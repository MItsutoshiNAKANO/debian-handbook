<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">14.3. Supervisão: Prevenção, Detecção, Desencorajamento</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-pt-BR-1.0-1" /><meta
        name="keywords"
        content="Firewall, Netfilter, IDS/NIDS" /><link
        rel="home"
        href="index.html"
        title="O Manual do Administrador Debian" /><link
        rel="up"
        href="security.html"
        title="Capítulo 14. Segurança" /><link
        rel="prev"
        href="sect.firewall-packet-filtering.html"
        title="14.2. Firewall ou Filtragem de pacotes" /><link
        rel="next"
        href="sect.apparmor.html"
        title="14.4. Introduction to AppArmor" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/pt-BR/sect.supervision.html" /></head><body
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>Anterior</strong></a></li><li
          class="home">O Manual do Administrador Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>Próxima</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.supervision"></a>14.3. Supervisão: Prevenção, Detecção, Desencorajamento</h2></div></div></div><a
          id="idm140590003635568"
          class="indexterm"></a><div
          class="para">
			O monitoramento é uma parte integrante de qualquer política de segurança por várias razões. Entre elas, que o objetivo da segurança não é normalmente restrito a garantir a confidencialidade dos dados, mas também inclui a disponibilidade assegurada dos serviços. Portanto, é imperativo verificar se tudo funciona como esperado, e para detectar em tempo hábil qualquer desvio no comportamento ou mudança na qualidade do(s) serviço(s) processado(s). Atividade de monitoramento pode ajudar a detectar tentativas de intrusão e permitir uma reação rápida antes que causem consequências graves. Esta seção analisa algumas ferramentas que podem ser usadas para monitorar vários aspectos de um sistema Debian. Como tal, completa a seção dedicada ao monitoramento genérico do sistema em <a
            class="xref"
            href="advanced-administration.html">Capítulo 12, <em>Administração Avançada</em></a>.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.logcheck"></a>14.3.1. Monitoramento de Logs com <code
                    class="command">logcheck</code></h3></div></div></div><a
            id="idm140590003631488"
            class="indexterm"></a><a
            id="idm140590003630368"
            class="indexterm"></a><a
            id="idm140590003628928"
            class="indexterm"></a><div
            class="para">
				O programa <code
              class="command">logcheck</code> monitora arquivos de log a cada hora por padrão. Ele envia mensagens de log incomuns em e-mails para o administrador, para posterior análise.
			</div><div
            class="para">
				The list of monitored files is stored in <code
              class="filename">/etc/logcheck/logcheck.logfiles</code>; the default values work fine if the <code
              class="filename">/etc/rsyslog.conf</code> file has not been completely overhauled.
			</div><div
            class="para">
				<code
              class="command">logcheck</code> pode trabalhar em um dos três modos mais ou menos detalhados: <span
              class="emphasis"><em>paranoid</em></span>, <span
              class="emphasis"><em>server</em></span> e <span
              class="emphasis"><em>workstation</em></span>. O primeiro é <span
              class="emphasis"><em>muito</em></span> verboso, e provavelmente deve ser restrito a servidores específicos, tais como firewalls. O segundo modo (e padrão) é recomendado para a maioria dos servidores. O último é projetado para estações de trabalho, e é ainda suscinto (que filtra mais mensagens).
			</div><div
            class="para">
				Nos três casos, <code
              class="command">logcheck</code> provavelmente deve ser personalizado para excluir algumas mensagens extras (dependendo dos serviços instalados), a menos que o administrador realmente deseje receber lotes por hora de longos e-mails desinteressantes. Uma vez que o mecanismo de seleção de mensagem é bastante complexo, <code
              class="filename">/usr/share/doc/logcheck-database/README.logcheck-database.gz</code> é uma necessidade - se desafiador - leia.
			</div><div
            class="para">
				As regras aplicadas podem ser divididas em vários tipos:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						aqueles que qualificam uma mensagem como uma tentativa de invasao (armazenado em um arquivo no diretorio <code
                    class="filename">/etc/logcheck/cracking.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						aqueles cancelando essas qualificaçoes (<code
                    class="filename">/etc/logcheck/cracking.ignore.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						aqueles classificando uma mensagem como um alerta de segurança (<code
                    class="filename">/etc/logcheck/violations.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						aqueles cancelando esta classificacao (<code
                    class="filename">/etc/logcheck/violations.ignore.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						finalmente, as que se aplicam às mensagens restantes (consideradas como <span
                    class="emphasis"><em>eventos de sistema</em></span>).
					</div></li></ul></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>ATENÇÃO</em></span> Ignorando uma mensagem</strong></p></div></div></div><div
              class="para">
				Qualquer mensagem marcada como uma tentativa de invasao ou um alerta de segurança (seguindo uma regra armazenada num arquivo <code
                class="filename">/etc/logcheck/violations.d/myfile</code>) só pode ser ignorada por uma regra em <code
                class="filename">/etc/logcheck/violations.ignore.d/myfile</code> ou no arquivo <code
                class="filename">/etc/logcheck/violations.ignore.d/myfile-<em
                  class="replaceable">extensão</em></code>.
			</div></div><div
            class="para">
				Um evento de sistema é sempre sinalizado a menos que uma regra em um dos diretorios <code
              class="filename">/etc/logcheck/ignore.d. {paranoid,server,workstation}/</code> indica que o evento deve ser ignorado. Naturalmente, apenas os directórios levados em consideração são aqueles que correspondem aos níveis de verbosidade iguais ou maiores que o modo de funcionamento seleccionado.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.monitoring-activity"></a>14.3.2. Monitorando Atividades</h3></div></div></div><a
            id="idm140590003606400"
            class="indexterm"></a><a
            id="idm140590003604960"
            class="indexterm"></a><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.real-time-monitoring"></a>14.3.2.1. Em Tempo Real</h4></div></div></div><div
              class="para">
					<code
                class="command">top</code> é uma ferramenta interativa que exibe uma lista de processos em execução. A triagem padrão baseia se na quantidade atual de utilização do processador e pode ser obtida com a tecla <span
                class="keycap"><strong>P</strong></span>. Outras ordens de classificação incluem uma espécie de memória ocupada (tecla <span
                class="keycap"><strong>M</strong></span>), pelo tempo total do processador (tecla <span
                class="keycap"><strong>T</strong></span>) e pelo identificador de processo (tecla <span
                class="keycap"><strong>N</strong></span>). A tecla <span
                class="keycap"><strong>k</strong></span> permite matar um processo, digitando seu identificador de processo. O tecla <span
                class="keycap"><strong>r</strong></span> permite <span
                class="emphasis"><em>renicing</em></span> um processo, ou seja, mudar sua prioridade.
				</div><a
              id="idm140590003598704"
              class="indexterm"></a><div
              class="para">
					Quando o sistema parece estar sobrecarregado, <code
                class="command">top</code> é uma ótima ferramenta para ver quais processos estão competindo por tempo de processador ou consumindo muita memória. Em particular, muitas vezes é interessante verificar se os recursos do processos que consomem coincidem com os serviços reais conhecidos que a máquina hospeda. Um processo desconhecido rodando como o usuário www-data deve realmente se destacar e ser investigado, já que é provavelmente uma instância do software instalado e executado no sistema através de uma vulnerabilidade em uma aplicação web.
				</div><div
              class="para">
					<code
                class="command">top</code> é uma ferramenta muito flexível e sua página de manual dá detalhes sobre como personalizar a sua exibição e adaptá la às nossas necessidades pessoais e hábitos.
				</div><div
              class="para">
					The <code
                class="command">gnome-system-monitor</code> graphical tool is similar to <code
                class="command">top</code> and it provides roughly the same features.
				</div><a
              id="idm140590003593632"
              class="indexterm"></a></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.monitoring-history"></a>14.3.2.2. Historia</h4></div></div></div><a
              id="idm140590003591296"
              class="indexterm"></a><div
              class="para">
					Carga do processador, o tráfego de rede e o espaço livre no disco são informações que variam constantemente. Manter um histórico de sua evolução é muitas vezes útil para determinar exatamente como o computador é usado.
				</div><a
              id="idm140590003589664"
              class="indexterm"></a><a
              id="idm140590003588704"
              class="indexterm"></a><div
              class="para">
					Existem muitas ferramentas dedicadas a esta tarefa. A maioria pode buscar dados via SNMP (<span
                class="emphasis"><em>Simple Network Management Protocol</em></span>, a fim de centralizar esta informação. Um benefício adicional é que este permite buscar dados de elementos de rede que podem não ser de computadores de uso geral, tais como roteadores de rede dedicadas ou switches.
				</div><div
              class="para">
					Este livro trata do Munin com algum detalhe (ver <a
                class="xref"
                href="sect.monitoring.html#sect.munin">Seção 12.4.1, “Configurando o Munin”</a>) como parte do <a
                class="xref"
                href="advanced-administration.html">Capítulo 12: “<em>Administração Avançada</em>”</a>. O Debian também fornece uma ferramenta similar, <span
                class="pkg pkg">cacti</span>. Sua implantação é um pouco mais complexa, pois se baseia apenas em SNMP. Apesar de ter uma interface web, compreender os conceitos envolvidos na configuração ainda requer algum esforço. Lendo a documentação HTML (<code
                class="filename">/usr/share/doc/cacti/html/index.html</code>) deve ser considerado um pré-requisito.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVO</em></span> <code
                          class="command">mrtg</code></strong></p></div></div></div><a
                id="idm140590003582336"
                class="indexterm"></a><div
                class="para">
					<code
                  class="command">mrtg</code> (do pacote com mesmo nome) é uma antiga ferramenta. Apesar de algumas arestas, ela pode agregar dados históricos e exibi-los na forma de gráficos. Ela inclui uma série de scripts dedicados à coleta de dados mais comumente monitorados, tais como a carga do processador, o tráfego de rede, acessos à página da web, e assim por diante.
				</div><div
                class="para">
					Os pacotes <span
                  class="pkg pkg">mrtg-contrib</span> e <span
                  class="pkg pkg">mrtgutils</span> contem exemplos de scripts que podem ser utilizados diretamente.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="idm140590003577568"></a>14.3.3. Detectando Modificações</h3></div></div></div><div
            class="para">
				Uma vez que o sistema esteja instalado e configurado, e impedindo atualizações de segurança, geralmente não há razão para a maioria dos arquivos e diretórios para evoluirem, exceeto os dados. É interessante, portanto, certificar se que os arquivos realmente não alteram: qualquer mudança seria, portanto, inesperada, valendo a pena investigar. Esta seção apresenta algumas ferramentas capazes de monitorar os arquivos e para avisar o administrador quando ocorrer uma mudança inesperada (ou simplesmente para listar tais mudanças).
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.dpkg-verify"></a>14.3.3.1. Auditing Packages with <code
                      class="command">dpkg --verify</code></h4></div></div></div><a
              id="idm140590003574400"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>INDO ALEM</em></span> Protegendo se contra mudanças mais significativas</strong></p></div></div></div><div
                class="para">
					<code
                  class="command">dpkg --verify</code> is useful in detecting changes to files coming from a Debian package, but it will be useless if the package itself is compromised, for instance if the Debian mirror is compromised. Protecting against this class of attacks involves using APT's digital signature verification system (see <a
                  class="xref"
                  href="sect.package-authentication.html">Seção 6.5, “Verificando Autenticidade do Pacote”</a>), and taking care to only install packages from a certified origin.
				</div></div><div
              class="para">
					<code
                class="command">dpkg --verify</code> (or <code
                class="command">dpkg -V</code>) is an interesting tool since it allows finding what installed files have been modified (potentially by an attacker), but this should be taken with a grain of salt. To do its job it relies on checksums stored in dpkg's own database which is stored on the hard disk (they can be found in <code
                class="filename">/var/lib/dpkg/info/<em
                  class="replaceable">package</em>.md5sums</code>); a thorough attacker will therefore update these files so they contain the new checksums for the subverted files.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>BACK TO BASICS</em></span> File fingerprint</strong></p></div></div></div><a
                id="idm140590003565808"
                class="indexterm"></a><a
                id="idm140590003564848"
                class="indexterm"></a><a
                id="idm140590003563888"
                class="indexterm"></a><a
                id="idm140590003562928"
                class="indexterm"></a><div
                class="para">
					As a reminder: a fingerprint is a value, often a number (even though in hexadecimal notation), that contains a kind of signature for the contents of a file. This signature is calculated with an algorithm (MD5 or SHA1 being well-known examples) that more or less guarantee that even the tiniest change in the file contents implies a change in the fingerprint; this is known as the “avalanche effect”. This allows a simple numerical fingerprint to serve as a litmus test to check whether the contents of a file have been altered. These algorithms are not reversible; in other words, for most of them, knowing a fingerprint doesn't allow finding the corresponding contents. Recent mathematical advances seem to weaken the absoluteness of these principles, but their use is not called into question so far, since creating different contents yielding the same fingerprint still seems to be quite a difficult task.
				</div></div><div
              class="para">
					Running <code
                class="command">dpkg -V</code> will verify all installed packages and will print out a line for each file with a failing test. The output format is the same as the one of <code
                class="command">rpm -V</code> where each character denotes a test on some specific meta-data. Unfortunately <code
                class="command">dpkg</code> does not store the meta-data needed for most tests and will thus output question marks for them. Currently only the checksum test can yield a "5" on the third character (when it fails).
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>dpkg -V</code></strong>
<code
                class="computeroutput">??5??????   /lib/systemd/system/ssh.service
??5?????? c /etc/libvirt/qemu/networks/default.xml
??5?????? c /etc/lvm/lvm.conf
??5?????? c /etc/salt/roster</code></pre><div
              class="para">
					In the sample above, dpkg reports a change to SSH's service file that the administrator made to the packaged file instead of using an appropriate <code
                class="filename">/etc/systemd/system/ssh.service</code> override. It also lists multiple configuration files (identified by the "c" letter on the second field) that had been legitimately modified.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.debsums"></a>14.3.3.2. Auditando Pacotes: <code
                      class="command">debsums</code> e seus limites</h4></div></div></div><a
              id="idm140590003553584"
              class="indexterm"></a><div
              class="para">
					<code
                class="command">debsums</code> is the ancestor of <code
                class="command">dpkg -V</code> and is thus mostly obsolete. It suffers from the same limitations than dpkg. Fortunately, some of the limitations can be worked-around (whereas dpkg does not offer similar work-arounds).
				</div><div
              class="para">
					Since the data on the disk cannot be trusted, <code
                class="command">debsums</code> offers to do its checks based on <code
                class="filename">.deb</code> files instead of relying on dpkg's database. To download trusted <code
                class="filename">.deb</code> files of all the packages installed, we can rely on APT's authenticated downloads. This operation can be slow and tedious, and should therefore not be considered a proactive technique to be used on a regular basis.
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</code></strong>
<code
                class="computeroutput">[ ... ]
# </code><strong
                class="userinput"><code>debsums -p /var/cache/apt/archives --generate=all</code></strong></pre><div
              class="para">
					Note que este exemplo usa o comando <code
                class="command">grep status</code> a partir do pacote <span
                class="pkg pkg">dctrl-tools</span>, que não é instalado por padrão.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="idm140590003545152"></a>14.3.3.3. Monitorando Arquivos: AIDE</h4></div></div></div><a
              id="idm140590003544384"
              class="indexterm"></a><div
              class="para">
					A ferramenta AIDE (<span
                class="emphasis"><em>Advanced Intrusion Detection Environment - Ambiente Avançado de Deteccao Intrusao</em></span>) permite verificar a integridade de arquivos, e detectar qualquer mudança em relacao a uma imagem gravada anteriormente do sistema válido. Esta imagem é armazenada como um banco de dados (<code
                class="filename"> /var/lib/aide/aide.db</code>) que contém as informações relevantes de todos os arquivos do sistema (impressões digitais, permissões, timestamps e assim por diante). Este banco de dados é inicializado com <code
                class="command">aideinit</code>, que é então usado diariamente (pelo script <code
                class="filename">/etc/cron.daily/</code> ) para verificar que nada de relevante mudou. Quando forem detectadas alterações, AIDE grava os em arquivos de log (<code
                class="filename">/var/log/aide/*.log</code>) e envia os seus resultados ao administrador por e-mail.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>NA PRATICA</em></span> Proteger o banco de dados</strong></p></div></div></div><div
                class="para">
					Como AIDE usa um banco de dados local para comparar os estados dos arquivos, a validade de seus resultados está diretamente ligada à validade do banco de dados. Se um atacante obtém permissões de root em um sistema comprometido, eles serão capazes de substituir o banco de dados e cobrir seus rastros. Uma possível solução seria armazenar os dados de referência em mídia somente leitura de armazenamento.
				</div></div><div
              class="para">
					Muitas opções em <code
                class="filename">/etc/default/aide</code> pode ser usadas para ajustar o comportamento do pacote <span
                class="pkg pkg">aide</span>. A configuração AIDE adequada é armazenada em <code
                class="filename">/etc/aide/aide.conf</code> e <code
                class="filename">/etc/aide/aide.conf.d/</code> (na verdade, esses arquivos são usados <code
                class="command">update-aide.conf</code> para gerar <code
                class="filename">/var/lib/aide/aide.conf.autogenerated</code>). Configuração indica quais propriedades de arquivos precisam ser verificadas. Por exemplo, o conteúdo de arquivos log muda rotineiramente, e estas modificações podem ser ignoradas, desde que as permissões destes arquivos permaneçam o mesmo, mas ambos os conteúdos e as permissões de programas executáveis devem ser constantes. Embora não seja muito complexo, a sintaxe de configuração não é totalmente intuitiva, e a leitura de <span
                class="citerefentry"><span
                  class="refentrytitle">aide.conf</span>(5)</span> da página do manual é recomendada.
				</div><div
              class="para">
					Uma nova versão do banco de dados é gerada diariamente em <code
                class="filename">/var/lib/aide/aide.db.new</code>, se todas alterações registradas eram legítimas, ele pode ser usado para substituir o banco de dados de referência.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVO</em></span> Tripwire and Samhain</strong></p></div></div></div><div
                class="para">
					Tripwire é muito semelhante ao AIDE; mesmo a sintaxe arquivo de configuração é quase a mesma. A adição principal fornecida pelo <span
                  class="pkg pkg">tripwire</span> é um mecanismo para assinar o arquivo de configuração, de modo que um atacante não pode torná lo ponto em uma versão diferente do banco de dados de referência.
				</div><div
                class="para">
					Samhain também oferece características semelhantes, bem como algumas funções ajudar a detectar rootkits (veja o quadro QUICK LOOK). Também pode ser implementado globalmente em uma rede, e gravar os seus vestigios em um servidor central (com uma assinatura).
				</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>BLOQUEIO RAPIDO</em></span> os pacotes <span
                          class="pkg pkg">checksecurity</span> e <span
                          class="pkg pkg">chkrootkit</span>/<span
                          class="pkg pkg">rkhunter</span></strong></p></div></div></div><a
                id="idm140590002601936"
                class="indexterm"></a><div
                class="para">
					O primeiro destes pacotes contém vários pequenos scripts que executam verificações básicas sobre o sistema (senhas vazias, arquivos setuid novos, e assim por diante) e alerta o administrador, se necessário. Apesar de seu nome expressar, um administrador não deve confiar somente nele para certificar se que um sistema Linux está seguro.
				</div><div
                class="para">
					Os pacotes <span
                  class="pkg pkg">chkrootkit</span> e <span
                  class="pkg pkg">rkhunter</span> permitem buscar por potenciais <span
                  class="emphasis"><em>rootkits</em></span> instalados no sistema. Como um lembrete, existem peças de software desenvolvidas para esconder o comprometimento de um sistema enquanto, discretamente, mantém o controle da máquina. Os testes não são 100% confiáveis, mas eles geralmente chamam a atenção do administrador para potenciais problemas.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.intrusion-detection"></a>14.3.4. Detectando Intrusoes (IDS/NIDS)</h3></div></div></div><a
            id="idm140590002595392"
            class="indexterm"></a><a
            id="idm140590002594432"
            class="indexterm"></a><a
            id="idm140590002593472"
            class="indexterm"></a><a
            id="idm140590002592512"
            class="indexterm"></a><a
            id="idm140590002591584"
            class="indexterm"></a><a
            id="idm140590002590624"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>DE VOLTA AO BASICO</em></span> Negação de serviço</strong></p></div></div></div><a
              id="idm140590002588064"
              class="indexterm"></a><div
              class="para">
				O ataque "negação de serviço" tem apenas um objetivo: tornar um serviço indisponível. Se tal ataque envolve a sobrecarrega do servidor com consultas ou explorar uma falha, o resultado final é o mesmo: o serviço não é mais operacional. Os usuários regulares estão infelizes, e a entidade que hospeda o serviço de rede alvo sofre uma perda de reputação (e, eventualmente, em receita, por exemplo, se o serviço era um site de comércio eletrônico).
			</div><div
              class="para">
				Tal ataque é por vezes "distribuído", o que geralmente envolve sobrecarregar o servidor com um grande número de consultas provenientes de muitas fontes diferentes para que o servidor se torna incapaz de responder às perguntas legítimas. Estes tipos de ataques ganharam siglas bem conhecidas: <acronym
                class="acronym">DoS</acronym> e <acronym
                class="acronym">DDoS</acronym> (dependendo se o ataque de negação de serviço distribuído ou não).
			</div></div><div
            class="para">
				<code
              class="command">suricata</code> (in the Debian package of the same name) is a NIDS — a <span
              class="emphasis"><em>Network Intrusion Detection System</em></span>. Its function is to listen to the network and try to detect infiltration attempts and/or hostile acts (including denial of service attacks). All these events are logged in multiple files in <code
              class="filename">/var/log/suricata</code>. There are third party tools (Kibana/logstash) to better browse all the data collected. <div
              class="url">→ <a
                href="http://suricata-ids.org">http://suricata-ids.org</a></div> <div
              class="url">→ <a
                href="https://www.elastic.co/products/kibana">https://www.elastic.co/products/kibana</a></div>
			</div><a
            id="idm140590002580304"
            class="indexterm"></a><a
            id="idm140590002579184"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>ATENCAO</em></span> Raio de ação</strong></p></div></div></div><div
              class="para">
				The effectiveness of <code
                class="command">suricata</code> is limited by the traffic seen on the monitored network interface. It will obviously not be able to detect anything if it cannot observe the real traffic. When plugged into a network switch, it will therefore only monitor attacks targeting the machine it runs on, which is probably not the intention. The machine hosting <code
                class="command">suricata</code> should therefore be plugged into the “mirror” port of the switch, which is usually dedicated to chaining switches and therefore gets all the traffic.
			</div></div><div
            class="para">
				Configuring suricata involves reviewing and editing <code
              class="filename">/etc/suricata/suricata-debian.yaml</code>, which is very long because because each parameter is abundantly commented. A minimal configuration requires describing the range of addresses that the local network covers (<code
              class="literal">HOME_NET</code> parameter). In practice, this means the set of all potential attack targets. But getting the most of it requires reading it in full and adapting it to the local situation.
			</div><div
            class="para">
				On top of this, you should also edit <code
              class="filename">/etc/default/suricata</code> to define the network interface to monitor and to enable the init script (by setting <code
              class="literal">RUN=yes</code>). You might also want to set <code
              class="literal">LISTENMODE=pcap</code> because the default <code
              class="literal">LISTENMODE=nfqueue</code> requires further configuration to work properly (the netfilter firewall must be configured to pass packets to some userspace queue handled by suricata via the <code
              class="literal">NFQUEUE</code> target).
			</div><div
            class="para">
				To detect bad behaviour, <code
              class="command">suricata</code> needs a set of monitoring rules: you can find such rules in the <span
              class="pkg pkg">snort-rules-default</span> package. <code
              class="command">snort</code> is the historical reference in the IDS ecosystem and <code
              class="command">suricata</code> is able to reuse rules written for it. Unfortunately that package is missing from <span
              class="distribution distribution">Debian Jessie</span> and should be retrieved from another Debian release like <span
              class="distribution distribution">Testing</span> or <span
              class="distribution distribution">Unstable</span>.
			</div><div
            class="para">
				Alternatively, <code
              class="command">oinkmaster</code> (in the package of the same name) can be used to download Snort rulesets from external sources.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>INDO MAIS</em></span> Integração com o <code
                        class="command">prelude</code></strong></p></div></div></div><div
              class="para">
				Prelude traz monitoramento centralizado de informações de segurança. Sua arquitetura modular inclui um servidor (o gerente <span
                class="emphasis"><em>manager</em></span> em <span
                class="pkg pkg">prelude-manager</span>) que reúne os alertas gerados por <span
                class="emphasis"><em>sensores</em></span> de vários tipos.
			</div><div
              class="para">
				Suricata can be configured as such a sensor. Other possibilities include <span
                class="emphasis"><em>prelude-lml</em></span> (<span
                class="emphasis"><em>Log Monitor Lackey</em></span>) which monitors log files (in a manner similar to <code
                class="command">logcheck</code>, described in <a
                class="xref"
                href="sect.supervision.html#sect.logcheck">Seção 14.3.1, “Monitoramento de Logs com <code
                  class="command">logcheck</code>”</a>).
			</div><a
              id="idm140590002557904"
              class="indexterm"></a></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>Anterior</strong>14.2. Firewall ou Filtragem de pacotes</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Acima</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Principal</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>Próxima</strong>14.4. Introduction to AppArmor</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.supervision.html">ar-MA</a></li><li><a
              href="../da-DK/sect.supervision.html">da-DK</a></li><li><a
              href="../de-DE/sect.supervision.html">de-DE</a></li><li><a
              href="../el-GR/sect.supervision.html">el-GR</a></li><li><a
              href="../en-US/sect.supervision.html">en-US</a></li><li><a
              href="../es-ES/sect.supervision.html">es-ES</a></li><li><a
              href="../fa-IR/sect.supervision.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.supervision.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.supervision.html">hr-HR</a></li><li><a
              href="../id-ID/sect.supervision.html">id-ID</a></li><li><a
              href="../it-IT/sect.supervision.html">it-IT</a></li><li><a
              href="../ja-JP/sect.supervision.html">ja-JP</a></li><li><a
              href="../pl-PL/sect.supervision.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.supervision.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.supervision.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.supervision.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.supervision.html">tr-TR</a></li><li><a
              href="../zh-CN/sect.supervision.html">zh-CN</a></li></ul></div></body></html>
