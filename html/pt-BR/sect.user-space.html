<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.5. O Espaço de Usuário</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.1" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-pt-BR-1.0-1" /><meta
        name="keywords"
        content="BIOS, Núcleo, Unix, Processo, Hierarquia, Comandos Básicos" /><link
        rel="home"
        href="index.html"
        title="O Manual do Administrador Debian" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Apêndice B. Curso Rápido de Reparação" /><link
        rel="prev"
        href="sect.kernel-role-and-tasks.html"
        title="B.4. Algumas Tarefas Manejadas pelo Núcleo" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/pt-BR/sect.user-space.html" /></head><body
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Anterior</strong></a></li><li
          class="home">O Manual do Administrador Debian</li><li
          class="next"></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.user-space"></a>B.5. O Espaço de Usuário</h2></div></div></div><a
          id="idm139775903819488"
          class="indexterm"></a><a
          id="idm139775903818528"
          class="indexterm"></a><div
          class="para">
			“User-space” refers to the runtime environment of normal (as opposed to kernel) processes. This does not necessarily mean these processes are actually started by users because a standard system normally has several “daemon” (or background) processes running before the user even opens a session. Daemon processes are also considered user-space processes.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.process-basics"></a>B.5.1. Processo</h3></div></div></div><a
            id="idm139775903815680"
            class="indexterm"></a><div
            class="para">
				When the kernel gets past its initialization phase, it starts the very first process, <code
              class="command">init</code>. Process #1 alone is very rarely useful by itself, and Unix-like systems run with many additional processes.
			</div><a
            id="idm139775903813536"
            class="indexterm"></a><div
            class="para">
				First of all, a process can clone itself (this is known as a <span
              class="emphasis"><em>fork</em></span>). The kernel allocates a new (but identical) process memory space, and another process to use it. At this time, the only difference between these two processes is their <span
              class="emphasis"><em>pid</em></span>. The new process is usually called a child process, and the original process whose <span
              class="emphasis"><em>pid</em></span> doesn't change, is called the parent process.
			</div><div
            class="para">
				Sometimes, the child process continues to lead its own life independently from its parent, with its own data copied from the parent process. In many cases, though, this child process executes another program. With a few exceptions, its memory is simply replaced by that of the new program, and execution of this new program begins. This is the mechanism used by the init process (with process number 1) to start additional services and execute the whole startup sequence. At some point, one process among <code
              class="command">init</code>'s offspring starts a graphical interface for users to log in to (the actual sequence of events is described in more details in <a
              class="xref"
              href="unix-services.html#sect.system-boot">Seção 9.1, “Inicialização do Sistema”</a>).
			</div><div
            class="para">
				Quando um processo termina a tarefa para a qual ele foi iniciado, ele termina. O kernel então recupera a memória atribuída para este processo, e para de dar porções de tempo de execução. É dito ao processo pai que seu processo filho que está sendo encerrado, o que permite que um processo aguardar a conclusão de uma tarefa que delegada a um processo filho. Este comportamento é claramente visível nos interpretadores de linha de comando (conhecido como <span
              class="emphasis"><em>shells</em></span>). Quando um comando é digitado em um shell, o prompt só volta quando a execução do comando é concluida. A maioria dos shells permitir a execução do comando em segundo plano simplesmente adicionando um <strong
              class="userinput"><code>&amp;</code></strong> no final do comando. O prompt é imediatamente exibido em seguida, o que pode ser um problema se o comando deve exibir dados próprios.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.daemons"></a>B.5.2. Daemons</h3></div></div></div><a
            id="idm139775903804928"
            class="indexterm"></a><a
            id="idm139775903803968"
            class="indexterm"></a><div
            class="para">
				Um "daemon" (serviço) é um processo iniciado automaticamente pela sequência de inicialização. Ele continua em execução (em segundo plano) para executar as tarefas de manutenção ou prover serviços a outros processos. Esta "tarefa em segundo plano" é realmente arbitrária e não tem uma importância especial do ponto de vista do sistema. Eles são simplesmente os processos, bastante semelhante a outros processos, que se executam quando está em sua porção de tempo. A distinção é apenas na língua humana: um processo que é executado sem interação com o usuário (em particular, sem qualquer interface gráfica) é dita estar em execução "em segundo plano" ou "como um serviço".
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>VOCABULÁRIO</em></span> Daemon, demon, um termo depreciativo?</strong></p></div></div></div><div
              class="para">
				Em inglês, utiliza-se o termo <span
                class="emphasis"><em>daemon</em></span> compartilhando sua etimologia grega com <span
                class="emphasis"><em>demônio</em></span>, o que não implica formalmente mal diabólico, ao contrário, deve ser entendido como uma espécie de espírito ajudante. Esta distinção é sutil o suficiente em inglês; é ainda pior em outras línguas em que a mesma palavra é usada para ambos os significados.
			</div></div><div
            class="para">
				Vários desses daemon são descritos em detalhe em <a
              class="xref"
              href="unix-services.html">Capítulo 9, <em>Serviços Unix</em></a>.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.ipc"></a>B.5.3. Comunicação Inter Processos</h3></div></div></div><a
            id="idm139775903796816"
            class="indexterm"></a><a
            id="idm139775903795856"
            class="indexterm"></a><div
            class="para">
				Um processo isolado, seja um daemon ou um aplicativo interativo, raramente é útil por si só, e é por isso que existem vários métodos que permitem a comunicação entre os processos separados, seja para troca de dados ou para controlar um ao outro. O termo genérico que se refere a isso é <span
              class="emphasis"><em>comunicação entre processos</em></span>, ou IPC (Inter-Process Communication) para abreviar.
			</div><div
            class="para">
				O sistema IPC mais simples é utilizar arquivos. O processo que deseja enviar dados escreve-os em um arquivo (com um nome já conhecido), enquanto o destinatário só precisa abrir o arquivo e ler seu conteúdo.
			</div><a
            id="idm139775903793056"
            class="indexterm"></a><div
            class="para">
				In the case where you do not wish to store data on disk, you can use a <span
              class="emphasis"><em>pipe</em></span>, which is simply an object with two ends; bytes written in one end are readable at the other. If the ends are controlled by separate processes, this leads to a simple and convenient inter-process communication channel. Pipes can be classified into two categories: named pipes, and anonymous pipes. A named pipe is represented by an entry on the filesystem (although the transmitted data is not stored there), so both processes can open it independently if the location of the named pipe is known beforehand. In cases where the communicating processes are related (for instance, a parent and its child process), the parent process can also create an anonymous pipe before forking, and the child inherits it. Both processes will then be able to exchange data through the pipe without needing the filesystem.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>NA PRÁTICA</em></span> Um exemplo concreto</strong></p></div></div></div><div
              class="para">
				Vamos descrever em detalhes o que acontece quando um comando complexo (um <span
                class="emphasis"><em>pipeline</em></span>) é executado a partir de um shell. Vamos assumir que temos um processo <code
                class="command">bash</code> (o shell do usuário padrão no Debian), com <span
                class="emphasis"><em>pid</em></span> 4374; neste shell podemos digitar o comando: <code
                class="command">ls | sort</code>.
			</div><div
              class="para">
				O shell interpreta pela primeira vez o comando digitado nele. No nosso caso, ele entende que existem dois programas (<code
                class="command">ls</code> e <code
                class="command">sort</code>), com um fluxo de dados que flui de um para o outro (denotada pelo caractere <strong
                class="userinput"><code>|</code></strong>, conhecido como <span
                class="emphasis"><em>pipe</em></span>). O <code
                class="command">bash</code> primeiro cria um pipe sem nome (que inicialmente só existe dentro do processo <code
                class="command">bash</code> em si).
			</div><div
              class="para">
				Então o shell se clona; isso leva a um novo processo <code
                class="command">bash</code> com <span
                class="emphasis"><em>pid</em></span> #4521 (<span
                class="emphasis"><em>pids</em></span> são números abstratos e geralmente não têm significado particular). O processo #4521 herda o pipe, o que significa que é capaz de escrever em seu lado de "entrada"; o <code
                class="command">bash</code> redireciona seu fluxo de saída padrão para a entrada deste pipe. Em seguida, ele executa (e substitui-se com) o <code
                class="command">ls</code> do programa, que lista o conteúdo do diretório atual. Como o <code
                class="command">ls</code> escreve em sua saída padrão, e anteriormente se direcionou esta saída, seus resultados são efetivamente enviados para o pipe.
			</div><div
              class="para">
				Uma operação similar acontece para o segundo comando: o<code
                class="command">bash</code> se clona novamente, levando a um novo processo <code
                class="command">bash</code> com pid #4522. Como também é um processo filho do #4374, também herda o pipe; em seguida o <code
                class="command">bash</code> conecta sua entrada padrão para a saída do pipe, então executa (e se substitui com) o <code
                class="command">sort</code>, que classifica sua entrada e exibe os resultados.
			</div><div
              class="para">
				Todas as peças do quebra-cabeça agora estão definidas: o <code
                class="command">ls</code> lê o diretório atual e escreve a lista de arquivos dentro do pipe; o <code
                class="command">sort</code> lê esta lista, classifica-a em ordem alfabética e exibe os resultados. Os processos números #4521 e #4522 encerram, e o #4374 (que estava esperando por eles durante a operação), retoma o controle e exibe o prompt permitindo que o usuário digite um novo comando.
			</div></div><div
            class="para">
				Not all inter-process communications are used to move data around, though. In many situations, the only information that needs to be transmitted are control messages such as “pause execution” or “resume execution”. Unix (and Linux) provides a mechanism known as <span
              class="emphasis"><em>signals</em></span>, through which a process can simply send a specific signal (chosen from a predefined list of signals) to another process. The only requirement is to know the <span
              class="emphasis"><em>pid</em></span> of the target.
			</div><div
            class="para">
				For more complex communications, there are also mechanisms allowing a process to open access, or share, part of its allocated memory to other processes. Memory now shared between them can be used to move data between the processes.
			</div><div
            class="para">
				Finalmente, as conexões de rede também pode ajudar a comunicação de processos; esses processos podem até ser executados em diferentes computadores, possivelmente a milhares de quilômetros de distância.
			</div><div
            class="para">
				É bastante normal para um típico sistema similar ao Unix fazer uso de todos esses mecanismos em vários graus.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.libraries"></a>B.5.4. Bibliotecas</h3></div></div></div><a
            id="idm139775903770672"
            class="indexterm"></a><div
            class="para">
				Bibliotecas de funções desempenham um papel crucial em um sistema operacional similar ao Unix. Eles não são programas propriamente dito, uma vez que não podem ser executados por si próprios, mas coleções de fragmentos de código que podem ser utilizados pelos programas normais. Entre as bibliotecas comuns, você pode encontrar:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						a biblioteca padrão C (<span
                    class="emphasis"><em>glibc</em></span>), que contém as funções básicas como aqueles para abrir arquivos ou conexões de rede, e outras que facilitam as interações com o kernel;
					</div></li><li
                class="listitem"><div
                  class="para">
						toolkits gráficos, como Gtk+ e o Qt, permitindo que muitos programas reutilizem os objetos gráficos que eles provêm;
					</div></li><li
                class="listitem"><div
                  class="para">
						a biblioteca <span
                    class="emphasis"><em>libpng</em></span> que permite carregar, interpretar e salvar imagens no formato PNG.
					</div></li></ul></div><div
            class="para">
				Thanks to those libraries, applications can reuse existing code. Application development is simplified since many applications can reuse the same functions. With libraries often developed by different persons, the global development of the system is closer to Unix's historical philosophy.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CULTURA</em></span> O Estilo Unix; uma coisa de cada vez</strong></p></div></div></div><div
              class="para">
				One of the fundamental concepts that underlies the Unix family of operating systems is that each tool should only do one thing, and do it well; applications can then reuse these tools to build more advanced logic on top. This philosophy can be seen in many incarnations. Shell scripts may be the best example: they assemble complex sequences of very simple tools (such as <code
                class="command">grep</code>, <code
                class="command">wc</code>, <code
                class="command">sort</code>, <code
                class="command">uniq</code> and so on). Another implementation of this philosophy can be seen in code libraries: the <span
                class="emphasis"><em>libpng</em></span> library allows reading and writing PNG images, with different options and in different ways, but it does only that; no question of including functions that display or edit images.
			</div></div><div
            class="para">
				Além disso, essas bibliotecas muitas vezes são referidas como "bibliotecas compartilhadas", desde que o kernel possa carregá-las apenas uma vez para a memória, mesmo se vários processos utilizam a mesma biblioteca ao mesmo tempo. Isso permite economia de memória, quando comparado com a situação oposta (hipotética), onde o código para uma biblioteca seria carregada tantas vezes quantos os processos que a utilizam.
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Anterior</strong>B.4. Algumas Tarefas Manejadas pelo Núcleo</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Acima</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Principal</strong></a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.user-space.html">ar-MA</a></li><li><a
              href="../da-DK/sect.user-space.html">da-DK</a></li><li><a
              href="../de-DE/sect.user-space.html">de-DE</a></li><li><a
              href="../el-GR/sect.user-space.html">el-GR</a></li><li><a
              href="../en-US/sect.user-space.html">en-US</a></li><li><a
              href="../es-ES/sect.user-space.html">es-ES</a></li><li><a
              href="../fa-IR/sect.user-space.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.user-space.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.user-space.html">hr-HR</a></li><li><a
              href="../id-ID/sect.user-space.html">id-ID</a></li><li><a
              href="../it-IT/sect.user-space.html">it-IT</a></li><li><a
              href="../ja-JP/sect.user-space.html">ja-JP</a></li><li><a
              href="../pl-PL/sect.user-space.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.user-space.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.user-space.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.user-space.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.user-space.html">tr-TR</a></li><li><a
              href="../zh-CN/sect.user-space.html">zh-CN</a></li></ul></div></body></html>
