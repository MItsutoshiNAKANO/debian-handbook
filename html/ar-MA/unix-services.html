<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">فصل 9. خدمات يونكس</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.1" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-ar-MA-1.0-1" /><meta
        name="keywords"
        content="إقلاع النظام, سكربتات Init, SSH , Telnet, حقوق, صلاحيات, إشراف, Inetd, Cron, النسخ الاحتياطي, توصيل ساخن, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="دفتر مدير دبيان" /><link
        rel="up"
        href="index.html"
        title="دفتر مدير دبيان" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. تثبيت النواة" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. تسجيل الدخول عن بعد" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/ar-MA/unix-services.html" /></head><body
      dir="rtl"
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>السابق</strong></a></li><li
          class="home">دفتر مدير دبيان</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>التالي</strong></a></li></ul><div
        xml:lang="ar-MA"
        class="chapter"
        lang="ar-MA"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  id="unix-services"></a>فصل 9. خدمات يونكس</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. إقلاع النظام</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. The systemd init system</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. The System V init system</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. تسجيل الدخول عن بعد</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. الدخول البعيد الآمن: SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. استخدام سطوح المكتب الرسومية البعيدة</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. إدارة الصلاحيات</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. واجهات الإدارة</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. الإدارة على واجهة وب: <code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. ضبط الحزم: <code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. أحداث <code
                    class="command">syslog</code></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. المبدأ والآلية</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. ملف الإعداد</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. المخدم الفائق <code
                    class="command">inetd</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. جدولة المهام باستخدام <code
                    class="command">cron</code> و<code
                    class="command">atd</code></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. صيغة ملف <code
                        class="filename">crontab</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. استخدام الأمر <code
                        class="command">at</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. جدولة المهام غير المتزامنة: <code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. الحصص التخزينية</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. النسخ الاحتياطي</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#idm140565132944176">9.10.1. النسخ الاحتياطي باستخدام <code
                        class="command">rsync</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#idm140565132902384">9.10.2. استعادة الأجهزة دون نسخ احتياطي</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. التوصيل الساخن: <span
                    class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm140565132884832">9.11.1. مقدمة</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm140565132875872">9.11.2. مشكلة التسمية</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm140565132861584">9.11.3. طريقة عمل <span
                        class="emphasis"><em>udev</em></span></a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm140565132804288">9.11.4. مثال واقعي</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. إدارة الطاقة: Advanced Configuration and Power Interface ‏(ACPI)</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		يغطي هذا الفصل عدداً من الخدمات الأساسية المشتركة بين العديد من أنظمة يونكس التي يجب أن يعرفها كل مدير نظام.
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    id="sect.system-boot"></a>9.1. إقلاع النظام</h2></div></div></div><a
            id="idm140565134354544"
            class="indexterm"></a><div
            class="para">
			عند إقلاع الحاسب، تعرض الرسائل العديدة التي تمر على الشاشة العديد من الإعدادات وعمليات التهيئة الجارية. قد ترغب أحياناً بتعديل هذه المرحلة قليلاً، مما يعني أنك تحتاج فهمها جيداً. هذا هو الهدف من هذا القسم.
		</div><div
            class="para">
			First, the BIOS takes control of the computer, detects the disks, loads the <span
              class="emphasis"><em>Master Boot Record</em></span>, and executes the bootloader. The bootloader takes over, finds the kernel on the disk, loads and executes it. The kernel is then initialized, and starts to search for and mount the partition containing the root filesystem, and finally executes the first program — <code
              class="command">init</code>. Frequently, this “root partition” and this <code
              class="command">init</code> are, in fact, located in a virtual filesystem that only exists in RAM (hence its name, “initramfs”, formerly called “initrd” for “initialization RAM disk”). This filesystem is loaded in memory by the bootloader, often from a file on a hard drive or from the network. It contains the bare minimum required by the kernel to load the “true” root filesystem: this may be driver modules for the hard drive, or other devices without which the system cannot boot, or, more frequently, initialization scripts and modules for assembling RAID arrays, opening encrypted partitions, activating LVM volumes, etc. Once the root partition is mounted, the initramfs hands over control to the real init, and the machine goes back to the standard boot process.
		</div><div
            class="figure"><a
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="Boot sequence of a computer running Linux with systemd" /></div></div><p
              class="title"><strong>شكل 9.1. Boot sequence of a computer running Linux with systemd</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.systemd"></a>9.1.1. The systemd init system</h3></div></div></div><div
              class="para">
				The “real init” is currently provided by <span
                class="pkg pkg">systemd</span> and this section documents this init system.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CULTURE</em></span> Before <code
                          class="command">systemd</code></strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> is a relatively recent “init system”, and although it was already available, to a certain extent, in <span
                  class="distribution distribution">Wheezy</span>, it has only become the default in Debian <span
                  class="distribution distribution">Jessie</span>. Previous releases relied, by default, on the “System V init” (in the <span
                  class="pkg pkg">sysv-rc</span> package), a much more traditional system. We describe the SysV init later on.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>بدائل</em></span> نظم إقلاعية أخرى</strong></p></div></div></div><div
                class="para">
				This book describes the boot system used by default in Debian <span
                  class="distribution distribution">Jessie</span> (as implemented by the <span
                  class="pkg pkg">systemd</span> package), as well as the previous default, <span
                  class="pkg pkg">sysvinit</span>, which is derived and inherited from <span
                  class="emphasis"><em>System_V</em></span> Unix systems; there are others.
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> هو نظام إقلاعي بتصميم بسيط جداً. يحافظ هذا النظام على مبدأ مستويات التشغيل، لكنه يستبدل الأوامر التوجيهية والروابط الرمزية بملف إعداد، الذي يشير إلى عمليات <code
                  class="command">init</code> التي يجب استدعاؤها كما يحدد ترتيب تشغيلها.
			</div><div
                class="para">
				The <code
                  class="command">upstart</code> system is still not perfectly tested on Debian. It is event based: init scripts are no longer executed in a sequential order but in response to events such as the completion of another script upon which they are dependent. This system, started by Ubuntu, is present in Debian <span
                  class="distribution distribution">Jessie</span>, but is not the default; it comes, in fact, as a replacement for <span
                  class="pkg pkg">sysvinit</span>, and one of the tasks launched by <code
                  class="command">upstart</code> is to launch the scripts written for traditional systems, especially those from the <span
                  class="pkg pkg">sysv-rc</span> package.
			</div><div
                class="para">
				هناك نظم إقلاع أخرى وأوضاع عمل أخرى، مثل <code
                  class="command">runit</code>،‏ <code
                  class="command">minit</code>، أو <code
                  class="command">initng</code>، لكنها جميعاً متخصصة نسبياً وغير منتشرة على نطاق واسع.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>حالة خاصة</em></span> الإقلاع من الشبكة</strong></p></div></div></div><div
                class="para">
				في بعض الحالات، قد يتم ضبط BIOS بحيث لا ينفذ MBR، بل يبحث عن مكافئه على الشبكة، وهذا يسمح بتجميع حواسيب بدون أقراص صلبة، أو تجهيز حواسيب يعاد تثبيت النظام عليها عند كل إقلاع. هذا الخيار غير متوفر في جميع الأجهزة وهو يحتاج توافقاً مناسباً بين BIOS وبطاقة الشبكة عموماً.
			</div><div
                class="para">
				يمكن استخدام الإقلاع من الشبكة لتشغيل <code
                  class="command">debian-installer</code> أو FAI (انظر <a
                  class="xref"
                  href="installation.html#sect.installation-methods">قسم 4.1, “طرائق التثبيت”</a>).
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>أساسيات</em></span> العملية، نسخة من البرنامج</strong></p></div></div></div><a
                id="idm140565136458416"
                class="indexterm"></a><div
                class="para">
				العملية process هي التمثيل الذاكري للبرنامج، وهي تحوي كل المعلومات اللازمة للتنفيذ السليم للبرمجية (تحوي الشفرة البرمجية نفسها، بالإضافة إلى البيانات التي تخزنها في الذاكرة، ولائحة الملفات التي فتحتها، والاتصالات الشبكية التي أنشأتها، الخ). يمكن إنشاء عدد من العمليات من برنامج واحد، ولا يشترط أن تعمل تحت مستخدمين مختلفين.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>أمن</em></span> استخدام الصدفة بدل <code
                          class="command">init</code> للحصول على صلاحيات الجذر</strong></p></div></div></div><div
                class="para">
				By convention, the first process that is booted is the <code
                  class="command">init</code> program (which is a symbolic link to <code
                  class="filename">/lib/systemd/systemd</code> by default). However, it is possible to pass an <code
                  class="literal">init</code> option to the kernel indicating a different program.
			</div><a
                id="idm140565136452912"
                class="indexterm"></a><div
                class="para">
				بوسع أي شخص يستطيع الوصول للحاسوب الضغط على زر <span
                  class="keycap"><strong>Reset</strong></span>، وبالتالي إعادة إقلاع الجهاز. بعدها، من الممكن، عند الوصول إلى شاشة محمل الإقلاع، تمرير الخيار <code
                  class="literal">init=/bin/sh</code> للنواة للحصول على صلاحيات الجذر دون معرفة كلمة سر مدير النظام.
			</div><div
                class="para">
				لمنع هذا يمكنك حماية محمل الإقلاع نفسه بكلمة سر. يمكنك أيضاً الأخذ بعين الاعتبار حماية الوصول إلى BIOS (ميزة حماية BIOS بكلمة سر متوفرة دائماً تقريباً)، إذ بدونها يستطيع أي متطفل خبيث إقلاع الجهاز من وسيط تخزين نقال عليه نسخة لينكس يستطيع استخدامها للوصول إلى المعلومات على الأقراص الصلبة للحاسب.
			</div><div
                class="para">
				أخيراً، عليك الحذر من أن معظم نظم BIOS لها كلمات سر عامة. القصد الأساسي وراء هذه الكلمات هو مساعدة الذين ينسون كلمات مرورهم، لكن كلمات السر هذه أصبحت علنية الآن ومتاحة على الإنترنت (تأكد بنفسك بالبحث عن ”generic BIOS passwords“ في أي محرك بحث). إذن سوف تعيق جميع وسائل الحماية هذه الوصول غير المصرح به للحواسيب لكن لن تمنعه بشكل كامل. لا توجد طريقة موثوقة لحماية حاسب ما إذا كان المخترق يستطيع الوصول إليه فيزيائياً؛ إذ يمكنه فصل الأقراص الصلبة وتوصيلها بحاسب آخر على أي حال، أو يسرق الجهاز كله، أو يمحو ذاكرة BIOS لإزالة كلمة السر…
			</div></div><div
              class="para">
				Systemd executes several processes, in charge of setting up the system: keyboard, drivers, filesystems, network, services. It does this while keeping a global view of the system as a whole, and the requirements of the components. Each component is described by a “unit file” (sometimes more); the general syntax is derived from the widely-used “*.ini files“ syntax, with <code
                class="literal"><em
                  class="replaceable">key</em> = <em
                  class="replaceable">value</em></code> pairs grouped between <code
                class="literal">[<em
                  class="replaceable">section</em>]</code> headers. Unit files are stored under <code
                class="filename">/lib/systemd/system/</code> and <code
                class="filename">/etc/systemd/system/</code>; they come in several flavours, but we'll focus on “services” and “targets” here.
			</div><div
              class="para">
				A systemd “service file” describes a process managed by systemd. It contains roughly the same information as old-style init-scripts, but expressed in a declaratory way (and much more concise) way. Systemd handles the bulk of the repetitive tasks (starting and stopping the process, checking its status, logging, dropping privileges, and so on), and the service file only needs to fill in the specifics of the process. For instance, here's the service file for SSH:
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service
</pre><div
              class="para">
				As you can see, there's very little code in there, only declarations. Systemd takes care of displaying progress reports, keeping track of the processes, and even restarting them when needed.
			</div><div
              class="para">
				A systemd “target file” describes a state of the system, where a set of services are known to be operational. It can be thought of as an equivalent of the old-style runlevel. One of the targets is <code
                class="literal">local-fs.target</code>; when it is reached, the rest of the system can assume that all local filesystems are mounted and accessible. Other targets include <code
                class="literal">network-online.target</code> and <code
                class="literal">sound.target</code>. The dependencies of a target can be listed either within the target file (in the <code
                class="literal">Requires=</code> line), or using a symbolic link to a service file in the <code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">targetname</em>.target.wants/</code> directory. For instance, <code
                class="filename">/etc/systemd/system/printer.target.wants/</code> contains a link to <code
                class="filename">/lib/systemd/system/cups.service</code>; systemd will therefore ensure CUPS is running in order to reach <code
                class="literal">printer.target</code>.
			</div><div
              class="para">
				Since unit files are declarative rather than scripts or programs, they cannot be run directly, and they are only interpreted by systemd; several utilities therefore allow the administrator to interact with systemd and control the state of the system and of each component.
			</div><div
              class="para">
				The first such utility is <code
                class="command">systemctl</code>. When run without any arguments, it lists all the unit files known to systemd (except those that have been disabled), as well as their status. <code
                class="command">systemctl status</code> gives a better view of the services, as well as the related processes. If given the name of a service (as in <code
                class="command">systemctl status ntp.service</code>), it returns even more details, as well as the last few log lines related to the service (more on that later).
			</div><div
              class="para">
				Starting a service by hand is a simple matter of running <code
                class="command">systemctl start <em
                  class="replaceable">servicename</em>.service</code>. As one can guess, stopping the service is done with <code
                class="command">systemctl stop <em
                  class="replaceable">servicename</em>.service</code>; other subcommands include <code
                class="command">reload</code> and <code
                class="command">restart</code>.
			</div><div
              class="para">
				To control whether a service is active (i.e. whether it will get started automatically on boot), use <code
                class="command">systemctl enable <em
                  class="replaceable">servicename</em>.service</code> (or <code
                class="command">disable</code>). <code
                class="command">is-enabled</code> allows checking the status of the service.
			</div><div
              class="para">
				An interesting feature of systemd is that it includes a logging component named <code
                class="command">journald</code>. It comes as a complement to more traditional logging systems such as <code
                class="command">syslogd</code>, but it adds interesting features such as a formal link between a service and the messages it generates, and the ability to capture error messages generated by its initialisation sequence. The messages can be displayed later on, with a little help from the <code
                class="command">journalctl</code> command. Without any arguments, it simply spews all log messages that occurred since system boot; it will rarely be used in such a manner. Most of the time, it will be used with a service identifier:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				Another useful command-line flag is <code
                class="command">-f</code>, which instructs <code
                class="command">journalctl</code> to keep displaying new messages as they are emitted (much in the manner of <code
                class="command">tail -f <em
                  class="replaceable">file</em></code>).
			</div><div
              class="para">
				If a service doesn't seem to be working as expected, the first step to debug the problem are to check that the service is actually running with <code
                class="command">systemctl status</code>; if it is not, and the messages given by the first command are not enough to diagnose the problem, check the logs gathered by journald about that service. For instance, assume the SSH server doesn't work:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				After checking the status of the service (failed), we went on to check the logs; they indicate an error in the configuration file. After editing the configuration file and fixing the error, we restart the service, then verify that it is indeed running.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GOING FURTHER</em></span> Other types of unit files</strong></p></div></div></div><div
                class="para">
				We've only described the most basic of systemd's capabilities in this section. It offers many other interesting features; we'll only list a few here:
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						socket activation: a “socket” unit file can be used to describe a network or Unix socket managed by systemd; this means that the socket will be created by systemd, and the actual service may be started on demand when an actual connection attempt comes. This roughly replicates the feature set of <code
                        class="command">inetd</code>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						timers: a “timer” unit file describes events that occur with a fixed frequency; when a service is linked to such a timer, the corresponding task will be executed whenever the timer fires. In a similar fashion, a “time” unit file describes events that occur on specific times. This allows replicating part of the <code
                        class="command">cron</code> features.
					</div></li><li
                    class="listitem"><div
                      class="para">
						network: a “network“ unit file describes a network interface, which allows configuring such interfaces as well as expressing that a service depends on one particular interface being up.
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.sysvinit"></a>9.1.2. The System V init system</h3></div></div></div><div
              class="para">
				The System V init system (which we'll call init for brevity) executes several processes, following instructions from the <code
                class="filename">/etc/inittab</code> file. The first program that is executed (which corresponds to the <span
                class="emphasis"><em>sysinit</em></span> step) is <code
                class="command">/etc/init.d/rcS</code>, a script that executes all of the programs in the <code
                class="filename">/etc/rcS.d/</code> directory. <a
                id="idm140565146048448"
                class="indexterm"></a> <a
                id="idm140565146047648"
                class="indexterm"></a> <a
                id="idm140565146046848"
                class="indexterm"></a> <a
                id="idm140565146046048"
                class="indexterm"></a>
			</div><div
              class="para">
				من ضمن هذه البرامج سوف تجد –على التعاقب– برامجاً مسؤولة عن:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						إعداد لوحة مفاتيح الطرفية؛
					</div></li><li
                  class="listitem"><div
                    class="para">
						تحميل التعاريف: تحمّل النواة معظم التعاريف عند اكتشاف العتاد؛ بعدها تحمل التعاريف الإضافية آلياً إذا كانت الوحدات الموافقة لها مذكورة في <code
                      dir="ltr"
                      class="filename">/etc/modules</code>؛
					</div></li><li
                  class="listitem"><div
                    class="para">
						التحقق من سلامة نظام الملفات؛
					</div></li><li
                  class="listitem"><div
                    class="para">
						ربط الأقسام المحلية؛
					</div></li><li
                  class="listitem"><div
                    class="para">
						إعداد الشبكة؛
					</div></li><li
                  class="listitem"><div
                    class="para">
						ربط نظم الملفات الشبكية (NFS).
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>أساسيات</em></span> وحدات النواة والخيارات</strong></p></div></div></div><a
                id="idm140565146036432"
                class="indexterm"></a><div
                class="para">
				هناك خيارات لوحدات النواة أيضاً يمكن ضبطها بوضع بعض الملفات في <code
                  class="filename">/etc/modprobe.d/</code>. تعرف هذه الخيارات بتعليمات توجيهية تشبه هذه: <code
                  class="literal">options <em
                    class="replaceable">module-name</em> <em
                    class="replaceable">option-name</em>=<em
                    class="replaceable">option-value</em></code>. يمكن تحديد عدة خيارات بتعليمة توجيهية واحدة إذا اقتضى الأمر.
			</div><div
                class="para">
				ملفات الضبط هذه تابعة لبرنامج <code
                  class="command">modprobe</code> – وهو البرنامج الذي يحمل وحدات النواة مع اعتمادياتها (تستطيع وحدات النواة بالفعل استدعاء وحدات أخرى). هذا البرنامج متوفر في الحزمة <span
                  class="pkg pkg">kmod</span>.
			</div><a
                id="idm140565146030192"
                class="indexterm"></a><a
                id="idm140565146029072"
                class="indexterm"></a></div><div
              class="para">
				After this stage, <code
                class="command">init</code> takes over and starts the programs enabled in the default runlevel (which is usually runlevel 2). It executes <code
                class="command">/etc/init.d/rc 2</code>, a script that starts all services which are listed in <code
                class="filename">/etc/rc2.d/</code> and whose names start with the “S” letter. The two-figures number that follows had historically been used to define the order in which services had to be started, but nowadays the default boot system uses <code
                class="command">insserv</code>, which schedules everything automatically based on the scripts' dependencies. Each boot script thus declares the conditions that must be met to start or stop the service (for example, if it must start before or after another service); <code
                class="command">init</code> then launches them in the order that meets these conditions. The static numbering of scripts is therefore no longer taken into consideration (but they must always have a name beginning with “S” followed by two digits and the actual name of the script used for the dependencies). Generally, base services (such as logging with <code
                class="command">rsyslog</code>, or port assignment with <code
                class="command">portmap</code>) are started first, followed by standard services and the graphical interface (<code
                class="command">gdm3</code>).
			</div><div
              class="para">
				يسمح نظام الإقلاع الاعتمادي هذا بأتمتة عملية إعادة الترقيم، وهذه عملية متعبة جداً لو كانت ستتم يدوياً، كما يحد من الأخطاء البشرية، بما أن الجدولة تجري وفقاً للقيود المفروضة. هناك أيضاً ميزة أخرى، وهي أن تشغيل الخدمات يمكن أن يتم على التوازي إذا كانت مستقلة عن بعضها، وهذا يسرع عملية الإقلاع.
			</div><a
              id="idm140565146021456"
              class="indexterm"></a><a
              id="idm140565146020496"
              class="indexterm"></a><div
              class="para">
				تفرق <code
                class="command">init</code> بين عدة مستويات تشغيلية، بحيث يمكن التبديل من أحد هذه المستويات إلى الآخر بالأمر <code
                class="command">telinit <em
                  class="replaceable">new-level</em></code>. تبدأ <code
                class="command">init</code> فوراً تنفيذ <code
                dir="ltr"
                class="command">/etc/init.d/rc</code> مرة ثانية ولكن في المستوى التشغيلي الجديد. بعدها يبدأ هذا السكربت تشغيل الخدمات الناقصة وإيقاف الخدمات التي لم تعد مرغوبة. لإتمام هذه المهمة، يستند هذا السكربت على محتويات <code
                dir="ltr"
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> (حيث <em
                class="replaceable">X</em> تمثل المستوى الجديد). السكربتات التي تبدأ بالحرف ”S“ (من كلمة ”Start“) هي الخدمات التي يجب تشغيلها؛ أما التي تبدأ بالحرف ”K“ (من كلمة ”Kill“) فهي الخدمات التي يجب إيقافها. لا يشغل السكربت أي خدمة كانت فعالة مسبقاً في المستوى التشغيلي السابق.
			</div><div
              class="para">
				By default, System V init in Debian uses four different runlevels:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						المستوى 0 يستخدم مؤقتاً فقط أثناء إيقاف تشغيل الحاسب. ولذلك فهو لا يحوي إلا عدة سكربتات ”K“ فقط.
					</div></li><li
                  class="listitem"><div
                    class="para">
						المستوى 1، ويعرف أيضاً بوضع المستخدم الوحيد single-user mode، وهو يمثل النظام في وضع الأداء المنخفض؛ فهو يُحَمِّل الخدمات الأساسية فقط، وهو يستخدم لأغراض الصيانة بعيداً عن تفاعل المستخدمين.
					</div></li><li
                  class="listitem"><div
                    class="para">
						المستوى 2 هو مستوى العمل الطبيعي، الذي يتضمن خدمات الشبكة، والواجهة الرسومية، واتصالات المستخدمين، الخ.
					</div></li><li
                  class="listitem"><div
                    class="para">
						المستوى 6 يشبه المستوى 0، عدا أنه يستخدم في طور إيقاف التشغيل الذي يسبق إعادة الإقلاع.
					</div></li></ul></div><div
              class="para">
				هناك مستويات تشغيل أخرى، بالأخص المستويات من 3 إلى 5. افتراضياً تعمل هذه المستويات مثل المستوى 2 تماماً، لكن يستطيع مدير النظام تعديلها (بإضافة أو حذف سكربتات في مجلد <code
                dir="ltr"
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> الموافق) لتكييفها مع حاجاته الخاصة.
			</div><div
              class="figure"><a
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="Boot sequence of a computer running Linux with System V init" /></div></div><p
                class="title"><strong>شكل 9.2. Boot sequence of a computer running Linux with System V init</strong></p></div><a
              id="idm140565146003408"
              class="indexterm"></a><div
              class="para">
				كافة السكربتات المخزنة في مجلدات <code
                dir="ltr"
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> المختلفة هي في الحقيقة روابط رمزية فقط —يُنشِئها البرنامج <code
                class="command">update-rc.d</code> عند تثبيت الحزمة— تشير إلى السكربتات الفعلية المخزنة في <code
                class="filename">/etc/init.d/</code>. يستطيع مدير النظام ضبط الخدمات المتاحة في كل مستوى تشغيلي من خلال إعادة استدعاء <code
                class="command">update-rc.d</code> مع البارامترات المعدلة. تشرح صفحة الدليل <span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(1)</span>‎ صيغة استخدامها بالتفصيل. نرجو أن تلاحظ أن إزالة جميع الروابط الرمزية (باستخدام البارامتر <code
                class="literal">remove</code>) ليست طريقة جيدة لتعطيل الخدمة. بل عليك إعدادها بحيث لا تعمل في المستوى التشغيلي المطلوب بكل بساطة (مع الحفاظ على الاستدعاءات الموافقة لإيقافها في حال كانت الخدمة تعمل في المستوى التشغيلي السابق). بما أن واجهة <code
                class="command">update-rc.d</code> متشابكة نوعاً ما، فقد تفضل استخدام <code
                class="command">rcconf</code> (من الحزمة <span
                class="pkg pkg">rcconf</span>) الذي يوفر واجهة أليفة للمستخدم.
			</div><a
              id="idm140565135473760"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>سياسة دبيان</em></span> إعادة تشغيل الخدمات</strong></p></div></div></div><a
                id="idm140565135471552"
                class="indexterm"></a><a
                id="idm140565135470432"
                class="indexterm"></a><a
                id="idm140565135468992"
                class="indexterm"></a><div
                class="para">
				أحياناً تعيد سكربتات الصيانة لبعض حزم دبيان تشغيل خدمات معينة لضمان توافرها أو لجعلها تأخذ بعض الخيارات بعين الاعتبار. لا يأخذ الأمر الذي يتحكم بالخدمات —<code
                  dir="ltr"
                  class="command">/etc/init.d/<em
                    class="replaceable">service</em> <em
                    class="replaceable">operation</em></code>— المستويات التشغيلية بعين الاعتبار، ويفترض (مخطئاً) أن الخدمة تستخدم حالياً، لذلك قد يجري عمليات غير صحيحة (بدء خدمة كانت موقفة عمداً، أو إيقاف خدمة متوقفة أصلاً، الخ). لهذا قدمت دبيان البرنامج <code
                  class="command">invoke-rc.d</code>: يجب أن تستخدم سكربتات الصيانة هذا البرنامج لتشغيل سكربتات تهيئة الخدمات، وسوف ينفذ هذا البرنامج الأوامر الضرورية فقط. لاحظ أن اللاحقة <code
                  dir="ltr"
                  class="filename">.d</code> استخدمت هنا في اسم البرنامج، وليس اسم مجلد، بخلاف الاستعمال الشائع.
			</div></div><div
              class="para">
				أخيراً، تبدأ <code
                class="command">init</code> تشغيل البرامج لمختلف الطرفيات الظاهرية (<code
                class="command">getty</code>). بعدها تعرض سطر أوامر، الذي ينتظر إدخال اسم المستخدم، ثم تنفذ <code
                class="command">login <em
                  class="replaceable">user</em></code> لبدء جلسة عمل.
			</div><a
              id="idm140565135461600"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>مصطلحات</em></span> Console وTerminal</strong></p></div></div></div><div
                class="para">
				كانت الحواسيب الأولى تفصل عادة إلى العديد من الأجزاء الكبيرة: كانت حظيرة التخزين ووحدة المعالجة المركزية مفصولتين عن الأجهزة الملحقة التي يستخدمها عمال التشغيل للتحكم بهما. كانت هذه الملحقات جزءاً من قطعة مستقلة، وهي الـ ”console – لوحة المراقبة أو التحكم“. لقد بقي المصطلح، لكن معناه تغير. لقد أصبح –بصورة أو بأخرى– مرادفاً للمصطلح ”terminal – طرفية“، وهي شاشة مع لوحة مفاتيح.
			</div><div
                class="para">
				مع تطور الحواسيب، قدمت نظم التشغيل العديد من الـconsoles الظاهرية لتسمح بفتح عدة جلسات مستقلة في الوقت نفسه، حتى لو كان هناك شاشة واحدة ولوحة مفاتيح واحدة. توفر معظم نظم GNU/Linux ست consoles ظاهرية (في الوضع النصي)، يمكن الوصول إليها بالضغط على المفاتيح <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> وحتى <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span>.
			</div><div
                class="para">
				يمكن أن يشير المصطلحان ”console“ و ”terminal“ أيضًا لمحاكيات الطرفيات التي تعمل في جلسات X11 الرسومية (مثل <code
                  class="command">xterm</code>، أو <code
                  class="command">gnome-terminal</code> أو <code
                  class="command">konsole</code>).
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>السابق</strong>8.11. تثبيت النواة</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>أعلى</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>البداية</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>التالي</strong>9.2. تسجيل الدخول عن بعد</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/unix-services.html">ar-MA</a></li><li><a
              href="../da-DK/unix-services.html">da-DK</a></li><li><a
              href="../de-DE/unix-services.html">de-DE</a></li><li><a
              href="../el-GR/unix-services.html">el-GR</a></li><li><a
              href="../en-US/unix-services.html">en-US</a></li><li><a
              href="../es-ES/unix-services.html">es-ES</a></li><li><a
              href="../fa-IR/unix-services.html">fa-IR</a></li><li><a
              href="../fr-FR/unix-services.html">fr-FR</a></li><li><a
              href="../hr-HR/unix-services.html">hr-HR</a></li><li><a
              href="../id-ID/unix-services.html">id-ID</a></li><li><a
              href="../it-IT/unix-services.html">it-IT</a></li><li><a
              href="../ja-JP/unix-services.html">ja-JP</a></li><li><a
              href="../pl-PL/unix-services.html">pl-PL</a></li><li><a
              href="../pt-BR/unix-services.html">pt-BR</a></li><li><a
              href="../ro-RO/unix-services.html">ro-RO</a></li><li><a
              href="../ru-RU/unix-services.html">ru-RU</a></li><li><a
              href="../tr-TR/unix-services.html">tr-TR</a></li><li><a
              href="../zh-CN/unix-services.html">zh-CN</a></li></ul></div></body></html>
