<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">14.3. 監督: 防止、検知、監査</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.1" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-ja-JP-1.0-1" /><meta
        name="keywords"
        content="ファイアウォール, Netfilter, IDS/NIDS" /><link
        rel="home"
        href="index.html"
        title="Debian 管理者ハンドブック" /><link
        rel="up"
        href="security.html"
        title="第14章 セキュリティ" /><link
        rel="prev"
        href="sect.firewall-packet-filtering.html"
        title="14.2. ファイアウォールとパケットフィルタリング" /><link
        rel="next"
        href="sect.selinux.html"
        title="14.4. SELinux の紹介" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/ja-JP/sect.supervision.html" /></head><body
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>戻る</strong></a></li><li
          class="home">Debian 管理者ハンドブック</li><li
          class="next"><a
            accesskey="n"
            href="sect.selinux.html"><strong>次へ</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.supervision"></a>14.3. 監督: 防止、検知、監査</h2></div></div></div><a
          id="idm140245148156400"
          class="indexterm"></a><a
          id="idm140245148155440"
          class="indexterm"></a><div
          class="para">
			監視はいくつかの理由によってセキュリティポリシーの不可欠な要素になっています。中でも、セキュリティの目標には、通常データの機密性を保証するだけでなく、サービスの可用性を保証することも含まれています。そのため、すべてが思った通り稼働しているかを確認したり、さまざまな逸脱した挙動や提供しているサービス品質の変化をタイミング良く検知したり、することが不可欠です。監視活動のおかげで、危機的状況に陥る前に、不正侵入の試行を検知し迅速に対応することが可能です。この節では、Debian システムのさまざまな側面を監視するために使えるいくつかのツールを概説します。この節は<a
            class="xref"
            href="advanced-administration.html">12章<em>高度な管理</em></a>内の一般的なシステム監視について書かれた節を補完するものです。
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.logcheck"></a>14.3.1. <code
                    class="command">logcheck</code> を使ったログ監視</h3></div></div></div><a
            id="idm140245148151360"
            class="indexterm"></a><a
            id="idm140245148150240"
            class="indexterm"></a><a
            id="idm140245148148800"
            class="indexterm"></a><div
            class="para">
				<code
              class="command">logcheck</code> プログラムはデフォルトでは毎時間ログファイルを監視します。<code
              class="command">logcheck</code> はログメッセージを電子メールで管理者に送信し、さらなる解析を促します。
			</div><div
            class="para">
				監視されるファイルのリストは <code
              class="filename">/etc/logcheck/logcheck.logfiles</code> に保存されています; <code
              class="filename">/etc/syslog.conf</code> ファイルが完全に書き換えられていなければ、デフォルト値でうまく動作します。
			</div><div
            class="para">
				<code
              class="command">logcheck</code> の動作モードは 3 種類の内の 1 つから選ぶことが可能です: <span
              class="emphasis"><em>paranoid</em></span>、<span
              class="emphasis"><em>server</em></span>、<span
              class="emphasis"><em>workstation</em></span> です。<span
              class="emphasis"><em>paranoid</em></span> モードは<span
              class="emphasis"><em>とても</em></span>詳細で、このモードを使うのはファイアウォールなどの特定のサーバに限定するべきです。<span
              class="emphasis"><em>server</em></span> モードはデフォルトで、ほとんどのサーバではこのモードを使うことを推奨します。<span
              class="emphasis"><em>workstation</em></span> モードはワークステーション用に設計されており、かなり簡潔です (より多くのメッセージをフィルタします)。
			</div><div
            class="para">
				管理者は毎時間のバッチ処理のたびに長くてつまらない電子メールを受け取ることを本当に望むのでなければ、3 つのモードすべてで <code
              class="command">logcheck</code> を (インストール済みサービスに従い) カスタマイズしていくつかの余分なメッセージを除外するべきです。メッセージ選択メカニズムはかなり複雑なので、もし挑戦するなら <code
              class="filename">/usr/share/doc/logcheck-database/README.logcheck-database.gz</code> を読むと良いでしょう。
			</div><div
            class="para">
				適用されるルールはいくつかの種類に分かれます:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						クラッキングの試行として分類するメッセージのルール (<code
                    class="filename">/etc/logcheck/cracking.d/</code> ディレクトリ内のファイルに保存します);
					</div></li><li
                class="listitem"><div
                  class="para">
						クラッキングの試行としての分類を解除するメッセージのルール (<code
                    class="filename">/etc/logcheck/cracking.ignore.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						セキュリティ警告として分類するメッセージのルール (<code
                    class="filename">/etc/logcheck/violations.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						セキュリティ警告としての分類を解除するメッセージのルール (<code
                    class="filename">/etc/logcheck/violations.ignore.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						最後に、残りのメッセージに適用するルール (<span
                    class="emphasis"><em>システムイベント</em></span>として分類されます)。
					</div></li></ul></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CAUTION</em></span> メッセージの無視</strong></p></div></div></div><div
              class="para">
				クラッキング試行や (<code
                class="filename">/etc/logcheck/violations.d/myfile</code> ファイルに保存されているルールに従い) セキュリティ警告としてタグ付けされたメッセージを無視するには、<code
                class="filename">/etc/logcheck/violations.ignore.d/myfile</code> または <code
                class="filename">/etc/logcheck/violations.ignore.d/myfile-<em
                  class="replaceable">extension</em></code> ファイルを使います。
			</div></div><div
            class="para">
				<code
              class="filename">/etc/logcheck/ignore.d.{paranoid,server,workstation}/</code> ディレクトリ内のルールの 1 つによってシステムイベントが無視されなかった場合を除いて、常にシステムイベントは通知されます。もちろん、ここで考慮されるディレクトリは、選択された動作モードの冗長性レベル以上の冗長性レベルに対応するディレクトリです。
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>TIP</em></span> 画面背景にログを表示する</strong></p></div></div></div><div
              class="para">
				一部の管理者はリアルタイムでログメッセージをスクロール表示したいと思っています。<code
                class="command">root-tail</code> コマンド (<span
                class="pkg pkg">root-tail</span> に含まれます) パッケージを使って、グラフィカルデスクトップの背景にログを表示することが可能です。<code
                class="command">xconsole</code> プログラム (<span
                class="emphasis"><em>x11-apps</em></span> パッケージに含まれます) も小さなウィンドウにログをスクロール表示させることが可能です。メッセージは <code
                class="filename">/dev/xconsole</code> 名前付きパイプを使って直接 <code
                class="command">syslogd</code> から取得されます。
			</div><a
              id="idm140245148120576"
              class="indexterm"></a><a
              id="idm140245148119456"
              class="indexterm"></a></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.monitoring-activity"></a>14.3.2. 監視活動</h3></div></div></div><a
            id="idm140245148116736"
            class="indexterm"></a><a
            id="idm140245148115296"
            class="indexterm"></a><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.real-time-monitoring"></a>14.3.2.1. リアルタイム監視</h4></div></div></div><div
              class="para">
					<code
                class="command">top</code> は現在実行中のプロセスのリストを表示する対話型ツールです。デフォルトでは現在のプロセッサ使用量に基づいてソートされ、 <span
                class="keycap"><strong>P</strong></span> キーを押すことで内容を更新することが可能です。他のソート基準として、占有メモリ量 (<span
                class="keycap"><strong>M</strong></span> キー)、総プロセッサ時間 (<span
                class="keycap"><strong>T</strong></span> キー)、プロセス識別子 (<span
                class="keycap"><strong>N</strong></span> キー) などがあります。<span
                class="keycap"><strong>k</strong></span> キーに続けてプロセス識別子を入力することで、識別子に対応するプロセスを殺すことが可能です。<span
                class="keycap"><strong>r</strong></span> キーを使ってプロセスの <span
                class="emphasis"><em>renicing</em></span> を行うことが可能です、つまり優先度を変更することが可能です。
				</div><a
              id="idm140245148108736"
              class="indexterm"></a><div
              class="para">
					システムの負荷が高過ぎる場合、<code
                class="command">top</code> という素晴らしいツールを使って、プロセッサ時間を奪っていたりメモリを大量に消費しているプロセスを調査します。特に、リソースを消費しているプロセスがそのマシンでホストされていることを知られている本物のサービスに一致しているか否かを確認することは興味深いです。www-data ユーザとして実行されている不明なプロセスは特に警戒して調査するべきです。なぜなら、その不明なプロセスはウェブアプリケーションの脆弱性を利用してシステムにインストールおよび実行されたソフトウェアのインスタンスかもしれないからです。
				</div><div
              class="para">
					<code
                class="command">top</code> はとても柔軟性の高いツールで、マニュアルページは表示をカスタマイズする方法とそのカスタマイズの結果を個人的なニーズや習慣に反映させる方法を詳細に説明しています。
				</div><div
              class="para">
					<code
                class="command">gnome-system-monitor</code> と <code
                class="command">qps</code> グラフィカルツールは <code
                class="command">top</code> とよく似ており、大まかに言って同じ機能を備えています。
				</div><a
              id="idm140245148102928"
              class="indexterm"></a></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.monitoring-history"></a>14.3.2.2. 歴史</h4></div></div></div><a
              id="idm140245148100480"
              class="indexterm"></a><div
              class="para">
					プロセッサの負荷、ネットワークトラフィック、空きディスク領域などの情報は絶えず変わります。これらの情報の時間変化を保存しておくと、コンピュータの使われ方を明らかにするためには便利です。
				</div><a
              id="idm140245148098768"
              class="indexterm"></a><a
              id="idm140245148097808"
              class="indexterm"></a><div
              class="para">
					このタスクには専用のツールがたくさんあります。ほとんどのツールは、この種の情報を中央に集めるために、SNMP (<span
                class="emphasis"><em>Simple Network Management Protocol</em></span>) を介してデータを取得します。SNMP を使うことで、汎用コンピュータ以外のネットワーク要素、たとえば専用ネットワークルータやスイッチ、からデータを取得することが可能になるという恩恵があります。
				</div><div
              class="para">
					本書では、<a
                class="xref"
                href="advanced-administration.html">第12章: 「<em>高度な管理</em>」</a>の中で Munin を詳細に取り上げています (<a
                class="xref"
                href="sect.monitoring.html#sect.munin">「Munin のセットアップ」</a>参照)。Debian は類似のツール <span
                class="pkg pkg">cacti</span> を提供しています。cacti の配備は Munin よりも少し複雑です。なぜなら cacti はもっぱら SNMP に基づいているからです。ウェブインターフェースを持つにも関わらず、設定に必要な概念を理解するには少し努力が必要です。HTML 文書 (<code
                class="filename">/usr/share/doc/cacti/html/index.html</code>) を読了していることが前提条件として求められます。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVE</em></span> <code
                          class="command">mrtg</code></strong></p></div></div></div><a
                id="idm140245148090672"
                class="indexterm"></a><div
                class="para">
					<code
                  class="command">mrtg</code> (よく似た名前のパッケージに含まれます) は古いツールです。一部では低く評価されていますが、<code
                  class="command">mrtg</code> は時系列データを集計し、これをグラフとして表示することが可能です。<code
                  class="command">mrtg</code> は最も一般的に監視されるデータ、たとえばプロセッサの負荷、ネットワークトラフィック、ウェブページのヒット、などの情報を収集する多数の専用スクリプトを備えています。
				</div><div
                class="para">
					<span
                  class="pkg pkg">mrtg-contrib</span> と <span
                  class="pkg pkg">mrtgutils</span> パッケージには、直接使うことができるスクリプトの例が含まれます。
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="idm140245148084592"></a>14.3.3. 変更検知</h3></div></div></div><div
            class="para">
				システムのインストールと設定が完了したら、セキュリティアップグレードを行わない限りデータ以外のほとんどのファイルとディレクトリが変化する理由はありません。このため、ファイルが変化していないことを確認することは興味深いです。このため、ファイルに対する予想外の変化は調査に値します。この節では、ファイルに対する予想外の変化に備えて、ファイルを監視して管理者に警告する (または単純に変更をリストする) いくつかのツールを紹介します。
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.debsums"></a>14.3.3.1. パッケージの監査: <code
                      class="command">debsums</code> とその限界</h4></div></div></div><a
              id="idm140245148081072"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GOING FURTHER</em></span> 上流に対して加えられた変更から保護する</strong></p></div></div></div><div
                class="para">
					<code
                  class="command">debsums</code> は Debian パッケージの提供するファイルに対する変化を検出するのに便利ですが、たとえば Debian ミラーが不正アクセスを受けたことによりパッケージ自体が不正に改竄されていた場合 <code
                  class="command">debsums</code> は役に立ちません。この種の攻撃に対向するには、APT のデジタル署名照合システム (<a
                  class="xref"
                  href="sect.package-authentication.html">「パッケージ信頼性の確認」</a>参照) を使い、認証された発行元からのパッケージだけをインストールするように気をつけること、が必要です。
				</div></div><div
              class="para">
					<code
                class="command">debsums</code> は興味深いツールで、(潜在的には攻撃者によって) 修正されたインストール済みファイルを見つけることが可能ですが、その結果は疑ってかかるべきです。第一に、すべての Debian パッケージが <code
                class="command">debsums</code> プログラムが要求する指紋を提供しているわけではないからです (指紋が提供されているならば、指紋は <code
                class="filename">/var/lib/dpkg/info/<em
                  class="replaceable">package</em>.md5sums</code> に保存されています)。<a
                id="idm140245148073616"
                class="indexterm"></a> <a
                id="idm140245148072976"
                class="indexterm"></a> <a
                id="idm140245148072336"
                class="indexterm"></a> <a
                id="idm140245148071696"
                class="indexterm"></a> 備忘録的になりますが: ここで指紋とは、ファイルの内容に対するある種のシグネチャを含む値、通常は数 (実際は 16 進数表記です)、です。このシグネチャはあるアルゴリズムを使って計算されます。指紋計算に使われるアルゴリズムはファイルに対して行われた小さな変化により指紋が変化することがおおよそ保証されているものです (MD5 や SHA1 がよく知られている例です); これは「アバランシェ効果」として知られています。アバランシェ効果のおかげで、簡単な数字で表される指紋がファイルの内容の変化を検出するためのリトマス試験として機能することになります。指紋計算に使われるアルゴリズムは不可逆です; 言い換えれば、ほとんどの場合、指紋からその指紋が得られる内容を発見することは不可能であることが知られています。最近の数学的な進歩により、アルゴリズムの原理の絶対性が揺らいでいるように見えます。しかしこれはアルゴリズムを使うことに対して疑問を投げかけるものではありません。なぜなら、同じ指紋を持つ異なる内容を作成することはまだかなり難しい作業だからです。
				</div><div
              class="para">
					加えて、<code
                class="filename">md5sums</code> ファイルはハードディスク上に保存されます; そのため几帳面な攻撃者なら <code
                class="filename">md5sums</code> ファイルの中の指紋を改竄したファイルに対応する新しい指紋で置き換えるでしょう。
				</div><div
              class="para">
					最初の欠点は <code
                class="command">debsums</code> が確認を行う際に <code
                class="filename">md5sums</code> ファイルを参照するのではなく <code
                class="filename">.deb</code> パッケージを参照すれば避けることが可能です。しかしこの場合、先に対応する <code
                class="filename">.deb</code> ファイルをダウンロードすることが必要になります:
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>apt-get --reinstall -d install `debsums -l`</code></strong>
<code
                class="computeroutput">[ ... ]
# </code><strong
                class="userinput"><code>debsums -p /var/cache/apt/archives -g</code></strong>
</pre><div
              class="para">
					注目すべき点として、デフォルト状態の <code
                class="command">debsums</code> は APT を使ってパッケージがインストールされていた場合でも存在しない <code
                class="filename">md5sums</code> ファイルを自動的に生成します。
				</div><div
              class="para">
					次の問題も同様のやり方で避けることが可能です: この確認は本来の <code
                class="filename">.deb</code> ファイル に基づかなければいけません。この方法の前提条件は、すべてのインストール済みパッケージに対するすべての <code
                class="filename">.deb</code> ファイルを取得すること、 <code
                class="filename">.deb</code> ファイルの完全性が保証されていること、です。これを満足させる最も簡単な方法は Debian ミラーから <code
                class="filename">.deb</code> ファイルを取得することです。この操作は遅くて退屈ですから、この操作を定期的かつ積極的に使うべき手法として考えるべきではありません。
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</code></strong>
<code
                class="computeroutput">[ ... ]
# </code><strong
                class="userinput"><code>debsums -p /var/cache/apt/archives --generate=all</code></strong>
</pre><div
              class="para">
					この例の中で、デフォルトではインストールされない <span
                class="pkg pkg">dctrl-tools</span> パッケージに含まれる <code
                class="command">grep-status</code> コマンドが使われている点に注意してください。
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="idm140245149807856"></a>14.3.3.2. ファイル監視: AIDE</h4></div></div></div><a
              id="idm140245149807088"
              class="indexterm"></a><div
              class="para">
					AIDE ツール (<span
                class="emphasis"><em>Advanced Intrusion Detection Environment</em></span>) を使うことで、ファイルの完全性を確認したり、前回保存された正当なシステムのイメージに対する変更を検知したり、することが可能です。このイメージはデータベース (<code
                class="filename">/var/lib/aide/aide.db</code>) に保存され、システムのすべてのファイルに対して関連する情報 (指紋、パーミッション、タイムスタンプなど) を保存しています。このデータベースは最初に <code
                class="command">aideinit</code> を使って初期化されます; そして毎日、関係のある情報が何も変更されていないことを確認するために、(<code
                class="filename">/etc/cron.daily/aide</code> スクリプトから) 使われます。変更が検知されたら、AIDE はこれをログファイル (<code
                class="filename">/var/log/aide/*.log</code>) に記録し、見つかった内容を管理者にメールで送信します。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>IN PRACTICE</em></span> データベースの保護</strong></p></div></div></div><div
                class="para">
					AIDE はファイルの状態を比較するためにローカルデータベースを使います。結果の信頼性は直接的にデータベースの信頼性と結びついています。攻撃者が不正アクセスされたシステムの root パーミッションを取得した場合、攻撃者はデータベースを置き換えて自分の行動の形跡を隠すことが可能です。可能な次善策は参照データを読み込み専用のストレージメディアに保存することです。
				</div></div><div
              class="para">
					<code
                class="filename">/etc/default/aide</code> に含まれる多くのオプションを使って <span
                class="pkg pkg">aide</span> パッケージの挙動を微調整します。AIDE 設定は <code
                class="filename">/etc/aide/aide.conf</code> と <code
                class="filename">/etc/aide/aide.conf.d/</code> に保存されています (実質的に言えば、これらのファイルは <code
                class="command">update-aide.conf</code> が <code
                class="filename">/var/lib/aide/aide.conf.autogenerated</code> を生成するためだけに使われます)。設定は確認する必要のあるファイルの属性の種類を指定します。たとえば、ログファアイルの内容は定期的に変わりますが、この種の変更はファイルのパーミッションが同じなら無視することが可能です。しかし、実行プログラムの内容とパーミッションの両方は必ず同じでなければいけません。設定の構文は、とても複雑というわけではありませんが、十分に直感的というわけでもありません。<span
                class="citerefentry"><span
                  class="refentrytitle">aide.conf</span>(5)</span> マニュアルページを読むことを推奨します。
				</div><div
              class="para">
					データベースの新しいバージョンは毎日生成され、<code
                class="filename">/var/lib/aide/aide.db.new</code> に保存されます; すべての記録された変更が正当ならば、参照データベースを新しいデータベースに置き換えることが可能です。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVE</em></span> Tripwire と Samhain</strong></p></div></div></div><div
                class="para">
					Tripwire は AIDE とよく似ています; 設定ファイルの構文もほとんど同じです。AIDE と <span
                  class="pkg pkg">tripwire</span> の主な違いは <span
                  class="pkg pkg">tripwire</span> には設定ファイルを署名するメカニズムが備わっている点です。設定ファイルを署名することで、参照データベースの示す先を異なるバージョンに差し替えることが不可能になります。
				</div><div
                class="para">
					Samhain も類似の機能を提供しますが、rootkit の検知に役立ついくつかの機能を備えています (傍注 QUICK LOOK を参照)。Samhain はネットワークを使って広範囲に配備され、中央サーバ上に履歴を (署名と一緒に) 記録することが可能です。
				</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>QUICK LOOK</em></span> <span
                          class="pkg pkg">checksecurity</span> と <span
                          class="pkg pkg">chkrootkit</span>/<span
                          class="pkg pkg">rkhunter</span> パッケージ</strong></p></div></div></div><a
                id="idm140245149785536"
                class="indexterm"></a><div
                class="para">
					<span
                  class="pkg pkg">checksecurity</span> パッケージには、システムの基本的な確認 (空のパスワード、新しい setuid ファイル、など) を行い、必要ならば管理者に警告するための、複数の小さなスクリプトが含まれます。checksecurity という明快な名前にも関わらず、管理者はこれ 1 つだけに頼って、Linux システムが安全であることを保証するべきではありません。
				</div><div
                class="para">
					<span
                  class="pkg pkg">chkrootkit</span> と <span
                  class="pkg pkg">rkhunter</span> パッケージを使うことで、システムに潜在的にインストールされた <span
                  class="emphasis"><em>rootkit</em></span> を探し出すことが可能です。備忘録的になりますが、<span
                  class="emphasis"><em>rootkit</em></span> はシステムの不正侵入を隠すために設計されたソフトウェアで、マシンをこっそりと操作できる状態にし続けます。このテストは 100% 信頼できるものではありませんが、管理者はテストにより潜在的な問題に対して注意を払うようになります。
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.intrusion-detection"></a>14.3.4. 侵入検知 (IDS/NIDS)</h3></div></div></div><a
            id="idm140245149777504"
            class="indexterm"></a><a
            id="idm140245149776544"
            class="indexterm"></a><a
            id="idm140245149775584"
            class="indexterm"></a><a
            id="idm140245149774624"
            class="indexterm"></a><a
            id="idm140245149773696"
            class="indexterm"></a><a
            id="idm140245149772736"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>BACK TO BASICS</em></span> サービス妨害</strong></p></div></div></div><a
              id="idm140245149770176"
              class="indexterm"></a><div
              class="para">
				「サービス妨害」攻撃の目的は 1 つしかありません: サービスを使用不能にすることです。そのような攻撃は、問い合わせを使ってサーバに大きな負荷を加えたり、バグを不正に活用したりすることで、実行されます。最終結果はどれも同じです: サービスはもはや使用できません。正規のユーザは迷惑しますし、標的にされたネットワークサービスをホストしている全体の評価が落ちます (たとえばサービスが電子商取引サイトの場合、さらに収入が落ちます)。
			</div><div
              class="para">
				「サービス妨害」攻撃はしばしば「分散」されることがあります; これは通常、数多くの異なる送信元から数多くの問い合わせを送信することにより、サーバに負荷を加えます。こうすることで、サーバは正規の問い合わせに応答できなくなります。この種の攻撃には、よく知られている頭字語が与えられています: <acronym
                class="acronym">DoS</acronym> と <acronym
                class="acronym">DDoS</acronym> です (サービス妨害攻撃が分散型か否かに基づきます)。
			</div></div><div
            class="para">
				<code
              class="command">snort</code> (同名の Debian パッケージに含まれます) は NIDS <span
              class="emphasis"><em>ネットワーク型侵入検知システム</em></span> です。NIDS の機能はネットワークをリッスンして侵入試行および敵対行為 (サービス妨害攻撃も含めて) を検知しようとします。すべてのイベントは記録され、過去 24 時間のイベントをまとめた電子メールが管理者宛に毎日送信されます。
			</div><a
            id="idm140245149764464"
            class="indexterm"></a><div
            class="para">
				snort の設定にローカルネットワークをカバーするアドレス範囲を追加します。具体的に言えば、アドレス範囲とは潜在的に攻撃対象となりうるすべてのアドレスを意味します。他の重要なパラメータは <code
              class="command">dpkg-reconfigure snort</code> を使って設定します。これには監視するネットワークインターフェースが含まれます。監視対象のネットワークインターフェースは通常イーサネット接続用の <code
              class="literal">eth0</code> ですが、他の可能性も存在します。たとえば ADSL や PSTN (<span
              class="emphasis"><em>Public Switched Telephone Network</em></span>、かなり古いダイヤルアップモデム) 用の <code
              class="literal">ppp0</code>、無線ネットワークカード用の <code
              class="literal">wlan0</code> などです。
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>GOING FURTHER</em></span> <code
                        class="command">prelude</code> との統合</strong></p></div></div></div><div
              class="para">
				prelude を使うことでセキュリティ情報の中央集中型監視が可能になります。prelude のモジュール式設計には、サーバ (<span
                class="pkg pkg">prelude-manager</span> に含まれる<span
                class="emphasis"><em>マネージャ</em></span>) が含まれ、サーバはさまざまな種類の<span
                class="emphasis"><em>センサー</em></span>によって生成された警告を収集します。
			</div><div
              class="para">
				Snort を prelude のセンサーとして設定することが可能です。他の可能性には <span
                class="emphasis"><em>prelude-lml</em></span> (<span
                class="emphasis"><em>Log Monitor Lackey</em></span>) があります。これは (<a
                class="xref"
                href="sect.supervision.html#sect.logcheck">「<code
                  class="command">logcheck</code> を使ったログ監視」</a>で説明されている <code
                class="command">logcheck</code> と同様のやり方で) ログファイルを監視します。
			</div><a
              id="idm140245149753696"
              class="indexterm"></a></div><div
            class="para">
				<code
              class="command">snort</code> 設定ファイル (<code
              class="filename">/etc/snort/snort.conf</code>) はとても長く、コメントを使ってそれぞれの指示文がとても詳しく説明されています。設定項目を最大限に活用するには、コメントを全部読んで、現場の状態に適用する必要があります。たとえば、マシンとそのマシンがホストするサービスの対応関係を表しておくことにより、<code
              class="command">snort</code> が報告する事故の数を制限することが可能です。なぜなら、デスクトップマシンへのサービス妨害攻撃は DNS サーバへのサービス妨害攻撃に比べて致命的な問題ではないからです。さらに別の興味深い指示文を使えば、IP アドレスと MAC アドレス (一意的にネットワークカードを識別するもの) 間の対応付けを保存することが可能です。こうすることで、不正侵入されたマシンが他の慎重に扱うべきサーバのような他のマシンになりすますという、<span
              class="emphasis"><em>ARP spoofing</em></span> 攻撃を検知することが可能になります。
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CAUTION</em></span> 動作範囲</strong></p></div></div></div><div
              class="para">
				<code
                class="command">snort</code> の有効性は監視対象のネットワークインターフェース上を流れるトラフィックによって制限されます。<code
                class="command">snort</code> が真のトラフィックを観察することができない場合、当然ながら何も検知されません。<code
                class="command">snort</code> が実行されているマシンをネットワークスイッチに接続した場合、<code
                class="command">snort</code> が実行されているマシンを対象にした攻撃だけを検知することが可能です。この挙動は意図するものではないかもしれません。このため <code
                class="command">snort</code> が実行されているマシンはネットワークスイッチの「ミラー」ポートに接続されるべきです。通常「ミラー」ポートはスイッチをカスケード接続するために使われるため、すべてのトラフィックを取得することが可能です。
			</div><div
              class="para">
				ネットワークが 1 台のネットワークハブ近傍に制限されている場合、そのような問題はありません。なぜなら、すべてのマシンはすべてのトラフィックを受け取るからです。
			</div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>戻る</strong>14.2. ファイアウォールとパケットフィルタリング</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>上に戻る</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>ホーム</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.selinux.html"><strong>次へ</strong>14.4. SELinux の紹介</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.supervision.html">ar-MA</a></li><li><a
              href="../da-DK/sect.supervision.html">da-DK</a></li><li><a
              href="../de-DE/sect.supervision.html">de-DE</a></li><li><a
              href="../el-GR/sect.supervision.html">el-GR</a></li><li><a
              href="../en-US/sect.supervision.html">en-US</a></li><li><a
              href="../es-ES/sect.supervision.html">es-ES</a></li><li><a
              href="../fa-IR/sect.supervision.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.supervision.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.supervision.html">hr-HR</a></li><li><a
              href="../id-ID/sect.supervision.html">id-ID</a></li><li><a
              href="../it-IT/sect.supervision.html">it-IT</a></li><li><a
              href="../ja-JP/sect.supervision.html">ja-JP</a></li><li><a
              href="../pl-PL/sect.supervision.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.supervision.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.supervision.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.supervision.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.supervision.html">tr-TR</a></li><li><a
              href="../zh-CN/sect.supervision.html">zh-CN</a></li></ul></div></body></html>
