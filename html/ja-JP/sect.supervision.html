<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">14.3. 監督、防止、検知、監査</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-ja-JP-1.0-1" /><meta
        name="keywords"
        content="ファイアウォール, Netfilter, IDS/NIDS" /><link
        rel="home"
        href="index.html"
        title="Debian 管理者ハンドブック" /><link
        rel="up"
        href="security.html"
        title="第14章 セキュリティ" /><link
        rel="prev"
        href="sect.firewall-packet-filtering.html"
        title="14.2. ファイアウォールとパケットフィルタリング" /><link
        rel="next"
        href="sect.apparmor.html"
        title="14.4. AppArmor の紹介" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/ja-JP/sect.supervision.html" /></head><body
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>戻る</strong></a></li><li
          class="home">Debian 管理者ハンドブック</li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>次へ</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.supervision"></a>14.3. 監督、防止、検知、監査</h2></div></div></div><a
          id="idm140500342882672"
          class="indexterm"></a><div
          class="para">
			監視はいくつかの理由によってセキュリティポリシーの不可欠な要素になっています。中でも、セキュリティの目標には、通常データの機密性を保証するだけでなく、サービスの可用性を保証することも含まれています。そのため、すべてが思った通り稼働しているかを確認したり、さまざまな逸脱した挙動や提供しているサービス品質の変化をタイミング良く検知したり、することが不可欠です。監視活動のおかげで、危機的状況に陥る前に、不正侵入の試行を検知し迅速に対応することが可能です。この節では、Debian システムのさまざまな側面を監視するために使えるいくつかのツールを概説します。この節は<a
            class="xref"
            href="advanced-administration.html">12章<em>高度な管理</em></a>内の一般的なシステム監視について書かれた節を補完するものです。
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.logcheck"></a>14.3.1. <code
                    class="command">logcheck</code> を使ったログ監視</h3></div></div></div><a
            id="idm140500342878592"
            class="indexterm"></a><a
            id="idm140500342877472"
            class="indexterm"></a><a
            id="idm140500342876032"
            class="indexterm"></a><div
            class="para">
				<code
              class="command">logcheck</code> プログラムはデフォルトでは毎時間ログファイルを監視します。<code
              class="command">logcheck</code> はログメッセージを電子メールで管理者に送信し、さらなる解析を促します。
			</div><div
            class="para">
				監視されるファイルのリストは <code
              class="filename">/etc/logcheck/logcheck.logfiles</code> に保存されています。そして <code
              class="filename">/etc/rsyslog.conf</code> ファイルが完全に書き換えられていなければ、デフォルト値でうまく動作します。
			</div><div
            class="para">
				<code
              class="command">logcheck</code> の動作モードは 3 種類のうちの 1 つから選ぶことが可能です。具体的に言えば、<span
              class="emphasis"><em>paranoid</em></span>、<span
              class="emphasis"><em>server</em></span>、<span
              class="emphasis"><em>workstation</em></span> から 1 つ選びます。<span
              class="emphasis"><em>paranoid</em></span> モードは<span
              class="emphasis"><em>とても</em></span>詳細で、このモードを使うのはファイアウォールなどの特定のサーバに限定するべきです。<span
              class="emphasis"><em>server</em></span> モードはデフォルトで、ほとんどのサーバではこのモードを使うことを推奨します。<span
              class="emphasis"><em>workstation</em></span> モードはワークステーション用に設計されており、かなり簡潔です (より多くのメッセージをフィルタします)。
			</div><div
            class="para">
				管理者は毎時間のバッチ処理のたびに長くてつまらない電子メールを受け取ることを本当に望むのでなければ、3 つのモードすべてで <code
              class="command">logcheck</code> を (インストール済みサービスに従い) カスタマイズしていくつかの余分なメッセージを除外するべきです。メッセージ選択メカニズムはかなり複雑なので、もし挑戦するなら <code
              class="filename">/usr/share/doc/logcheck-database/README.logcheck-database.gz</code> を読むと良いでしょう。
			</div><div
            class="para">
				適用されるルールはいくつかの種類に分かれます。
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						クラッキングの試行として分類するメッセージのルール (<code
                    class="filename">/etc/logcheck/cracking.d/</code> ディレクトリ内のファイルに保存します)。
					</div></li><li
                class="listitem"><div
                  class="para">
						クラッキングの試行としての分類を解除するメッセージのルール (<code
                    class="filename">/etc/logcheck/cracking.ignore.d/</code> ディレクトリ内のファイルに保存します)。
					</div></li><li
                class="listitem"><div
                  class="para">
						セキュリティ警告として分類するメッセージのルール (<code
                    class="filename">/etc/logcheck/violations.d/</code> ディレクトリ内のファイルに保存します)。
					</div></li><li
                class="listitem"><div
                  class="para">
						セキュリティ警告としての分類を解除するメッセージのルール (<code
                    class="filename">/etc/logcheck/violations.ignore.d/</code> ディレクトリ内のファイルに保存します)。
					</div></li><li
                class="listitem"><div
                  class="para">
						最後に、残りのメッセージに適用するルール (<span
                    class="emphasis"><em>システムイベント</em></span>として分類されます)。
					</div></li></ul></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CAUTION</em></span> メッセージの無視</strong></p></div></div></div><div
              class="para">
				クラッキング試行や (<code
                class="filename">/etc/logcheck/violations.d/myfile</code> ファイルに保存されているルールに従い) セキュリティ警告としてタグ付けされたメッセージを無視するには、<code
                class="filename">/etc/logcheck/violations.ignore.d/myfile</code> または <code
                class="filename">/etc/logcheck/violations.ignore.d/myfile-<em
                  class="replaceable">extension</em></code> ファイルを使います。
			</div></div><div
            class="para">
				<code
              class="filename">/etc/logcheck/ignore.d.{paranoid,server,workstation}/</code> ディレクトリ内のルールの 1 つによってシステムイベントが無視されなかった場合を除いて、常にシステムイベントは通知されます。もちろん、ここで考慮されるディレクトリは、選択された動作モードの冗長性レベル以上の冗長性レベルに対応するディレクトリです。
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.monitoring-activity"></a>14.3.2. 監視活動</h3></div></div></div><a
            id="idm140500342851152"
            class="indexterm"></a><a
            id="idm140500342849712"
            class="indexterm"></a><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.real-time-monitoring"></a>14.3.2.1. リアルタイム監視</h4></div></div></div><div
              class="para">
					<code
                class="command">top</code> は現在実行中のプロセスのリストを表示する対話型ツールです。デフォルトでは現在のプロセッサ使用量に基づいてソートされ、<span
                class="keycap"><strong>P</strong></span> キーを押すことで内容を更新することが可能です。他のソート基準として、専有メモリ量 (<span
                class="keycap"><strong>M</strong></span> キー)、総プロセッサ時間 (<span
                class="keycap"><strong>T</strong></span> キー)、プロセス識別子 (<span
                class="keycap"><strong>N</strong></span> キー) などがあります。<span
                class="keycap"><strong>k</strong></span> キーに続けてプロセス識別子を入力することで、識別子に対応するプロセスを殺すことが可能です。<span
                class="keycap"><strong>r</strong></span> キーを使ってプロセスの <span
                class="emphasis"><em>renicing</em></span> を行うことが可能です、つまり優先度を変更することが可能です。
				</div><a
              id="idm140500342843152"
              class="indexterm"></a><div
              class="para">
					システムの負荷が高過ぎる場合、<code
                class="command">top</code> という素晴らしいツールを使って、プロセッサ時間を奪っていたりメモリを大量に消費しているプロセスを調査します。特に、リソースを消費しているプロセスがそのマシンでホストされていることを知られている本物のサービスに一致しているか否かを確認することは興味深いです。www-data ユーザとして実行されている不明なプロセスは特に警戒して調査するべきです。なぜなら、その不明なプロセスはウェブアプリケーションの脆弱性を利用してシステムにインストールおよび実行されたソフトウェアのインスタンスかもしれないからです。
				</div><div
              class="para">
					<code
                class="command">top</code> はとても柔軟性の高いツールで、マニュアルページは表示をカスタマイズする方法とそのカスタマイズの結果を個人的なニーズや習慣に反映させる方法を詳細に説明しています。
				</div><div
              class="para">
					<code
                class="command">gnome-system-monitor</code> グラフィカルツールは <code
                class="command">top</code> とよく似ており、大雑把に言って同じ機能を備えています。
				</div><a
              id="idm140500342837824"
              class="indexterm"></a></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.monitoring-history"></a>14.3.2.2. 歴史</h4></div></div></div><a
              id="idm140500342835376"
              class="indexterm"></a><div
              class="para">
					プロセッサの負荷、ネットワークトラフィック、空きディスク領域などの情報は絶えず変わります。これらの情報の時間変化を保存しておくと、コンピュータの使われ方を明らかにするためには便利です。
				</div><a
              id="idm140500342833664"
              class="indexterm"></a><a
              id="idm140500342832704"
              class="indexterm"></a><div
              class="para">
					このタスクには専用のツールがたくさんあります。ほとんどのツールは、この種の情報を中央に集めるために、SNMP (<span
                class="emphasis"><em>Simple Network Management Protocol</em></span>) を介してデータを取得します。SNMP を使うことで、汎用的なコンピュータを除くネットワーク要素、たとえば専用ネットワークルータやスイッチ、からデータを取得することが可能になるという恩恵があります。
				</div><div
              class="para">
					本書では、<a
                class="xref"
                href="advanced-administration.html">第12章: 「<em>高度な管理</em>」</a>の中で Munin を詳細に取り上げています (<a
                class="xref"
                href="sect.monitoring.html#sect.munin">「Munin のセットアップ」</a>を参照してください)。Debian は類似のツール <span
                class="pkg pkg">cacti</span> を提供しています。cacti の配備は Munin よりも少し複雑です。なぜなら cacti はもっぱら SNMP に基づいているからです。ウェブインターフェースを持つにも関わらず、設定に必要な概念を理解するには少し努力が必要です。HTML 文書 (<code
                class="filename">/usr/share/doc/cacti/html/index.html</code>) を読了していることが前提条件として求められます。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVE</em></span> <code
                          class="command">mrtg</code></strong></p></div></div></div><a
                id="idm140500342825488"
                class="indexterm"></a><div
                class="para">
					<code
                  class="command">mrtg</code> (よく似た名前のパッケージに含まれます) は古いツールです。一部では低く評価されていますが、<code
                  class="command">mrtg</code> は時系列データを集計し、これをグラフとして表示することが可能です。<code
                  class="command">mrtg</code> は最も一般的に監視されるデータ、たとえばプロセッサの負荷、ネットワークトラフィック、ウェブページのヒット、などの情報を収集する多数の専用スクリプトを備えています。
				</div><div
                class="para">
					<span
                  class="pkg pkg">mrtg-contrib</span> と <span
                  class="pkg pkg">mrtgutils</span> パッケージには、直接使うことができるスクリプトの例が含まれます。
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="idm140500342819408"></a>14.3.3. 変更検知</h3></div></div></div><div
            class="para">
				システムのインストールと設定が完了したら、セキュリティアップグレードを行わない限りデータ以外のほとんどのファイルとディレクトリが変化する理由はありません。このため、ファイルが変化していないことを確認することは興味深いです。このため、ファイルに対する予想外の変化は調査に値します。この節では、ファイルに対する予想外の変化に備えて、ファイルを監視して管理者に警告する (または単純に変更をリストする) いくつかのツールを紹介します。
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.dpkg-verify"></a>14.3.3.1. <code
                      class="command">dpkg --verify</code> を使ったパッケージ監視</h4></div></div></div><a
              id="idm140500342816048"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GOING FURTHER</em></span> 上流に対して加えられた変更から保護する</strong></p></div></div></div><div
                class="para">
					<code
                  class="command">dpkg --verify</code> は Debian パッケージの提供するファイルに対する変化を検出するのに便利ですが、たとえば Debian ミラーが不正アクセスを受けたことによりパッケージ自体が不正に改竄されていた場合 <code
                  class="command">dpkg --verify</code> は役に立ちません。この種の攻撃に対向するには、APT のデジタル署名照合システム (<a
                  class="xref"
                  href="sect.package-authentication.html">「パッケージ信頼性の確認」</a>参照) を使い、認証された発行元からのパッケージだけをインストールするように気を付けること、が必要です。
				</div></div><div
              class="para">
					<code
                class="command">dpkg --verify</code> (または <code
                class="command">dpkg -V</code>) は興味深いツールで、(潜在的には攻撃者によって) 変更を加えられたインストール済みファイルを見つけることが可能ですが、その結果は疑ってかかるべきです。なぜなら <code
                class="command">dpkg --verify</code> は変更されたファイルを検出するために dpkg 自身のデータベースに保存されたチェックサムを使っており、このデータベースはハードディスク上に保存されている (<code
                class="filename">/var/lib/dpkg/info/<em
                  class="replaceable">package</em>.md5sums</code> にあります) からです。このため、几帳面な攻撃者なら改竄したファイルに対応する新しいチェックサムを使ってデータベースファイルを更新するでしょう。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>BACK TO BASICS</em></span> ファイルの指紋</strong></p></div></div></div><a
                id="idm140500342805808"
                class="indexterm"></a><a
                id="idm140500342804848"
                class="indexterm"></a><a
                id="idm140500342803920"
                class="indexterm"></a><a
                id="idm140500342802960"
                class="indexterm"></a><div
                class="para">
					備忘録的になりますが、ここで指紋とは、ファイルの内容に対するある種のシグネチャを含む値、通常は数 (実際は 16 進数表記です)、です。このシグネチャはあるアルゴリズムを使って計算されます。指紋計算に使われるアルゴリズムはファイルに対して行われた小さな変化により指紋が変化することがおおよそ保証されているものです (MD5 や SHA1 がよく知られている例です)。そしてこれは「アバランシェ効果」として知られています。アバランシェ効果のおかげで、簡単な数字で表される指紋がファイルの内容の変化を検出するためのリトマス試験として機能することになります。指紋計算に使われるアルゴリズムは不可逆です。言い換えれば、ほとんどの場合、指紋からその指紋が得られる内容を発見することは不可能であることが知られています。最近の数学的な進歩により、アルゴリズムの原理の絶対性が揺らいでいるように見えます。しかしこれはアルゴリズムを使うことに対して疑問を投げかけるものではありません。なぜなら、同じ指紋を持つ異なる内容を作成することはまだかなり難しい作業だからです。
				</div></div><div
              class="para">
					<code
                class="command">dpkg -V</code> を実行すると、すべてのインストール済みパッケージが検証され、テストに失敗したファイルが行ごとに表示されます。出力フォーマットは <code
                class="command">rpm -V</code> が採用しているフォーマットと同じで、それぞれの文字は特定のメタデータに対するテストの結果を意味しています。残念なことに <code
                class="command">dpkg</code> はテストに必要な多くのメタデータを保存しません。これらのメタデータを必要とするテストの結果は常に疑問符が出力されることになります。今のところ実行できるテストはチェックサムテストだけで、チェックサムテストに失敗した場合、左から 3 番目の文字が「5」になります。
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>dpkg -V</code></strong>
<code
                class="computeroutput">??5??????   /lib/systemd/system/ssh.service
??5?????? c /etc/libvirt/qemu/networks/default.xml
??5?????? c /etc/lvm/lvm.conf
??5?????? c /etc/salt/roster</code></pre><div
              class="para">
					上の例では、dpkg はパッケージから提供された SSH のサービスファイルが直接変更されていることを報告しています。一般に管理者はパッケージから提供された設定ファイル以外のファイルを直接編集するべきではありません。今回の場合ならば、改めて <code
                class="filename">/etc/systemd/system/ssh.service</code> を作成し、これを編集するべきです (このファイルは一般に設定変更を配置すべき場所である <code
                class="filename">/etc</code> ディレクトリの下に配置されます)。さらに、dpkg は設定ファイルとみなされた複数のファイルが修正されていることを報告しています (この場合、左から 2 番目のフィールドが「c」文字になります)。設定ファイルに対する修正は合法的と言えます。
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.debsums"></a>14.3.3.2. パッケージの監査、<code
                      class="command">debsums</code> とその限界</h4></div></div></div><a
              id="idm140500342791664"
              class="indexterm"></a><div
              class="para">
					<code
                class="command">debsums</code> は <code
                class="command">dpkg -V</code> の祖先で、したがってほとんど使われていません。<code
                class="command">debsums</code> と dpkg は同じ制限に悩まされています。幸いなことに、<code
                class="command">debsums</code> はいくつかの制限を回避することが可能です (一方で dpkg には同様の回避策がありません)。
				</div><div
              class="para">
					ディスク上のデータは信頼できないため、<code
                class="command">debsums</code> は dpkg データベースではなく <code
                class="filename">.deb</code> ファイルに基づいてテストを行う機能を提供しています。すべてのインストール済みパッケージに対応する信頼できる <code
                class="filename">.deb</code> ファイルをダウンロードするには、APT の認証付きダウンロード機構を使います。この操作は遅くて退屈ですから、この操作を定期的かつ積極的に使うべき手法として考えるべきではありません。
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</code></strong>
<code
                class="computeroutput">[ ... ]
# </code><strong
                class="userinput"><code>debsums -p /var/cache/apt/archives --generate=all</code></strong></pre><div
              class="para">
					この例の中で、デフォルトではインストールされない <span
                class="pkg pkg">dctrl-tools</span> パッケージに含まれる <code
                class="command">grep-status</code> コマンドが使われている点に注意してください。
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="idm140500342748736"></a>14.3.3.3. ファイル監視、AIDE</h4></div></div></div><a
              id="idm140500342747968"
              class="indexterm"></a><div
              class="para">
					AIDE ツール (<span
                class="emphasis"><em>Advanced Intrusion Detection Environment</em></span>) を使うことで、ファイルの完全性を確認したり、前回保存された正当なシステムのイメージに対する変更を検知したり、することが可能です。このイメージはデータベース (<code
                class="filename">/var/lib/aide/aide.db</code>) に保存され、システムのすべてのファイルに対して関連する情報 (指紋、パーミッション、タイムスタンプなど) を保存しています。このデータベースは最初に <code
                class="command">aideinit</code> を使って初期化されます。そして毎日、関係のある情報が何も変更されていないことを確認するために、(<code
                class="filename">/etc/cron.daily/aide</code> スクリプトから) 使われます。変更が検知されたら、AIDE はこれをログファイル (<code
                class="filename">/var/log/aide/*.log</code>) に記録し、見つかった内容を管理者にメールで送信します。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>IN PRACTICE</em></span> データベースの保護</strong></p></div></div></div><div
                class="para">
					AIDE はファイルの状態を比較するためにローカルデータベースを使います。結果の信頼性は直接的にデータベースの信頼性と結び付いています。攻撃者が不正アクセスされたシステムの root パーミッションを取得した場合、攻撃者はデータベースを置き換えて自分の行動の形跡を隠すことが可能です。可能な次善策は参照データを読み込み専用のストレージメディアに保存することです。
				</div></div><div
              class="para">
					<code
                class="filename">/etc/default/aide</code> に含まれる多くのオプションを使って <span
                class="pkg pkg">aide</span> パッケージの挙動を微調整します。AIDE 設定は <code
                class="filename">/etc/aide/aide.conf</code> と <code
                class="filename">/etc/aide/aide.conf.d/</code> に保存されています (実質的に言えば、これらのファイルは <code
                class="command">update-aide.conf</code> が <code
                class="filename">/var/lib/aide/aide.conf.autogenerated</code> を生成するためだけに使われます)。設定は確認する必要のあるファイルの属性の種類を指定します。たとえば、ログファアイルの内容は定期的に変わりますが、この種の変更はファイルのパーミッションが同じなら無視することが可能です。しかし、実行プログラムの内容とパーミッションの両方は必ず同じでなければいけません。設定の構文は、とても複雑というわけではありませんが、十分に直感的というわけでもありません。<span
                class="citerefentry"><span
                  class="refentrytitle">aide.conf</span>(5)</span> マニュアルページを読むことを推奨します。
				</div><div
              class="para">
					データベースの新しいバージョンは毎日生成され、<code
                class="filename">/var/lib/aide/aide.db.new</code> に保存されます。そして、すべての記録された変更が正当ならば、参照データベースを新しいデータベースに置き換えることが可能です。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVE</em></span> Tripwire と Samhain</strong></p></div></div></div><div
                class="para">
					Tripwire は AIDE とよく似ています。さらに、設定ファイルの構文もほとんど同じです。AIDE と <span
                  class="pkg pkg">tripwire</span> の主な違いは <span
                  class="pkg pkg">tripwire</span> には設定ファイルを署名するメカニズムが備えられている点です。設定ファイルを署名することで、参照データベースの示す先を異なるバージョンに差し替えることが不可能になります。
				</div><div
                class="para">
					Samhain も類似の機能を提供しますが、rootkit の検知に役立ついくつかの機能を備えています (傍注 QUICK LOOK を参照してください)。Samhain はネットワークを使って広範囲に配備され、中央サーバ上に履歴を (署名と一緒に) 記録することが可能です。
				</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>QUICK LOOK</em></span> <span
                          class="pkg pkg">checksecurity</span> と <span
                          class="pkg pkg">chkrootkit</span>/<span
                          class="pkg pkg">rkhunter</span> パッケージ</strong></p></div></div></div><a
                id="idm140500342726208"
                class="indexterm"></a><div
                class="para">
					<span
                  class="pkg pkg">checksecurity</span> パッケージには、システムの基本的な確認 (空のパスワード、新しい setuid ファイル、など) を行い、必要ならば管理者に警告するための、複数の小さなスクリプトが含まれます。checksecurity という明快な名前にも関わらず、管理者はこれ 1 つだけに頼って、Linux システムが安全であることを保証するべきではありません。
				</div><div
                class="para">
					<span
                  class="pkg pkg">chkrootkit</span> と <span
                  class="pkg pkg">rkhunter</span> パッケージを使うことで、システムに潜在的にインストールされた <span
                  class="emphasis"><em>rootkit</em></span> を探し出すことが可能です。備忘録的になりますが、<span
                  class="emphasis"><em>rootkit</em></span> はシステムの不正侵入を隠すために設計されたソフトウェアで、マシンをこっそりと操作できる状態にし続けます。このテストは 100% 信頼できるものではありませんが、管理者はテストにより潜在的な問題に対して注意を払うようになります。
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.intrusion-detection"></a>14.3.4. 侵入検知 (IDS/NIDS)</h3></div></div></div><a
            id="idm140500342718176"
            class="indexterm"></a><a
            id="idm140500342717216"
            class="indexterm"></a><a
            id="idm140500342716256"
            class="indexterm"></a><a
            id="idm140500342715296"
            class="indexterm"></a><a
            id="idm140500342714368"
            class="indexterm"></a><a
            id="idm140500342713408"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>BACK TO BASICS</em></span> サービス妨害</strong></p></div></div></div><a
              id="idm140500342710848"
              class="indexterm"></a><div
              class="para">
				「サービス妨害」攻撃の目的は 1 つしかありません。すなわちサービスを使用不能にすることです。そのような攻撃は、問い合わせを使ってサーバに大きな負荷を加えたり、バグを不正に活用したりすることで、実行されます。最終結果はどれも同じです。つまり、サービスはもはや使用できません。正規のユーザは迷惑しますし、標的にされたネットワークサービスをホストしている全体の評価が落ちます (たとえばサービスが電子商取引サイトの場合、さらに収入が落ちます)。
			</div><div
              class="para">
				「サービス妨害」攻撃はしばしば「分散」されることがあります。これは通常、数多くの異なる送信元から数多くの問い合わせを送信することにより、サーバに負荷を加えます。こうすることで、サーバは正規の問い合わせに応答できなくなります。この種の攻撃には、よく知られている頭字語が与えられています。具体的に言えば、<acronym
                class="acronym">DDoS</acronym> と <acronym
                class="acronym">DoS</acronym> です (サービス妨害攻撃が分散型か否かに基づきます)。
			</div></div><div
            class="para">
				<code
              class="command">suricata</code> (同名の Debian パッケージに含まれます) は NIDS <span
              class="emphasis"><em>ネットワーク型侵入検知システム</em></span> です。NIDS の機能はネットワークをリッスンして侵入試行および敵対行為 (サービス妨害攻撃も含めて) を検知しようとします。すべてのイベントは <code
              class="filename">/var/log/suricata</code> 内の複数のファイルに記録されます。収集されたすべてのデータを閲覧するためのサードパーティツール (Kibana/logstash) が存在します。<div
              class="url">→ <a
                href="http://suricata-ids.org">http://suricata-ids.org</a></div><div
              class="url">→ <a
                href="https://www.elastic.co/products/kibana">https://www.elastic.co/products/kibana</a></div>
			</div><a
            id="idm140500342702816"
            class="indexterm"></a><a
            id="idm140500342701696"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CAUTION</em></span> 動作範囲</strong></p></div></div></div><div
              class="para">
				<code
                class="command">suricata</code> の有効性は監視対象のネットワークインターフェース上を流れるトラフィックによって制限されます。<code
                class="command">suricata</code> が真のトラフィックを観察することができない場合、当然ながら何も検知されません。<code
                class="command">suricata</code> が実行されているマシンをネットワークスイッチに接続した場合、<code
                class="command">suricata</code> が実行されているマシンを対象にした攻撃だけを検知することが可能です。この挙動は意図するものではないかもしれません。このため <code
                class="command">suricata</code> が実行されているマシンはネットワークスイッチの「ミラー」ポートに接続されるべきです。通常「ミラー」ポートはスイッチをカスケード接続するために使われるため、すべてのトラフィックを取得することが可能です。
			</div></div><div
            class="para">
				suricata を設定するには <code
              class="filename">/etc/suricata/suricata-debian.yaml</code> をよく読んで編集します。それぞれのパラメータはこのファイルの中で詳細に説明されているため、このファイルはとても長いものです。最低限の設定を行うには、<code
              class="literal">HOME_NET</code> パラメータでローカルネットワークのカバーするアドレス範囲を指定する必要があります。実際のところ <code
              class="literal">HOME_NET</code> パラメータとはすべての潜在的な攻撃対象の組を意味しています。しかし設定パラメータの多くを理解するには、パラメータの説明をすべて読み、パラメータをそれぞれの状況に適応させることが必要です。
			</div><div
            class="para">
				加えて、監視対象のネットワークインターフェースを定義して、init スクリプトを有効化する (<code
              class="literal">RUN=yes</code> と設定する) ために、<code
              class="filename">/etc/default/suricata</code> を編集するべきです。また、管理者は <code
              class="literal">LISTENMODE=pcap</code> のように設定したいと思うかもしれません。なぜなら、デフォルト設定である <code
              class="literal">LISTENMODE=nfqueue</code> を適切に動かすためには、さらに設定を行う必要があるからです (netfilter ファイアーウォールの <code
              class="literal">NFQUEUE</code> ターゲットを使って suricata が取り扱う一部のユーザ空間キュー宛のパケットを通過するように、ファイアーウォールを設定しなければいけません)。
			</div><div
            class="para">
				不正行為を検出するためには、<code
              class="command">suricata</code> に一連の監視規則を設定する必要があります。いくつかの監視規則は <span
              class="pkg pkg">snort-rules-default</span> パッケージに含まれています。<code
              class="command">snort</code> は IDS エコシステムにおける歴史的な基準ソフトウェアで、<code
              class="command">suricata</code> は <code
              class="command">snort</code> 向けに書かれた監視規則を再利用することが可能です。残念なことに <span
              class="pkg pkg">snort-rules-default</span> パッケージは <span
              class="distribution distribution">Debian Jessie</span> には含まれません。このため、<span
              class="pkg pkg">snort-rules-default</span> パッケージを入手するには <span
              class="distribution distribution">テスト版</span>か<span
              class="distribution distribution">不安定版</span>などの他の Debian リリースに含まれるパッケージを入手してください。
			</div><div
            class="para">
				代案として、<code
              class="command">oinkmaster</code> (同名のパッケージに含まれます) を使って外部ソースから Snort の監視規則をダウンローすることも可能です。
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>GOING FURTHER</em></span> <code
                        class="command">prelude</code> との統合</strong></p></div></div></div><div
              class="para">
				prelude を使うことでセキュリティ情報の中央集中型監視が可能になります。prelude のモジュール式設計には、サーバ (<span
                class="pkg pkg">prelude-manager</span> に含まれる<span
                class="emphasis"><em>マネージャ</em></span>) が含まれ、サーバはさまざまな種類の<span
                class="emphasis"><em>センサー</em></span>によって生成された警告を収集します。
			</div><div
              class="para">
				Suricata を prelude のセンサーとして設定することが可能です。他の可能性には <span
                class="emphasis"><em>prelude-lml</em></span> (<span
                class="emphasis"><em>Log Monitor Lackey</em></span>) があります。これは (<a
                class="xref"
                href="sect.supervision.html#sect.logcheck">「<code
                  class="command">logcheck</code> を使ったログ監視」</a>で説明されている <code
                class="command">logcheck</code> と同様のやり方で) ログファイルを監視します。
			</div><a
              id="idm140500342674960"
              class="indexterm"></a></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>戻る</strong>14.2. ファイアウォールとパケットフィルタリング</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>上に戻る</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>ホーム</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>次へ</strong>14.4. AppArmor の紹介</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.supervision.html">ar-MA</a></li><li><a
              href="../da-DK/sect.supervision.html">da-DK</a></li><li><a
              href="../de-DE/sect.supervision.html">de-DE</a></li><li><a
              href="../el-GR/sect.supervision.html">el-GR</a></li><li><a
              href="../en-US/sect.supervision.html">en-US</a></li><li><a
              href="../es-ES/sect.supervision.html">es-ES</a></li><li><a
              href="../fa-IR/sect.supervision.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.supervision.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.supervision.html">hr-HR</a></li><li><a
              href="../id-ID/sect.supervision.html">id-ID</a></li><li><a
              href="../it-IT/sect.supervision.html">it-IT</a></li><li><a
              href="../ja-JP/sect.supervision.html">ja-JP</a></li><li><a
              href="../pl-PL/sect.supervision.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.supervision.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.supervision.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.supervision.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.supervision.html">tr-TR</a></li><li><a
              href="../zh-CN/sect.supervision.html">zh-CN</a></li></ul></div></body></html>
