<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">第9章 Unix サービス</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.1" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-ja-JP-1.0-1" /><meta
        name="keywords"
        content="システム起動, 初期化スクリプト, SSH, Telnet, 権限, パーミッション, 管理, Inetd, Cron, バックアップ, ホットプラグ, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Debian 管理者ハンドブック" /><link
        rel="up"
        href="index.html"
        title="Debian 管理者ハンドブック" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. カーネルのインストール" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. リモートログイン" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/ja-JP/unix-services.html" /></head><body
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>戻る</strong></a></li><li
          class="home">Debian 管理者ハンドブック</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>次へ</strong></a></li></ul><div
        xml:lang="ja-JP"
        class="chapter"
        lang="ja-JP"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  id="unix-services"></a>第9章 Unix サービス</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. システム起動</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. systemd init システム</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. System V init システム</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. リモートログイン</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. 安全なリモートログイン: SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. リモートグラフィカルデスクトップの利用</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. 権限の管理</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. 管理インターフェース</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. ウェブインターフェースを使った管理: <code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. パッケージの設定: <code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. <code
                    class="command">syslog</code> システムイベント</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. 原理とメカニズム</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. 設定ファイル</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. <code
                    class="command">inetd</code> スーパーサーバ</a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. <code
                    class="command">cron</code> と <code
                    class="command">atd</code> を使ったスケジューリングタスク</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. <code
                        class="filename">crontab</code> ファイルの書式</a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. <code
                        class="command">at</code> コマンドの利用</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. 非同期タスクのスケジューリング: <code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. クォータ</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. バックアップ</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#idm139900947997312">9.10.1. <code
                        class="command">rsync</code> を使ったバックアップ</a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#idm139900947955680">9.10.2. バックアップなしのマシンの復元</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. ホットプラグ機能: <span
                    class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm139900947937728">9.11.1. はじめに</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm139900947928608">9.11.2. 命名問題</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm139900947914208">9.11.3. <span
                        class="emphasis"><em>udev</em></span> の動作原理</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm139900947862384">9.11.4. 具体例</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. 電源管理: Advanced Configuration and Power Interface (ACPI)</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		この章では、多くの Unix システムに共通する数多くの基本的なサービスをカバーします。すべての管理者はこれらに精通しているべきです。
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    id="sect.system-boot"></a>9.1. システム起動</h2></div></div></div><a
            id="idm139900957653856"
            class="indexterm"></a><div
            class="para">
			コンピュータを起動する際、コンソール画面にスクロールされる多くのメッセージには、実行されている多くの自動初期化と自動設定に関する情報が表示されます。この段階の挙動を少し変えたいと思うことがあるかもしれません。これは起動処理をよく理解する必要があることを意味しています。これがこの節の目的です。
		</div><div
            class="para">
			最初に BIOS がコンピュータを制御し、ディスクを検出し、<span
              class="emphasis"><em>Master Boot Record</em></span> を読み込み、ブートローダを実行します。以降、ブートローダが引き継ぎ、ディスクからカーネルを見つけ、カーネルを読み込んで実行します。そして、カーネルが初期化され、root ファイルシステムを含むパーティションの検索とマウントを開始し、最後に最初のプログラム - <code
              class="command">init</code> - を実行します。実際には、「root パーティション」と <code
              class="command">init</code> は RAM の中にだけ存在する仮想ファイルシステム (そのためこの名前は「initramfs」、以前は「初期化 RAM ディスク」という意味で「initrd」と呼ばれていました) 上に置かれていることが多いです。多くの場合、このファイルシステムはハードドライブのファイルかネットワークから、ブートローダによってメモリに読み込まれます。このファイルシステムには、カーネルが「真の」root ファイルシステムを読み込むために必要な最低限の要素が含まれています: ハードドライブやそれなしではシステムが起動できないその他のデバイスのドライバモジュール、より頻繁にあるのが、RAID アレイを組み立て、暗号化されたパーティションを開き、LVM ボリュームを有効化するなどの初期化スクリプトとモジュールです。一度 root パーティションがマウントされたら、initramfs は制御を真の init に渡し、マシンは標準的な起動処理に戻ります。
		</div><div
            class="figure"><a
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="systemd を使う Linux の動くコンピュータの起動シーケンス" /></div></div><p
              class="title"><strong>図9.1 systemd を使う Linux の動くコンピュータの起動シーケンス</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.systemd"></a>9.1.1. systemd init システム</h3></div></div></div><div
              class="para">
				「基本的な init」は現在 <span
                class="pkg pkg">systemd</span> によって提供されています。この節ではこの init システムに付いて説明します。
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CULTURE</em></span> <code
                          class="command">systemd</code> 以前</strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> は比較的最近の「init システム」で、既に <span
                  class="distribution distribution">Wheezy</span> ではある程度利用可能でしたが、Debian <span
                  class="distribution distribution">Jessie</span> からデフォルトに採用されました。以前のリリースはデフォルトで「System V init」(<span
                  class="pkg pkg">sysv-rc</span> パッケージに含まれます) を採用していました。SysV init はより伝統的なシステムです。SysV init については後で説明します。
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVE</em></span> 他の起動システム</strong></p></div></div></div><div
                class="para">
				本書は Debian <span
                  class="distribution distribution">Jessie</span> のデフォルト起動システム (<span
                  class="pkg pkg">systemd</span> パッケージによる実装) および以前のデフォルト起動システム <span
                  class="pkg pkg">sysvinit</span> について説明します。<span
                  class="pkg pkg">sysvinit</span> は <span
                  class="emphasis"><em>System_V</em></span> Unix システムから派生し受け継がれたものです; 他の起動システムも存在します。
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> は極めて単純なやり方を使う起動システムです。<span
                  class="pkg pkg">file-rc</span> はランレベルの原則を守りますが、ディレクトリとシンボリックリンクを設定ファイルで置換します。この設定ファイルを使っては <code
                  class="command">init</code> に対して起動するプロセスとその起動順を伝えます。
			</div><div
                class="para">
				Debian 上の <code
                  class="command">upstart</code> システムはまだ完全に試されていません。<code
                  class="command">upstart</code> はイベントに基づく起動システムです: init スクリプトはもはや逐次的順序でなく、あるスクリプトが依存する他のスクリプトの完了などのイベントに応じて起動されます。Ubuntu の始めたこのシステムは Debian <span
                  class="distribution distribution">Jessie</span> に含まれますが、デフォルトではありません; 実際のところ、<code
                  class="command">upstart</code> は <span
                  class="pkg pkg">sysvinit</span> の代替として始まりました。<code
                  class="command">upstart</code> の起動するタスクの 1 つが <span
                  class="pkg pkg">sysv-rc</span> パッケージの提供する伝統的なシステム向けに書かれたスクリプトを起動します。
			</div><div
                class="para">
				他の起動システムや他の動作モードも存在します。たとえば <code
                  class="command">runit</code>、<code
                  class="command">minit</code>、<code
                  class="command">initng</code> などです。しかしこれらは比較的特殊で広く使われていません。
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SPECIFIC CASE</em></span> ネットワークからの起動</strong></p></div></div></div><div
                class="para">
				一部の設定では、BIOS が MBR を実行しないように設定され、その代わり同じものをネットワークから探すように設定されているかもしれません。こうすることで、ハードドライブなしでコンピュータを組み立てたり、起動するたびに完全に再インストールすることが可能になります。このオプションは、すべてのハードウェアで利用できるというわけではありませんし、通常 BIOS とネットワークカードの適切な組み合わせが必要です。
			</div><div
                class="para">
				ネットワークからの起動は <code
                  class="command">debian-installer</code> や FAI (<a
                  class="xref"
                  href="installation.html#sect.installation-methods">「インストール方法」</a>参照) を起動するために使われます。
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>BACK TO BASICS</em></span> プロセス、プログラムインスタンス</strong></p></div></div></div><a
                id="idm139900956408976"
                class="indexterm"></a><div
                class="para">
				プロセスとは、実行中のプログラムのメモリ内表現です。プロセスには、ソフトウェアを適切に実行するために必要なすべての情報が含まれます (ソフトウェアのコードだけでなく、ソフトウェアが所有するメモリ内のデータ、ソフトウェアが開いたファイルのリスト、ソフトウェアが確立したネットワーク接続など)。単独のプログラムは複数のプロセスにインスタンス化されるかもしれませんし、異なるユーザ ID の下で実行される必要はありません。
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SECURITY</em></span> root 権を獲得するために <code
                          class="command">init</code> としてシェルを使う</strong></p></div></div></div><div
                class="para">
				慣例により、起動される最初のプロセスは <code
                  class="command">init</code> プログラムです (これはデフォルトで <code
                  class="filename">/lib/systemd/systemd</code> へのシンボリックリンクです)。しかしながら、カーネルに <code
                  class="literal">init</code> オプションを渡して別のプログラムを開始することも可能です。
			</div><a
                id="idm139900956403440"
                class="indexterm"></a><div
                class="para">
				コンピュータに触ることができる人は誰でも、<span
                  class="keycap"><strong>Reset</strong></span> ボタンを押して、コンピュータを再起動することが可能です。そして、ブートローダプロンプトでカーネルに <code
                  class="literal">init=/bin/sh</code> オプションを渡せば、管理者パスワードを知らなくても root 権を取得できます。
			</div><div
                class="para">
				これを避けるため、パスワードでブートローダを保護することが可能です。さらに BIOS へのアクセスも保護したいと考えるかもしれません (パスワード保護機能はほぼ必ず付いています)。パスワードがなければ、悪意ある侵入者が、自分の Linux システムを含むリムーバブルメディアからマシンを起動して、コンピュータのハードドライブのデータにアクセスするかもしれません。
			</div><div
                class="para">
				最後に、ほとんどの BIOS では、汎用的なパスワードが使えることに注意してください。当初、汎用パスワードはパスワードを忘れた人向けのトラブルシューティングを意図していましたが、今や汎用パスワードは公開されインターネットから入手できます (ご自分の手で、検索エンジンで「generic BIOS passwords」を検索してみてください)。これらの保護により、マシンへの不正アクセスを完全に防ぐことはできないにせよ、それを遅らせることになるでしょう。攻撃者が物理的にコンピュータにアクセスできる場合、確実にコンピュータを保護する方法はありません; 攻撃者はハードドライブを取り外して自分の制御下にあるコンピュータに接続したり、マシン本体ごと盗んだり、パスワードをリセットするために BIOS メモリを消去することも可能です…
			</div></div><div
              class="para">
				Systemd はシステムの設定を担当している複数のプロセスを実行します: キーボード、ドライバ、ファイルシステム、ネットワーク、サービス。Systemd はシステム全体におよぶ包括的視点と各要素の要求条件を満足させながらこれを行います。各要素は「ユニットファイル」(これだけでは済まない場合もあります) によって定義されています; ユニットファイルの一般的な構文は広く使われている「*.ini ファイル」の構文から派生したもので、<code
                class="literal">[<em
                  class="replaceable">section</em>]</code> ヘッダでグループ化された <code
                class="literal"><em
                  class="replaceable">key</em> = <em
                  class="replaceable">value</em></code> ペアを使います。ユニットファイルは <code
                class="filename">/lib/systemd/system/</code> と <code
                class="filename">/etc/systemd/system/</code> の下に保存されます; ユニットファイルはいくつかの形式がありますが、われわれは「service」型と「target」型に注目します。
			</div><div
              class="para">
				systemd の「service ファイル」は systemd が管理するプロセスを記述します。「service ファイル」にはおおまかに言って古いスタイルの init スクリプトと同じ情報が含まれていますが、宣言的な方法 (そしてより簡潔な方法) を使ってその情報が記述されています。systemd は繰り返しタスク (プロセスの開始と停止、状態確認、ログ記録、特権の取り消し、など) の大部分を取り扱い、service ファイルにはプロセスに特有の情報を記入する必要があります。たとえば、以下は SSH 用の service ファイルです:
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</pre><div
              class="para">
				ご覧のとおり、内容はとても少なく、ただの宣言に過ぎません。systemd は作業進行状況を表示したり、プロセスを監視したり、必要なときにプロセスを再起動することを担当します。
			</div><div
              class="para">
				systemd の「target ファイル」はシステムの状態を表現するもので、このファイルを使って利用可能状態になっていなければいけないサービス群を指定します。「target ファイル」は昔ながらのランレベルに相当するものとして考えることが可能です。target ファイルの 1 つに <code
                class="literal">local-fs.target</code> があります; このターゲットを処理する際には、残りのシステムはすべてのローカルファイルシステムがマウントされアクセスできるようになっている状態を仮定することが可能です。また別の target ファイルに <code
                class="literal">network-online.target</code> と <code
                class="literal">sound.target</code> があります。ターゲットの依存関係を指定するには target ファイルの (<code
                class="literal">Requires=</code> 行で) リスト指定するか、<code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">targetname</em>.target.wants/</code> ディレクトリに service ファイルへのシンボリックリンクを保存することで行います。たとえば、<code
                class="filename">/etc/systemd/system/printer.target.wants/</code> には <code
                class="filename">/lib/systemd/system/cups.service</code> へのリンクが含まれます; このため systemd は <code
                class="literal">printer.target</code> を処理する前に CUPS が実行されていることを保証するでしょう。
			</div><div
              class="para">
				ユニットファイルは宣言型の設定ファイルでありスクリプトやプログラムではないため、直接実行することは不可能で、systemd によってのみ解釈されます。いくつかのユーティリティを使うことで、管理者は systemd と情報をやりとりして、システムおよびシステム部品の状態を制御することが可能です。
			</div><div
              class="para">
				systemd と情報をやりとりする 1 番目のユーティリティとして <code
                class="command">systemctl</code> が挙げられます。<code
                class="command">systemctl</code> を引数なしで実行した場合、systemd が把握しているすべてのユニットファイル (無効化されているものを除く) およびその状態が表示されます。<code
                class="command">systemctl status</code> を使うことで、サービスおよび関連するプロセスをよりわかりやすく表示することが可能です。サービスの名前を指定した (<code
                class="command">systemctl status ntp.service</code> のように指定した) 場合、<code
                class="command">systemctl</code> はさらに詳しい情報および指定したサービスに関連するログの最後の (最新の) 数行を表示します。
			</div><div
              class="para">
				手作業でサービスを開始するのは簡単で、<code
                class="command">systemctl start <em
                  class="replaceable">servicename</em>.service</code> を実行するだけです。予想通り、サービスを停止するには <code
                class="command">systemctl stop <em
                  class="replaceable">servicename</em>.service</code> を使います; 他のサブコマンドには <code
                class="command">reload</code> と <code
                class="command">restart</code> があります。
			</div><div
              class="para">
				サービスを有効化するには (たとえば、起動時に自動的にサービスを開始するには)、<code
                class="command">systemctl enable <em
                  class="replaceable">servicename</em>.service</code> (または <code
                class="command">disable</code>) を使います。<code
                class="command">is-enabled</code> を使えば、サービスの状態を確認することが可能です。
			</div><div
              class="para">
				systemd の興味深い機能として、<code
                class="command">journald</code> と名付けられたログ記録部品が挙げられます。<code
                class="command">journald</code> は <code
                class="command">syslogd</code> などのより伝統的なログ記録ファイルシステムを補完するために誕生しましたが、サービスとサービスが生成したメッセージ間を正しく結びつけたり、初期化シーケンスが生成するエラーメッセージを捕捉する能力などの興味深い機能を追加しています。<code
                class="command">journalctl</code> コマンドの助けを借りれば、メッセージを後から表示することも可能です。引数なしで実行した場合、<code
                class="command">journalctl</code> は起動後に発生したすべてのログメッセージを表示します; 引数を与えずに実行することはほとんどないでしょう。ほとんどの場合、サービス識別子を与えて <code
                class="command">journalctl</code> を実行することが多いでしょう。
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at 火 2015-03-31 17:08:49 JST, end at 水 2015-04-01 00:06:02 JST. --
 3月 31 17:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
 3月 31 17:08:55 mirtuel sshd[430]: Server listening on :: port 22.
 3月 31 17:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
 3月 31 17:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
 3月 31 17:09:00 mirtuel sshd[430]: Server listening on :: port 22.
 3月 31 17:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
 3月 31 17:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				また別の便利なコマンドラインフラグとして <code
                class="command">-f</code> が挙げられます。これを使った場合、<code
                class="command">journalctl</code> は新しいメッセージを受け取ったらそのメッセージを表示し続けます (もっと言えば <code
                class="command">tail -f <em
                  class="replaceable">file</em></code> のやり方です)。
			</div><div
              class="para">
				サービスが期待通りに動いていないように見える場合、プログラムをデバッグするために、サービスが本当に <code
                class="command">systemctl status</code> を使って実行されているか否かを真っ先に確認します; サービスが実行されていなくて、<code
                class="command">systemctl status</code> の表示したメッセージが問題の原因を突き止めるのに十分でない場合、journald が収集したサービスに関連するログを確認します。たとえば、SSH サービスが動いていないと仮定します:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since 水 2015-04-01 00:30:36 JST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

 4月  1 00:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
 4月  1 00:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
 4月  1 00:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at 水 2015-04-01 00:29:27 JST, end at 水 2015-04-01 00:30:36 JST. --
 4月  1 00:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
 4月  1 00:29:27 mirtuel sshd[424]: Server listening on :: port 22.
 4月  1 00:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
 4月  1 00:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
 4月  1 00:29:29 mirtuel sshd[424]: Server listening on :: port 22.
 4月  1 00:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
 4月  1 00:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
 4月  1 00:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
 4月  1 00:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
 4月  1 00:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
 4月  1 00:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
 4月  1 00:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
 4月  1 00:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
 4月  1 00:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
 4月  1 00:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
 4月  1 00:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
 4月  1 00:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
 4月  1 00:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
 4月  1 00:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
 4月  1 00:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
 4月  1 00:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
 4月  1 00:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since 水 2015-04-01 00:31:09 JST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				サービスの状態が失敗状態であることを確認した後、ログの確認作業に進みました; ログは設定ファイル内にエラーがあることを示しています。設定ファイルを編集してエラーを修正した後、SSH サービスを再起動し、SSH サービスが本当に動いていることを確認します。
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GOING FURTHER</em></span> ユニットファイルの他の型</strong></p></div></div></div><div
                class="para">
				この節では、systemd の最も基本的な機能だけを説明しました。systemd は他にも多くの興味深い機能を備えています; ここで一部を紹介します:
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						ソケットの活性化: 「socket」型のユニットファイルを使えば、systemd が管理するネットワークや Unix ソケットを表現することが可能です。これは systemd がソケットを作成し、実際のサービスは実際の接続要求を受信した時に要求に応じて開始されることを意味しています。この機能はおおまかに言って <code
                        class="command">inetd</code> の機能群を再現するものです。
					</div></li><li
                    class="listitem"><div
                      class="para">
						タイマ: 「timer」型のユニットファイルを使えば、固定周期で発動するイベントを表現することが可能です; サービスをタイマに関連付けた場合、タイマが発動するたびに対応するタスクを実行します。同様のやり方で、「time」型のユニットファイルを使えば、特定の時刻に発動するイベントを表現することが可能です。これを使うことで、<code
                        class="command">cron</code> 機能の一部を置き換えることが可能です。
					</div></li><li
                    class="listitem"><div
                      class="para">
						ネットワーク: 「network」型のユニットファイルを使えば、ネットワークインターフェースを表現することが可能です。これを使うことで、ネットワークインターフェースを設定したり、サービスが特定のネットワークインターフェースの状態に依存することを表現することが可能です。
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.sysvinit"></a>9.1.2. System V init システム</h3></div></div></div><div
              class="para">
				System V init システム (これを短縮して init と呼びます) は、<code
                class="filename">/etc/inittab</code> ファイルの指示に従って、複数のプロセスを起動します。実行される最初のプログラム (<span
                class="emphasis"><em>sysinit</em></span> 段階に相当します) は <code
                class="command">/etc/init.d/rcS</code> で、これは <code
                class="filename">/etc/rcS.d/</code> ディレクトリに含まれるすべてのプログラムを起動するスクリプトです。<a
                id="idm139900952796624"
                class="indexterm"></a> <a
                id="idm139900952795824"
                class="indexterm"></a> <a
                id="idm139900952795024"
                class="indexterm"></a> <a
                id="idm139900952794224"
                class="indexterm"></a>
			</div><div
              class="para">
				これらのスクリプトは特に以下の点を担当します:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						コンソールキーボードの設定;
					</div></li><li
                  class="listitem"><div
                    class="para">
						ドライバの読み込み: カーネルはほとんどのカーネルモジュールを読み込み、ハードウェアを検出します; 追加のドライバは、それに対応するモジュールが <code
                      class="filename">/etc/modules</code> にリストされている場合に、読み込まれます。
					</div></li><li
                  class="listitem"><div
                    class="para">
						ファイルシステムの整合性確認;
					</div></li><li
                  class="listitem"><div
                    class="para">
						ローカルパーティションのマウント;
					</div></li><li
                  class="listitem"><div
                    class="para">
						ネットワークの設定;
					</div></li><li
                  class="listitem"><div
                    class="para">
						ネットワークファイルシステム (NFS) のマウント。
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>BACK TO BASICS</em></span> カーネルモジュールとオプション</strong></p></div></div></div><a
                id="idm139900952784752"
                class="indexterm"></a><div
                class="para">
				カーネルモジュールにオプションを指定するには、<code
                  class="filename">/etc/modprobe.d/</code> にファイルを追加してください。これらのオプションは次のような指示文を使って定義します。<code
                  class="literal">options <em
                    class="replaceable">module-name</em> <em
                    class="replaceable">option-name</em>=<em
                    class="replaceable">option-value</em></code>。場合によっては、いくつかのオプションは単独の指示文で指定できます。
			</div><div
                class="para">
				<code
                  class="command">modprobe</code> がこれらの設定ファイルを使います。このプログラムは依存関係に従ってカーネルモジュールを読み込みます (モジュールは他のモジュールを呼ぶことができます)。<code
                  class="command">modprobe</code> は <span
                  class="pkg pkg">kmod</span> パッケージによって提供されます。
			</div><a
                id="idm139900952778160"
                class="indexterm"></a><a
                id="idm139900952777040"
                class="indexterm"></a></div><div
              class="para">
				この段階の後、<code
                class="command">init</code> が引き継ぎ、デフォルトランレベル (通常ランレベル 2) で有効化されたプログラムを起動します。<code
                class="command">init</code> は <code
                class="command">/etc/init.d/rc 2</code> を実行します。これは <code
                class="filename">/etc/rc2.d/</code> 置かれて、「S」で始まる名前のすべてのサービスを開始するスクリプトです。「S」の後に続く 2 桁の数字は、歴史的言って、起動するサービスの順番を定義するために使われていました。しかし今やデフォルトの起動システムは <code
                class="command">insserv</code> を使って、スクリプト同士の依存関係に従った起動順を自動的に決定します。このため、各起動スクリプトはサービスを起動または終了させる時に満足しなければいけない条件を宣言します (たとえば、あるサービスは他のサービスの前または後に起動しなければいけないなど); そして、<code
                class="command">init</code> は条件を満足するようにサービスを起動します。このため、スクリプトの静的な番号付けはもはや考慮されません (しかしスクリプトの名前は必ず「S」で始まり、その後ろに 2 桁の番号を付け、依存関係に使われる実際のスクリプトの名前を続けなければいけません)。一般に、ベースシステム (ログ記録を担当している <code
                class="command">rsyslog</code> やポート割り当てを担当している <code
                class="command">portmap</code>) が最初に起動され、その後に標準的なサービスとグラフィカルインターフェース (<code
                class="command">gdm3</code>) が起動されます。
			</div><div
              class="para">
				この依存関係に基づく起動システムのおかげで、自動的な起動順の再定義が可能になります。これは手作業でやるにはちょっと退屈な作業で、人的ミスの危険性があります。なぜなら、起動順は宣言された依存関係に従って定義されるからです。別の利益として、他のサービスに依存しないサービスは並列して開始できるという点があります。このことにより、起動処理を加速できます。
			</div><a
              id="idm139900952603264"
              class="indexterm"></a><a
              id="idm139900952602304"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">init</code> はいくつかのランレベルを区別します。そうすることで、<code
                class="command">telinit <em
                  class="replaceable">new-level</em></code> コマンドを使ってあるランレベルから別のランレベルに切り替えることができます。即座に <code
                class="command">init</code> は新しいランレベルで <code
                class="command">/etc/init.d/rc</code> を再実行します。このスクリプトは欠けているサービスを開始し、もはや不要なサービスを停止します。これを行うために、<code
                class="command">init</code> は <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> の内容を参照します (ここで <em
                class="replaceable">X</em> は新しいランレベルです)。(「Start」の)「S」で始まるスクリプトは開始されるサービスです; (「Kill」の)「K」で始まるスクリプトは停止されるサービスです。このスクリプトは前のランレベルで既に起動されているサービスは開始しません。
			</div><div
              class="para">
				デフォルトで、Debian の System V init は 4 種類のランレベルを使います:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						レベル 0 はコンピュータの電源を切る祭に一時的に使われるだけです。このため「K」スクリプトしか含まれません。
					</div></li><li
                  class="listitem"><div
                    class="para">
						シングルユーザモードとしても知られるレベル 1 はシステムの機能抑制モードに相当します; このモードでは基本的なサービスだけが提供され、一般ユーザにマシンを使わせないメンテナンス作業を対象としています。
					</div></li><li
                  class="listitem"><div
                    class="para">
						レベル 2 は通常動作用のモードで、ネットワークサービス、グラフィカルインターフェース、ユーザログインなどの機能を使うことが可能です。
					</div></li><li
                  class="listitem"><div
                    class="para">
						レベル 6 はレベル 0 と似ていますが、再起動前のシャットダウン段階中に使われる点が異なります。
					</div></li></ul></div><div
              class="para">
				他のレベル、特に 3 から 5 まで、も存在します。デフォルトでこれらのランレベルはレベル 2 と同じ様に動作しますが、管理者はこれを変えて (ランレベルに対応する <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> ディレクトリにスクリプトを追加したりおよび削除したりすることで) 特定の要求に順応させることが可能です。
			</div><div
              class="figure"><a
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="System V init を使う Linux の動くコンピュータの起動シーケンス" /></div></div><p
                class="title"><strong>図9.2 System V init を使う Linux の動くコンピュータの起動シーケンス</strong></p></div><a
              id="idm139900952585952"
              class="indexterm"></a><div
              class="para">
				さまざまな <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> ディレクトリに含まれるすべてのスクリプトは <code
                class="filename">/etc/init.d/</code> に格納されたスクリプトの実体を指すシンボリックリンク - パッケージのインストール時に <code
                class="command">update-rc.d</code> プログラムによって作られます - に過ぎません。管理者は、調整したパラメータを与えて <code
                class="command">update-rc.d</code> を再実行して、各ランレベルで利用できるサービスを微調整することが可能です。<code
                class="command">update-rc.d</code> の構文は <span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(1)</span> マニュアルページに詳しく説明されています。サービスを無効化する目的で、(<code
                class="literal">remove</code> パラメータを付けて) すべてのシンボリックリンクを削除するのは悪い方法であるという点に注意してください。その代わりに、単純に希望するランレベルでそのサービスを起動しないよう設定するべきです (一方で、万が一、前のランレベルでそのサービスが実行されている場合に備えて、そのランレベルでもサービスを停止するために必要なシンボリックリンクを確保しておくべきです)。<code
                class="command">update-rc.d</code> は複雑なインターフェースを持っているため、(<span
                class="pkg pkg">rcconf</span> パッケージの提供する) <code
                class="command">rcconf</code> を使いたいと思うかもしれません。<code
                class="command">rcconf</code> はよりユーザにとって使い勝手の良いインターフェースを提供します。
			</div><a
              id="idm139900952577024"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DEBIAN POLICY</em></span> サービスの再起動</strong></p></div></div></div><a
                id="idm139900952574816"
                class="indexterm"></a><a
                id="idm139900952573696"
                class="indexterm"></a><a
                id="idm139900952572256"
                class="indexterm"></a><div
                class="para">
				Debian のメンテナスクリプトは、サービスを利用できるようにするためか、特定のオプションを考慮するために、特定のサービスを再起動することがあります。サービスを操作するコマンド - <code
                  class="command">/etc/init.d/<em
                    class="replaceable">service</em> <em
                    class="replaceable">operation</em></code> - はランレベルを考慮しません。サービスが現在使用中であると (間違って) 仮定し、間違った操作 (故意に停止されたサービスの開始や既に停止されたサービスの停止など) を開始するかもしれません。このため Debian は <code
                  class="command">invoke-rc.d</code> プログラムを導入しました: メンテナスクリプト内でサービス初期化スクリプトを実行する場合は、必ずこのプログラムを使わなければいけません。このプログラムは必要なコマンドを実行するだけです。通常の使い方と異なり、ディレクトリではなくプログラム名に <code
                  class="filename">.d</code> サフィックスが使われている点に注意してください。
			</div></div><div
              class="para">
				最後に、<code
                class="command">init</code> はさまざまな仮想コンソール (<code
                class="command">getty</code>) 用の制御プログラムを開始します。この制御プログラムがプロンプトを表示し、ユーザ名の入力を待ち、セッションを開始するために <code
                class="command">login <em
                  class="replaceable">user</em></code> を実行します。
			</div><a
              id="idm139900952565264"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOCABULARY</em></span> コンソールと端末</strong></p></div></div></div><div
                class="para">
				最初のコンピュータは通常、複数のとても大きな部品に分かれていました: ストレージ収納装置と中央処理装置は、それらを操作するオペレータが使う周辺装置と分けられていました。分離された周辺装置、これが「コンソール」です。この用語は残りましたが、意味が変わりました。「コンソール」は「端末」と大体同義語になり、キーボードと画面を備えるようになりました。
			</div><div
                class="para">
				コンピュータの開発とともに、オペレーティングシステムは、たとえもしマシンに 1 台のキーボードと画面しか接続されていなかったとしても、複数の独立したセッションを同時に取り扱う目的で、複数の仮想コンソールを提供するようになりました。多くの GNU/Linux システムでは、<span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> から <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span> までのキーの組み合わせをタイプすることで 6 つの仮想コンソールを切り替えられます (テキストモード)。
			</div><div
                class="para">
				転じて、「コンソール」と「端末」という用語はグラフィカル X11 セッションで使われる端末エミュレータ (<code
                  class="command">xterm</code>、<code
                  class="command">gnome-terminal</code>、<code
                  class="command">konsole</code> など) でも使われています。
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>戻る</strong>8.11. カーネルのインストール</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>上に戻る</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>ホーム</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>次へ</strong>9.2. リモートログイン</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/unix-services.html">ar-MA</a></li><li><a
              href="../da-DK/unix-services.html">da-DK</a></li><li><a
              href="../de-DE/unix-services.html">de-DE</a></li><li><a
              href="../el-GR/unix-services.html">el-GR</a></li><li><a
              href="../en-US/unix-services.html">en-US</a></li><li><a
              href="../es-ES/unix-services.html">es-ES</a></li><li><a
              href="../fa-IR/unix-services.html">fa-IR</a></li><li><a
              href="../fr-FR/unix-services.html">fr-FR</a></li><li><a
              href="../hr-HR/unix-services.html">hr-HR</a></li><li><a
              href="../id-ID/unix-services.html">id-ID</a></li><li><a
              href="../it-IT/unix-services.html">it-IT</a></li><li><a
              href="../ja-JP/unix-services.html">ja-JP</a></li><li><a
              href="../pl-PL/unix-services.html">pl-PL</a></li><li><a
              href="../pt-BR/unix-services.html">pt-BR</a></li><li><a
              href="../ro-RO/unix-services.html">ro-RO</a></li><li><a
              href="../ru-RU/unix-services.html">ru-RU</a></li><li><a
              href="../tr-TR/unix-services.html">tr-TR</a></li><li><a
              href="../zh-CN/unix-services.html">zh-CN</a></li></ul></div></body></html>
