<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.4. Algunas tareas administradas por el núcleo</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.1" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-es-ES-1.0-1" /><meta
        name="keywords"
        content="BIOS, Núcleo, Unix, Proceso, Jerarquía, Órdenes básicas" /><link
        rel="home"
        href="index.html"
        title="El libro del administrador de Debian" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Apéndice B. Curso breve de emergencia" /><link
        rel="prev"
        href="sect.computer-layers.html"
        title="B.3. Funcionamiento interno de un equipo: las diferentes capas involucradas" /><link
        rel="next"
        href="sect.user-space.html"
        title="B.5. El espacio de usuario" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/es-ES/sect.kernel-role-and-tasks.html" /></head><body
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>Anterior</strong></a></li><li
          class="home">El libro del administrador de Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>Siguiente</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.kernel-role-and-tasks"></a>B.4. Algunas tareas administradas por el núcleo</h2></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.hardware-drivers"></a>B.4.1. Administración del hardware</h3></div></div></div><div
            class="para">
				El núcleo tiene, antes que nada, la tarea de controlar las partes del hardware, detectarlas, encenderlas cuando se enciende el equipo, etc. También los pone a disposición del software de más alto nivel con una interfaz de programación simplificada para que las aplicaciones puedan aprovechar dispositivos sin tener que preocuparse por detalles como cuál puerto de extensión es aquél en el que está conectada una tarjeta. La interfaz de programación también provee una capa de abstracción; permite, por ejemplo, que el software de videoconferencias utilice una cámara web independientemente de su modelo y fabricante. El software puede utilizar simplemente la interfaz <span
              class="emphasis"><em>video para Linux</em></span> (V4L: «Video for Linux») y el núcleo traduce las llamadas a las funciones de esta interfaz a las órdenes de hardware reales que necesita la cámara específica que está utilizando.
			</div><div
            class="para">
				<a
              id="idm140474886137280"
              class="indexterm"></a> <a
              id="idm140474886136480"
              class="indexterm"></a> <a
              id="idm140474886135680"
              class="indexterm"></a> <a
              id="idm140474886134880"
              class="indexterm"></a> El núcleo exporta muchos detalles sobre el hardware detectado a través de los sistemas de archivos virtuales <code
              class="filename">/proc/</code> y <code
              class="filename">/sys/</code>. Muchas herramientas resumen estos detalles. Entre ellas, <code
              class="command">lspci</code> (en el paquete <span
              class="pkg pkg">pciutils</span>) enumera los dispositivos PCI, <code
              class="command">lsusb</code> (en el paquete <span
              class="pkg pkg">usbutils</span>) enumera los dispositivos USB y <code
              class="command">lspcmcia</code> (en el paquete <span
              class="pkg pkg">pcmciautils</span>) enumera las tarjetas PCMCIA. Estas herramientas son muy útiles para identificar el modelo exacto de un dispositivo. Esta identificación permite realizar búsquedas más precisas en la web lo que, a su vez, lleva a documentos más relevantes.
			</div><div
            class="example"><a
              id="idm140474886129264"></a><p
              class="title"><strong>Ejemplo B.1. Ejemplo de información provista por <code
                  class="command">lspci</code> y <code
                  class="command">lsusb</code></strong></p><div
              class="example-contents"><pre
                class="screen">
<code
                  class="computeroutput">$ </code><strong
                  class="userinput"><code>lspci</code></strong>
<code
                  class="computeroutput">[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </code><strong
                  class="userinput"><code>lsusb</code></strong>
<code
                  class="computeroutput">Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</code></pre></div></div><div
            class="para">
				Estos programas tienen una opción <code
              class="literal">-v</code>, que mostrará información mucho más detallada (pero generalmente innecesaria). Finalmente, el programa <code
              class="command">lsdev</code> (en el paquete <span
              class="pkg pkg">procinfo</span>) enumera los recuros de comunicación utilizados por los dispositivos.
			</div><div
            class="para">
				Las aplicaciones frecuentemente acceden a los dispositivos a través de archivos especiales creados en <code
              class="filename">/dev/</code> (revise el recuadro <a
              class="xref"
              href="sect.creating-accounts.html#sidebar.special-files"><span
                class="emphasis"><em>VOLVER A LOS CIMIENTOS</em></span> Permisos de acceso a dispositivos</a>). Éstos son archivos especiales que representan discos (por ejemplo: <code
              class="filename">/dev/hda</code> y <code
              class="filename">/dev/sdc</code>), particiones (<code
              class="filename">/dev/hda1</code> o <code
              class="filename">/dev/sdc3</code>, ratones (<code
              class="filename">/dev/input/mouse0</code>), teclados (<code
              class="filename">/dev/input/event0</code>), tarjetas de sonido (<code
              class="filename">/dev/snd/*</code>), puertos seriales (<code
              class="filename">/dev/ttyS*</code>), etc.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.filesystems"></a>B.4.2. Sistemas de archivos</h3></div></div></div><a
            id="idm140474886115616"
            class="indexterm"></a><a
            id="idm140474886114656"
            class="indexterm"></a><div
            class="para">
				Los sistemas de archivos son uno de los aspectos más destacados del núcleo. Los sistemas Unix agrupan todos los archivos que almacenan en una jerarquía única, lo que permite a los usuarios (y las aplicaciones) acceder a los datos simplemente conociendo su ubicación dentro de dicha jerarquía.
			</div><div
            class="para">
				El nombre del punto de partida de este árbol jerárquico es la raíz, <code
              class="filename">/</code>. Este directorio puede tener subdirectorios con nombres. Por ejemplo, el nombre del subdirectorio <code
              class="literal">home</code> de <code
              class="filename">/</code> es <code
              class="filename">/home/</code>. Este subdirectorio, a su vez, puede contener otros subdirectorios y así sucesivamente. Cada directorio también puede contener archivos, donde se almacenarán los datos en sí. Por lo tanto, el nombre <code
              class="filename">/home/rmas/Desktop/hello.txt</code> se refiere al archivo <code
              class="literal">hello.txt</code> almacenado en el subdirectorio <code
              class="literal">Desktop</code> del subdirectorio <code
              class="literal">rmas</code> del directorio <code
              class="literal">home</code> presente en la raíz. El núcleo traduce este sistema de nombres en el almacenamiento físico real en un disco.
			</div><div
            class="para">
				A diferencia de otros sistemas, existe sólo una jerarquía de este tipo que puede integrar datos de varios discos. Se utiliza uno de estos discos como raíz y los demás son «montados» en directorios de la jerarquía (el programa Unix se llama <code
              class="command">mount</code>); luego estos otros discos estarán disponibles bajo estos «puntos de montaje». Esto permite almacenar los directorios personales de los usuarios (tradicionalmente almacenados en <code
              class="filename">/home/</code>) en un disco secundario que contendrá directorios <code
              class="literal">rhertzog</code> y <code
              class="literal">rmas</code>. Una vez que se montó el disco en <code
              class="filename">/home/</code>, estos directorios estarán disponibles en su ubicación usual y continuarán funcionando las rutas como <code
              class="filename">/home/rmas/Desktop/hello.txt</code>.
			</div><a
            id="idm140474886104208"
            class="indexterm"></a><div
            class="para">
				There are many filesystem formats, corresponding to many ways of physically storing data on disks. The most widely known are <span
              class="emphasis"><em>ext2</em></span>, <span
              class="emphasis"><em>ext3</em></span> and <span
              class="emphasis"><em>ext4</em></span>, but others exist. For instance, <span
              class="emphasis"><em>vfat</em></span> is the system that was historically used by DOS and Windows operating systems, which allows using hard disks under Debian as well as under Windows. In any case, a filesystem must be prepared on a disk before it can be mounted and this operation is known as “formatting”. Commands such as <code
              class="command">mkfs.ext3</code> (where <code
              class="command">mkfs</code> stands for <span
              class="emphasis"><em>MaKe FileSystem</em></span>) handle formatting. These commands require, as a parameter, a device file representing the partition to be formatted (for instance, <code
              class="filename">/dev/sda1</code>). This operation is destructive and should only be run once, except if one deliberately wishes to wipe a filesystem and start afresh.
			</div><div
            class="para">
				There are also network filesystems, such as <acronym
              class="acronym">NFS</acronym>, where data is not stored on a local disk. Instead, data is transmitted through the network to a server that stores and retrieves them on demand. The filesystem abstraction shields users from having to care: files remain accessible in their usual hierarchical way.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.shared-functions"></a>B.4.3. Funciones compartidas</h3></div></div></div><div
            class="para">
				Debido a que una cantidad de funciones son utilizadas por todo software, tiene sentido centralizarlas en el núcleo. Por ejemplo, la gestión compartida de sistemas de archivos permite que cualquier aplicación simplemente abra un archivo, sin preocuparse dónde está almacenado físicamente dicho archivo. Éste puede estar almacenado en diferentes porciones de un disco duro, dividido entre varios discos duros o inclusive almacenado en un servidor remoto. Las funciones de comunicación compartidas son utilizadas por las aplicaciones para intercambiar datos independientemente de la forma en la que se transportan los mismos. Por ejemplo, el transporte puede ser a través de una combinación de redes locales o inalámbricas o a través de una línea telefónica terrestre.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.process-management"></a>B.4.4. Gestión de proceso</h3></div></div></div><a
            id="idm140474886093312"
            class="indexterm"></a><div
            class="para">
				Un proceso es una instancia en ejecución de un programa. Esto necesita memoria para almacenar tanto el programa en sí como los datos con los que trabaja. El núcleo es el encargado de crearlos y seguirlos. Cuando se ejecuta un programa, primero el núcleo reserva memoria, carga en ella el código ejecutable desde el sistema de archivos y luego inicia la ejecución de este código. Mantiene información sobre este proceso, de las que la más visible es un número de identificación conocido como <span
              class="emphasis"><em>pid</em></span> (<span
              class="emphasis"><em>identificador de proceso</em></span>: «process identifier»).
			</div><div
            class="para">
				Unix-like kernels (including Linux), like most other modern operating systems, are capable of “multi-tasking”. In other words, they allow running many processes “at the same time”. There's actually only one running process at any one time, but the kernel cuts time into small slices and runs each process in turn. Since these time slices are very short (in the millisecond range), they create the illusion of processes running in parallel, although they're actually only active during some time intervals and idle the rest of the time. The kernel's job is to adjust its scheduling mechanisms to keep that illusion, while maximizing the global system performance. If the time slices are too long, the application may not appear as responsive as desired. Too short, and the system loses time switching tasks too frequently. These decisions can be tweaked with process priorities. High-priority processes will run for longer and with more frequent time slices than low-priority processes.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>NOTA</em></span> Sistemas multiprocesador (y variaciones)</strong></p></div></div></div><div
              class="para">
				The limitation described above of only one process being able to run at a time, doesn't always apply. The actual restriction is that there can only be one running process <span
                class="emphasis"><em>per processor core</em></span> at a time. Multi-processor, multi-core or “hyper-threaded” systems allow several processes to run in parallel. The same time-slicing system is still used, though, so as to handle cases where there are more active processes than available processor cores. This is far from unusual: a basic system, even a mostly idle one, almost always has tens of running processes.
			</div></div><div
            class="para">
				Por supuesto, el núcleo permite ejecutar varias instancias independientes del mismo programa. Pero cada una de ellas sólo puede acceder sus propias divisiones de tiempo y su propia memoria. Sus datos, por lo tanto, se mantienen independientes.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.permissions"></a>B.4.5. Gestión de permisos</h3></div></div></div><div
            class="para">
				Unix-like systems are also multi-user. They provide a rights management system that supports separate users and groups; it also allows control over actions based on permissions. The kernel manages data for each process, allowing it to control permissions. Most of the time, a process is identified by the user who started the process. That process is only permitted to take those actions available to its owner. For instance, trying to open a file requires the kernel to check the process identity against access permissions (for more details on this particular example, see <a
              class="xref"
              href="sect.rights-management.html">Sección 9.3, “Administración de permisos”</a>).
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>Anterior</strong>B.3. Funcionamiento interno de un equipo: las dif...</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Subir</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Inicio</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>Siguiente</strong>B.5. El espacio de usuario</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.kernel-role-and-tasks.html">ar-MA</a></li><li><a
              href="../da-DK/sect.kernel-role-and-tasks.html">da-DK</a></li><li><a
              href="../de-DE/sect.kernel-role-and-tasks.html">de-DE</a></li><li><a
              href="../el-GR/sect.kernel-role-and-tasks.html">el-GR</a></li><li><a
              href="../en-US/sect.kernel-role-and-tasks.html">en-US</a></li><li><a
              href="../es-ES/sect.kernel-role-and-tasks.html">es-ES</a></li><li><a
              href="../fa-IR/sect.kernel-role-and-tasks.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.kernel-role-and-tasks.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.kernel-role-and-tasks.html">hr-HR</a></li><li><a
              href="../id-ID/sect.kernel-role-and-tasks.html">id-ID</a></li><li><a
              href="../it-IT/sect.kernel-role-and-tasks.html">it-IT</a></li><li><a
              href="../ja-JP/sect.kernel-role-and-tasks.html">ja-JP</a></li><li><a
              href="../pl-PL/sect.kernel-role-and-tasks.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.kernel-role-and-tasks.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.kernel-role-and-tasks.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.kernel-role-and-tasks.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.kernel-role-and-tasks.html">tr-TR</a></li><li><a
              href="../zh-CN/sect.kernel-role-and-tasks.html">zh-CN</a></li></ul></div></body></html>
