<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.4. Algunas tareas administradas por el núcleo</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-es-ES-1.0-1" /><meta
        name="keywords"
        content="BIOS, Núcleo, Unix, Proceso, Jerarquía, Órdenes básicas" /><link
        rel="home"
        href="index.html"
        title="El libro del administrador de Debian" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Apéndice B. Curso breve de emergencia" /><link
        rel="prev"
        href="sect.computer-layers.html"
        title="B.3. Funcionamiento interno de un equipo: las diferentes capas involucradas" /><link
        rel="next"
        href="sect.user-space.html"
        title="B.5. El espacio de usuario" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/es-ES/sect.kernel-role-and-tasks.html" /></head><body
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>Anterior</strong></a></li><li
          class="home">El libro del administrador de Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>Siguiente</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.kernel-role-and-tasks"></a>B.4. Algunas tareas administradas por el núcleo</h2></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.hardware-drivers"></a>B.4.1. Administración del hardware</h3></div></div></div><div
            class="para">
				El núcleo tiene, antes que nada, la tarea de controlar las partes del hardware, detectarlas, encenderlas cuando se enciende el equipo, etc. También los pone a disposición del software de más alto nivel con una interfaz de programación simplificada para que las aplicaciones puedan aprovechar dispositivos sin tener que preocuparse por detalles como cuál puerto de extensión es aquél en el que está conectada una tarjeta. La interfaz de programación también provee una capa de abstracción; permite, por ejemplo, que el software de videoconferencias utilice una cámara web independientemente de su modelo y fabricante. El software puede utilizar simplemente la interfaz <span
              class="emphasis"><em>video para Linux</em></span> (V4L: «Video for Linux») y el núcleo traduce las llamadas a las funciones de esta interfaz a las órdenes de hardware reales que necesita la cámara específica que está utilizando.
			</div><div
            class="para">
				<a
              id="idm140114205295136"
              class="indexterm"></a> <a
              id="idm140114205294336"
              class="indexterm"></a> <a
              id="idm140114205293536"
              class="indexterm"></a> <a
              id="idm140114205292736"
              class="indexterm"></a> El núcleo exporta muchos detalles sobre el hardware detectado a través de los sistemas de archivos virtuales <code
              class="filename">/proc/</code> y <code
              class="filename">/sys/</code>. Muchas herramientas resumen estos detalles. Entre ellas, <code
              class="command">lspci</code> (en el paquete <span
              class="pkg pkg">pciutils</span>) enumera los dispositivos PCI, <code
              class="command">lsusb</code> (en el paquete <span
              class="pkg pkg">usbutils</span>) enumera los dispositivos USB y <code
              class="command">lspcmcia</code> (en el paquete <span
              class="pkg pkg">pcmciautils</span>) enumera las tarjetas PCMCIA. Estas herramientas son muy útiles para identificar el modelo exacto de un dispositivo. Esta identificación permite realizar búsquedas más precisas en la web lo que, a su vez, lleva a documentos más relevantes.
			</div><div
            class="example"><a
              id="idm140114205287120"></a><p
              class="title"><strong>Ejemplo B.1. Ejemplo de información provista por <code
                  class="command">lspci</code> y <code
                  class="command">lsusb</code></strong></p><div
              class="example-contents"><pre
                class="screen">
<code
                  class="computeroutput">$ </code><strong
                  class="userinput"><code>lspci</code></strong>
<code
                  class="computeroutput">[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </code><strong
                  class="userinput"><code>lsusb</code></strong>
<code
                  class="computeroutput">Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</code></pre></div></div><div
            class="para">
				Estos programas tienen una opción <code
              class="literal">-v</code>, que mostrará información mucho más detallada (pero generalmente innecesaria). Finalmente, el programa <code
              class="command">lsdev</code> (en el paquete <span
              class="pkg pkg">procinfo</span>) enumera los recuros de comunicación utilizados por los dispositivos.
			</div><div
            class="para">
				Las aplicaciones frecuentemente acceden a los dispositivos a través de archivos especiales creados en <code
              class="filename">/dev/</code> (revise el recuadro <a
              class="xref"
              href="sect.creating-accounts.html#sidebar.special-files"><span
                class="emphasis"><em>VOLVER A LOS CIMIENTOS</em></span> Permisos de acceso a dispositivos</a>). Éstos son archivos especiales que representan discos (por ejemplo: <code
              class="filename">/dev/hda</code> y <code
              class="filename">/dev/sdc</code>), particiones (<code
              class="filename">/dev/hda1</code> o <code
              class="filename">/dev/sdc3</code>, ratones (<code
              class="filename">/dev/input/mouse0</code>), teclados (<code
              class="filename">/dev/input/event0</code>), tarjetas de sonido (<code
              class="filename">/dev/snd/*</code>), puertos seriales (<code
              class="filename">/dev/ttyS*</code>), etc.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.filesystems"></a>B.4.2. Sistemas de archivos</h3></div></div></div><a
            id="idm140114205273472"
            class="indexterm"></a><a
            id="idm140114205272512"
            class="indexterm"></a><div
            class="para">
				Los sistemas de archivos son uno de los aspectos más destacados del núcleo. Los sistemas Unix agrupan todos los archivos que almacenan en una jerarquía única, lo que permite a los usuarios (y las aplicaciones) acceder a los datos simplemente conociendo su ubicación dentro de dicha jerarquía.
			</div><div
            class="para">
				El nombre del punto de partida de este árbol jerárquico es la raíz, <code
              class="filename">/</code>. Este directorio puede tener subdirectorios con nombres. Por ejemplo, el nombre del subdirectorio <code
              class="literal">home</code> de <code
              class="filename">/</code> es <code
              class="filename">/home/</code>. Este subdirectorio, a su vez, puede contener otros subdirectorios y así sucesivamente. Cada directorio también puede contener archivos, donde se almacenarán los datos en sí. Por lo tanto, el nombre <code
              class="filename">/home/rmas/Desktop/hello.txt</code> se refiere al archivo <code
              class="literal">hello.txt</code> almacenado en el subdirectorio <code
              class="literal">Desktop</code> del subdirectorio <code
              class="literal">rmas</code> del directorio <code
              class="literal">home</code> presente en la raíz. El núcleo traduce este sistema de nombres en el almacenamiento físico real en un disco.
			</div><div
            class="para">
				Unlike other systems, there is only one such hierarchy, and it can integrate data from several disks. One of these disks is used as the root, and the others are “mounted” on directories in the hierarchy (the Unix command is called <code
              class="command">mount</code>); these other disks are then available under these “mount points”. This allows storing users' home directories (traditionally stored within <code
              class="filename">/home/</code>) on a second hard disk, which will contain the <code
              class="literal">rhertzog</code> and <code
              class="literal">rmas</code> directories. Once the disk is mounted on <code
              class="filename">/home/</code>, these directories become accessible at their usual locations, and paths such as <code
              class="filename">/home/rmas/Desktop/hello.txt</code> keep working.
			</div><a
            id="idm140114205262240"
            class="indexterm"></a><div
            class="para">
				Hay muchos sistemas de archivos que corresponden con muchas formas de almacenar físicamente los datos en discos. Los más conocidos son <span
              class="emphasis"><em>ext2</em></span>, <span
              class="emphasis"><em>ext3</em></span> y <span
              class="emphasis"><em>ext4</em></span>, pero existen otros. Por ejemplo, <span
              class="emphasis"><em>vfat</em></span> es el sistema de archivos utilizado históricamente por los sistemas operativos DOS y Windows, lo que permite utilizar discos duros tanto en Debian como en Windows. En cualquier caso, un sistema de archivos debe ser preparado en un disco antes que pueda ser montado, se conoce esta operación como «dar formato». Los programas como <code
              class="command">mkfs.ext3</code> (donde <code
              class="command">mkfs</code> significa <span
              class="emphasis"><em>crear sistema de archivos</em></span>: «MaKe FileSystem») se encargan de esta operación. Estos programas necesitan, como parámetro, un archivo de dispositivo que representa la partición a la que dar formato (por ejemplo: <code
              class="filename">/dev/sda1</code>). Esta operación es destructiva y sólo debe ejecutarla una vez, excepto cuando uno desee eliminar deliberadamente un sistema de archivos y comenzar nuevamente desde cero.
			</div><div
            class="para">
				Existen tambien sistemas de archivos de red, como <acronym
              class="acronym">NFS</acronym>, en el que los datos no son almacenados en un disco local. En su lugar, se transmiten los datos a través de la red a un servidor que los almacena y obtiene a pedido. La abstracción del sistema de archivos evita que al usuario le importe: los archivos continúan disponibles en la forma jerárquica usual.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.shared-functions"></a>B.4.3. Funciones compartidas</h3></div></div></div><div
            class="para">
				Debido a que una cantidad de funciones son utilizadas por todo software, tiene sentido centralizarlas en el núcleo. Por ejemplo, la gestión compartida de sistemas de archivos permite que cualquier aplicación simplemente abra un archivo, sin preocuparse dónde está almacenado físicamente dicho archivo. Éste puede estar almacenado en diferentes porciones de un disco duro, dividido entre varios discos duros o inclusive almacenado en un servidor remoto. Las funciones de comunicación compartidas son utilizadas por las aplicaciones para intercambiar datos independientemente de la forma en la que se transportan los mismos. Por ejemplo, el transporte puede ser a través de una combinación de redes locales o inalámbricas o a través de una línea telefónica terrestre.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.process-management"></a>B.4.4. Gestión de proceso</h3></div></div></div><a
            id="idm140114205251184"
            class="indexterm"></a><div
            class="para">
				Un proceso es una instancia en ejecución de un programa. Esto necesita memoria para almacenar tanto el programa en sí como los datos con los que trabaja. El núcleo es el encargado de crearlos y seguirlos. Cuando se ejecuta un programa, primero el núcleo reserva memoria, carga en ella el código ejecutable desde el sistema de archivos y luego inicia la ejecución de este código. Mantiene información sobre este proceso, de las que la más visible es un número de identificación conocido como <span
              class="emphasis"><em>pid</em></span> (<span
              class="emphasis"><em>identificador de proceso</em></span>: «process identifier»).
			</div><div
            class="para">
				Unix-like kernels (including Linux), like most other modern operating systems, are capable of “multi-tasking”. In other words, they allow running many processes “at the same time”. There is actually only one running process at any one time, but the kernel cuts time into small slices and runs each process in turn. Since these time slices are very short (in the millisecond range), they create the illusion of processes running in parallel, although they are actually only active during some time intervals and idle the rest of the time. The kernel's job is to adjust its scheduling mechanisms to keep that illusion, while maximizing the global system performance. If the time slices are too long, the application may not appear as responsive as desired. Too short, and the system loses time switching tasks too frequently. These decisions can be tweaked with process priorities. High-priority processes will run for longer and with more frequent time slices than low-priority processes.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>NOTA</em></span> Sistemas multiprocesador (y variaciones)</strong></p></div></div></div><div
              class="para">
				La limitación aquí descripta sólo es un caso extremo. La restricción actual es que, en cada momento, sólo puede existir un proceso en ejecución <span
                class="emphasis"><em>por núcleo de procesador</em></span>. Los sistemas multiprocesador, multinúcleo o con «hyper-threading» («multihilos») permite ejecutar varios procesos en paralelo. Sin embargo, se utiliza el mismo sistema de división de tiempo para administrar casos en los que existan más procesos activos que núcleos de procesador disponibles. Este caso no es extraño: un sistema básico, aún aquellos mayormente desocupados, casi siempre posee decenas de procesos en ejecución.
			</div></div><div
            class="para">
				Por supuesto, el núcleo permite ejecutar varias instancias independientes del mismo programa. Pero cada una de ellas sólo puede acceder sus propias divisiones de tiempo y su propia memoria. Sus datos, por lo tanto, se mantienen independientes.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.permissions"></a>B.4.5. Gestión de permisos</h3></div></div></div><div
            class="para">
				Unix-like systems are also multi-user. They provide a rights management system that supports separate users and groups; it also allows control over actions based on permissions. The kernel manages data for each process, allowing it to control permissions. Most of the time, a process is identified by the user who started it. That process is only permitted to take those actions available to its owner. For instance, trying to open a file requires the kernel to check the process identity against access permissions (for more details on this particular example, see <a
              class="xref"
              href="sect.rights-management.html">Sección 9.3, “Administración de permisos”</a>).
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>Anterior</strong>B.3. Funcionamiento interno de un equipo: las dif...</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Subir</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Inicio</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>Siguiente</strong>B.5. El espacio de usuario</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.kernel-role-and-tasks.html">ar-MA</a></li><li><a
              href="../da-DK/sect.kernel-role-and-tasks.html">da-DK</a></li><li><a
              href="../de-DE/sect.kernel-role-and-tasks.html">de-DE</a></li><li><a
              href="../el-GR/sect.kernel-role-and-tasks.html">el-GR</a></li><li><a
              href="../en-US/sect.kernel-role-and-tasks.html">en-US</a></li><li><a
              href="../es-ES/sect.kernel-role-and-tasks.html">es-ES</a></li><li><a
              href="../fa-IR/sect.kernel-role-and-tasks.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.kernel-role-and-tasks.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.kernel-role-and-tasks.html">hr-HR</a></li><li><a
              href="../id-ID/sect.kernel-role-and-tasks.html">id-ID</a></li><li><a
              href="../it-IT/sect.kernel-role-and-tasks.html">it-IT</a></li><li><a
              href="../ja-JP/sect.kernel-role-and-tasks.html">ja-JP</a></li><li><a
              href="../pl-PL/sect.kernel-role-and-tasks.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.kernel-role-and-tasks.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.kernel-role-and-tasks.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.kernel-role-and-tasks.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.kernel-role-and-tasks.html">tr-TR</a></li><li><a
              href="../zh-CN/sect.kernel-role-and-tasks.html">zh-CN</a></li></ul></div></body></html>
