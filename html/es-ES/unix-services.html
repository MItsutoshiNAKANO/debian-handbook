<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">Capítulo 9. Servicios Unix</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-es-ES-1.0-1" /><meta
        name="keywords"
        content="Arranque del sistema, Scripts de inicio, SSH, Telnet, Derechos, Permisos, Supervisión, Inetd, Cron, Respaldo, Conexión en caliente («hotplug»), PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="El libro del administrador de Debian" /><link
        rel="up"
        href="index.html"
        title="El libro del administrador de Debian" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. Instalación de un núcleo" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. Inicio de sesión remoto" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/es-ES/unix-services.html" /></head><body
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Anterior</strong></a></li><li
          class="home">El libro del administrador de Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Siguiente</strong></a></li></ul><div
        xml:lang="es-ES"
        class="chapter"
        lang="es-ES"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  id="unix-services"></a>Capítulo 9. Servicios Unix</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. Arranque del sistema</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. The systemd init system</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. The System V init system</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. Inicio de sesión remoto</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. Inicio seguro de sesión remota: SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. Utilización de escritorios gráficos remotos</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. Administración de permisos</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. Interfaces de administración</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. Administración en una interfaz web: <code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. Configuración de paquetes: <code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. <code
                    class="command">syslog</code> Eventos de sistema</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. Principio y mecanismo</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. El archivo de configuración</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. El superservidor <code
                    class="command">inetd</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. Programación de tareas con <code
                    class="command">cron</code> y <code
                    class="command">atd</code></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. Formato de un archivo <code
                        class="filename">crontab</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. Utilización del programa <code
                        class="command">at</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. Programación de tareas asincrónicas: <code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. Cuotas</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. Respaldo</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#idm140667123861152">9.10.1. Respaldos con <code
                        class="command">rsync</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#idm140667123822768">9.10.2. Restauración de equipos sin repaldos</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. Conexión en caliente: <span
                    class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm140667123805648">9.11.1. Introducción</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm140667123796912">9.11.2. El problema de nombres</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm140667123783968">9.11.3. Cómo funciona <span
                        class="emphasis"><em>udev</em></span></a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm140667123733232">9.11.4. Un ejemplo concreto</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. Gestión de energía: interfaz avanzada de configuración y energía (ACPI: «Advanced Configuration and Power Interface)</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		Este capítulo cubre un número básico de servicios que son comunes a varios sistemas Unix. Todos los administradores deberían estar familiarizados con ellos.
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    id="sect.system-boot"></a>9.1. Arranque del sistema</h2></div></div></div><a
            id="idm140667139625792"
            class="indexterm"></a><div
            class="para">
			Cuando inicia el equipo, los muchos mensajes que aparecen en la pantalla muestran varias inicializaciones y configuraciones automáticas que se están ejecutando. Algunas veces deseará alterar ligeramente cómo funciona esta etapa, lo que significa que necesitará entenderlas bien. Éste es el propósito de esta sección.
		</div><div
            class="para">
			First, the BIOS takes control of the computer, detects the disks, loads the <span
              class="emphasis"><em>Master Boot Record</em></span>, and executes the bootloader. The bootloader takes over, finds the kernel on the disk, loads and executes it. The kernel is then initialized, and starts to search for and mount the partition containing the root filesystem, and finally executes the first program — <code
              class="command">init</code>. Frequently, this “root partition” and this <code
              class="command">init</code> are, in fact, located in a virtual filesystem that only exists in RAM (hence its name, “initramfs”, formerly called “initrd” for “initialization RAM disk”). This filesystem is loaded in memory by the bootloader, often from a file on a hard drive or from the network. It contains the bare minimum required by the kernel to load the “true” root filesystem: this may be driver modules for the hard drive, or other devices without which the system cannot boot, or, more frequently, initialization scripts and modules for assembling RAID arrays, opening encrypted partitions, activating LVM volumes, etc. Once the root partition is mounted, the initramfs hands over control to the real init, and the machine goes back to the standard boot process.
		</div><div
            class="figure"><a
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="Boot sequence of a computer running Linux with systemd" /></div></div><p
              class="title"><strong>Figura 9.1. Boot sequence of a computer running Linux with systemd</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.systemd"></a>9.1.1. The systemd init system</h3></div></div></div><div
              class="para">
				The “real init” is currently provided by <span
                class="pkg pkg">systemd</span> and this section documents this init system.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CULTURE</em></span> Before <code
                          class="command">systemd</code></strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> is a relatively recent “init system”, and although it was already available, to a certain extent, in <span
                  class="distribution distribution">Wheezy</span>, it has only become the default in Debian <span
                  class="distribution distribution">Jessie</span>. Previous releases relied, by default, on the “System V init” (in the <span
                  class="pkg pkg">sysv-rc</span> package), a much more traditional system. We describe the SysV init later on.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVA</em></span> Otros sistemas de inicio</strong></p></div></div></div><div
                class="para">
				This book describes the boot system used by default in Debian <span
                  class="distribution distribution">Jessie</span> (as implemented by the <span
                  class="pkg pkg">systemd</span> package), as well as the previous default, <span
                  class="pkg pkg">sysvinit</span>, which is derived and inherited from <span
                  class="emphasis"><em>System_V</em></span> Unix systems; there are others.
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> es un sistema de inicio con un proceso muy simple. Mantiene el principio de niveles de ejecución pero reemplaza los directorios y enlaces simbólicos con un archivo de configuración que le indica a <code
                  class="command">init</code> los procesos a iniciar y el orden en el que hacerlo.
			</div><div
                class="para">
				The <code
                  class="command">upstart</code> system is still not perfectly tested on Debian. It is event based: init scripts are no longer executed in a sequential order but in response to events such as the completion of another script upon which they are dependent. This system, started by Ubuntu, is present in Debian <span
                  class="distribution distribution">Jessie</span>, but is not the default; it comes, in fact, as a replacement for <span
                  class="pkg pkg">sysvinit</span>, and one of the tasks launched by <code
                  class="command">upstart</code> is to launch the scripts written for traditional systems, especially those from the <span
                  class="pkg pkg">sysv-rc</span> package.
			</div><div
                class="para">
				También existen otros sistemas y otros modos de operación, como <code
                  class="command">runit</code>, <code
                  class="command">minit</code> o <code
                  class="command">initng</code> pero son relativamente especializados y poco difundidos.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CASO ESPECÍFICO</em></span> Arranque desde la red</strong></p></div></div></div><div
                class="para">
				En algunas situaciones, se puede configurar el BIOS para que no ejecute el MBR sino que busque su equivalente en la red, haciendo posible construir equipos sin disco duro o que son completamente reinstalados en cada arranque. Esta opción no está disponible en todo el hardware y generalmente necesita una combinación apropiada de BIOS y placa de red.
			</div><div
                class="para">
				El arranque desde la red puede utilizarse para ejecutar <code
                  class="command">debian-installer</code> o FAI (revise la <a
                  class="xref"
                  href="installation.html#sect.installation-methods">Sección 4.1, “Métodos de instalación”</a>).
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOLVER A LOS CIMIENTOS</em></span> El proceso, una instancia de un programa</strong></p></div></div></div><a
                id="idm140667128417456"
                class="indexterm"></a><div
                class="para">
				Un proceso es la representación en memoria de un programa en ejecución. Incluye toda la información necesaria para la ejecución apropiada del programa (el código en sí pero también los datos que tiene en memoria, la lista de archivos que ha abierto, las conexiones de red que ha establecido, etc.). Un único programa puede ser instanciado en varios procesos inclusive bajo el mismo ID de usuario.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SEGURIDAD</em></span> Usar una consola como <code
                          class="command">init</code> para obtener derechos de root</strong></p></div></div></div><div
                class="para">
				By convention, the first process that is booted is the <code
                  class="command">init</code> program (which is a symbolic link to <code
                  class="filename">/lib/systemd/systemd</code> by default). However, it is possible to pass an <code
                  class="literal">init</code> option to the kernel indicating a different program.
			</div><a
                id="idm140667128411936"
                class="indexterm"></a><div
                class="para">
				Cualquier persona con acceso al equipo puede presionar el botón <span
                  class="keycap"><strong>Reset</strong></span> y así reiniciarla. Entonces es posible, en el prompt del gestor de arranque, pasar la opción <code
                  class="literal">init=/bin/sh</code> al núcleo para obtener acceso root sin conocer la contraseña del administrador.
			</div><div
                class="para">
				Para prevenirlo puede proteger el gestor de arranque con una contraseña. También podría pensar en proteger el acceso al BIOS (casi siempre tiene disponible un mecanismo de protección por contraseña) sin el cual un intruso malicioso podría iniciar la máquina desde un medio removible que contiene su propio sistema Linux, el cual podría utilizar para tener acceso a los datos del disco duro del equipo.
			</div><div
                class="para">
				Finalmente, tenga en cuenta que la mayoría de los BIOS tiene disponible una contraseña genérica. Inicialmente destinado a resolver los problemas de quienes han olvidado su contraseña, éstas ahora son públicas y están disponibles en Internet (revíselo por su cuenta buscando «contraseñas genéricas de BIOS» en algún motor de búsqueda). Todas estas protecciones impedirán el acceso no autorizado a la máquina sin poder evitarlo por completo. No existe una forma segura de proteger un equipo si el atacante puede acceder a él físicamente; podría quitar el disco duro para conectarlo a un equipo bajo su control de cualquier manera, o aún robar la máquina completa o borrar la memoria del BIOS para eliminar la contraseña…
			</div></div><div
              class="para">
				Systemd executes several processes, in charge of setting up the system: keyboard, drivers, filesystems, network, services. It does this while keeping a global view of the system as a whole, and the requirements of the components. Each component is described by a “unit file” (sometimes more); the general syntax is derived from the widely-used “*.ini files“ syntax, with <code
                class="literal"><em
                  class="replaceable">key</em> = <em
                  class="replaceable">value</em></code> pairs grouped between <code
                class="literal">[<em
                  class="replaceable">section</em>]</code> headers. Unit files are stored under <code
                class="filename">/lib/systemd/system/</code> and <code
                class="filename">/etc/systemd/system/</code>; they come in several flavours, but we'll focus on “services” and “targets” here.
			</div><div
              class="para">
				A systemd “service file” describes a process managed by systemd. It contains roughly the same information as old-style init-scripts, but expressed in a declaratory way (and much more concise) way. Systemd handles the bulk of the repetitive tasks (starting and stopping the process, checking its status, logging, dropping privileges, and so on), and the service file only needs to fill in the specifics of the process. For instance, here's the service file for SSH:
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service
</pre><div
              class="para">
				As you can see, there's very little code in there, only declarations. Systemd takes care of displaying progress reports, keeping track of the processes, and even restarting them when needed.
			</div><div
              class="para">
				A systemd “target file” describes a state of the system, where a set of services are known to be operational. It can be thought of as an equivalent of the old-style runlevel. One of the targets is <code
                class="literal">local-fs.target</code>; when it is reached, the rest of the system can assume that all local filesystems are mounted and accessible. Other targets include <code
                class="literal">network-online.target</code> and <code
                class="literal">sound.target</code>. The dependencies of a target can be listed either within the target file (in the <code
                class="literal">Requires=</code> line), or using a symbolic link to a service file in the <code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">targetname</em>.target.wants/</code> directory. For instance, <code
                class="filename">/etc/systemd/system/printer.target.wants/</code> contains a link to <code
                class="filename">/lib/systemd/system/cups.service</code>; systemd will therefore ensure CUPS is running in order to reach <code
                class="literal">printer.target</code>.
			</div><div
              class="para">
				Since unit files are declarative rather than scripts or programs, they cannot be run directly, and they are only interpreted by systemd; several utilities therefore allow the administrator to interact with systemd and control the state of the system and of each component.
			</div><div
              class="para">
				The first such utility is <code
                class="command">systemctl</code>. When run without any arguments, it lists all the unit files known to systemd (except those that have been disabled), as well as their status. <code
                class="command">systemctl status</code> gives a better view of the services, as well as the related processes. If given the name of a service (as in <code
                class="command">systemctl status ntp.service</code>), it returns even more details, as well as the last few log lines related to the service (more on that later).
			</div><div
              class="para">
				Starting a service by hand is a simple matter of running <code
                class="command">systemctl start <em
                  class="replaceable">servicename</em>.service</code>. As one can guess, stopping the service is done with <code
                class="command">systemctl stop <em
                  class="replaceable">servicename</em>.service</code>; other subcommands include <code
                class="command">reload</code> and <code
                class="command">restart</code>.
			</div><div
              class="para">
				To control whether a service is active (i.e. whether it will get started automatically on boot), use <code
                class="command">systemctl enable <em
                  class="replaceable">servicename</em>.service</code> (or <code
                class="command">disable</code>). <code
                class="command">is-enabled</code> allows checking the status of the service.
			</div><div
              class="para">
				An interesting feature of systemd is that it includes a logging component named <code
                class="command">journald</code>. It comes as a complement to more traditional logging systems such as <code
                class="command">syslogd</code>, but it adds interesting features such as a formal link between a service and the messages it generates, and the ability to capture error messages generated by its initialisation sequence. The messages can be displayed later on, with a little help from the <code
                class="command">journalctl</code> command. Without any arguments, it simply spews all log messages that occurred since system boot; it will rarely be used in such a manner. Most of the time, it will be used with a service identifier:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				Another useful command-line flag is <code
                class="command">-f</code>, which instructs <code
                class="command">journalctl</code> to keep displaying new messages as they are emitted (much in the manner of <code
                class="command">tail -f <em
                  class="replaceable">file</em></code>).
			</div><div
              class="para">
				If a service doesn't seem to be working as expected, the first step to debug the problem are to check that the service is actually running with <code
                class="command">systemctl status</code>; if it is not, and the messages given by the first command are not enough to diagnose the problem, check the logs gathered by journald about that service. For instance, assume the SSH server doesn't work:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				After checking the status of the service (failed), we went on to check the logs; they indicate an error in the configuration file. After editing the configuration file and fixing the error, we restart the service, then verify that it is indeed running.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GOING FURTHER</em></span> Other types of unit files</strong></p></div></div></div><div
                class="para">
				We've only described the most basic of systemd's capabilities in this section. It offers many other interesting features; we'll only list a few here:
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						socket activation: a “socket” unit file can be used to describe a network or Unix socket managed by systemd; this means that the socket will be created by systemd, and the actual service may be started on demand when an actual connection attempt comes. This roughly replicates the feature set of <code
                        class="command">inetd</code>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						timers: a “timer” unit file describes events that occur with a fixed frequency; when a service is linked to such a timer, the corresponding task will be executed whenever the timer fires. In a similar fashion, a “time” unit file describes events that occur on specific times. This allows replicating part of the <code
                        class="command">cron</code> features.
					</div></li><li
                    class="listitem"><div
                      class="para">
						network: a “network“ unit file describes a network interface, which allows configuring such interfaces as well as expressing that a service depends on one particular interface being up.
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.sysvinit"></a>9.1.2. The System V init system</h3></div></div></div><div
              class="para">
				The System V init system (which we'll call init for brevity) executes several processes, following instructions from the <code
                class="filename">/etc/inittab</code> file. The first program that is executed (which corresponds to the <span
                class="emphasis"><em>sysinit</em></span> step) is <code
                class="command">/etc/init.d/rcS</code>, a script that executes all of the programs in the <code
                class="filename">/etc/rcS.d/</code> directory. <a
                id="idm140667128662944"
                class="indexterm"></a> <a
                id="idm140667128662144"
                class="indexterm"></a> <a
                id="idm140667128661344"
                class="indexterm"></a> <a
                id="idm140667128660544"
                class="indexterm"></a>
			</div><div
              class="para">
				Entre estos encontrará sucesivamente programas a cargo de:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						configurar el teclado de la consola;
					</div></li><li
                  class="listitem"><div
                    class="para">
						cargar controladores: el núcleo carga por sí mismo la mayoría de los módulos a medida que el hardware es detectado; los controladores extras se cargan automáticamente cuando los módulos correspondientes son listados en <code
                      class="filename">/etc/modules</code>;
					</div></li><li
                  class="listitem"><div
                    class="para">
						verificar la integridad de los sistemas de archivos;
					</div></li><li
                  class="listitem"><div
                    class="para">
						montar particiones locales;
					</div></li><li
                  class="listitem"><div
                    class="para">
						configurar la red;
					</div></li><li
                  class="listitem"><div
                    class="para">
						montar sistemas de archivos de red (NFS).
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOLVER A LOS CIMIENTOS</em></span> Módulos y opciones del núcleo</strong></p></div></div></div><a
                id="idm140667128651360"
                class="indexterm"></a><div
                class="para">
				Los módulos del núcleo también tienen opciones que puede configurar agregando algunos archivos en <code
                  class="filename">/etc/modprobe.d/</code>. Estas opciones se definen con directivas como: <code
                  class="literal">options <em
                    class="replaceable">nombre-del-módulo</em> <em
                    class="replaceable">nombre-opción</em>=<em
                    class="replaceable">valor-opción</em></code>. Puede especficar varias opciones con una sola directiva si es necesario.
			</div><div
                class="para">
				Estos archivos de configuración están destinados a <code
                  class="command">modprobe</code> — el programa que carga un módulo de núcleo con sus dependencias (los módulos también pueden llamar otros módulos). El paquete <span
                  class="pkg pkg">kmod</span> provee este programa.
			</div><a
                id="idm140667128645408"
                class="indexterm"></a><a
                id="idm140667128644288"
                class="indexterm"></a></div><div
              class="para">
				After this stage, <code
                class="command">init</code> takes over and starts the programs enabled in the default runlevel (which is usually runlevel 2). It executes <code
                class="command">/etc/init.d/rc 2</code>, a script that starts all services which are listed in <code
                class="filename">/etc/rc2.d/</code> and whose names start with the “S” letter. The two-figures number that follows had historically been used to define the order in which services had to be started, but nowadays the default boot system uses <code
                class="command">insserv</code>, which schedules everything automatically based on the scripts' dependencies. Each boot script thus declares the conditions that must be met to start or stop the service (for example, if it must start before or after another service); <code
                class="command">init</code> then launches them in the order that meets these conditions. The static numbering of scripts is therefore no longer taken into consideration (but they must always have a name beginning with “S” followed by two digits and the actual name of the script used for the dependencies). Generally, base services (such as logging with <code
                class="command">rsyslog</code>, or port assignment with <code
                class="command">portmap</code>) are started first, followed by standard services and the graphical interface (<code
                class="command">gdm3</code>).
			</div><div
              class="para">
				Este sistema de inicio basado en dependencias hace posible renumerar automáticamente los scripts, lo que sería tediososo de hacer manualmente y limita el riesgo de error humano ya que se realiza la programación según los parámetros indicados. Otro beneficio es que se pueden iniciar los servicios en paralelo cuando son independientes entre ellos, lo cual puede acelerar el proceso de inicio.
			</div><a
              id="idm140667128636816"
              class="indexterm"></a><a
              id="idm140667128635856"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">init</code> distingue varios niveles de ejecución («runlevel») y puede cambiar de uno a otro ejecutando <code
                class="command">telinit <em
                  class="replaceable">nuevo-nivel</em></code>. Inmediatamente, <code
                class="command">init</code> ejecuta nuevamente <code
                class="command">/etc/init.d/rc</code> con el nuevo nivel de ejecución. Luego, este script ejecutará los servicios faltantes y detendrá aquellos que ya no se desean. Para hacerlo, se refiere al contenido del archivo <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> (donde <em
                class="replaceable">X</em> representa el nuevo nivel de ejecución). Los scripts cuyos nombres comienzan con «S» (por «start», iniciar) son los servicios a iniciar; aquellos cuyos nombres comienzan con «K» (por «kill», matar) son los servicios a detener. El script no inicia ningún servicio que ya haya estado activo en el nivel de ejecución anterior.
			</div><div
              class="para">
				By default, System V init in Debian uses four different runlevels:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						Nivel 0: sólo se lo utiliza temporalmente mientras se apaga el equipo. Como tal, sólo contiene scripts «K».
					</div></li><li
                  class="listitem"><div
                    class="para">
						Nivel 1: también conocido como modo de usuario único, corresponde al sistema en modo degradado; sólo incluye servicios básicos y está destinado a operaciones de mantenimiento donde no se desea la interacción con usuarios normales.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Nivel 2: es el nivel para operaciones normales, lo que incluye servicios de red, una interfaz gráfica, sesiones de usuario, etc.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Nivel 6: similar a nivel 0, excepto a que es utilizada durante la fase de cierre que precede a un reinicio.
					</div></li></ul></div><div
              class="para">
				Existe otros niveles, especialmente del 3 al 5. De forma predeterminara están configurados para operar de la misma forma que el nivel 2, pero el administrador puede modificarlos (agregando o eliminando scripts en los directorios <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> correspondientes) para adaptarlos a necesidades particulares.
			</div><div
              class="figure"><a
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="Boot sequence of a computer running Linux with System V init" /></div></div><p
                class="title"><strong>Figura 9.2. Boot sequence of a computer running Linux with System V init</strong></p></div><a
              id="idm140667128620064"
              class="indexterm"></a><div
              class="para">
				Todos los scripts en los varios directorios <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> son sólo enlaces simbólicos — creados durante la instalación del paquete por el programa <code
                class="command">update-rc.d</code> — que apuntan a los scripts reales que están almacenados en <code
                class="filename">/etc/init.d/</code>. El administrador puede ajustar los servicios disponibles en cada nivel de ejecución ejecutando <code
                class="command">update-rc.d</code> nuevamente con los parámetros correctos. La página de manual <span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(1)</span> describe la sintaxis en detalle. Sepa que eliminar todos los enlaces simbólicos (con el parámetro <code
                class="literal">remove</code>) no es un buen método de desactivar un servicio. En su lugar, simplemente debería configurar para que el mismo no se ejecute en el nivel de ejecución deseado (preservando las llamadas para detenerlo en caso que el servicio esté ejecutando en el nivel de ejecución anterior). Debido a que <code
                class="command">update-rc.d</code> tiene una interfaz bastante compleja, puede preferir utilizar <code
                class="command">rcconf</code> (en el paquete <span
                class="pkg pkg">rcconf</span>) que provee una interfaz mucho más amigable.
			</div><a
              id="idm140667128612768"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>NORMATIVA DEBIAN</em></span> Reinicialización de servicios</strong></p></div></div></div><a
                id="idm140667128610560"
                class="indexterm"></a><a
                id="idm140667128609440"
                class="indexterm"></a><a
                id="idm140667128608000"
                class="indexterm"></a><div
                class="para">
				Los scripts de mantenimiento para paquetes Debian a veces reinician algunos servicios para asegurar su disponibilidad o conseguir que tengan en cuenta algunas opciones. El script que controla un servicio — <code
                  class="command">/etc/init.d/<em
                    class="replaceable">servicio</em> <em
                    class="replaceable">operación</em></code> — no tiene en cuenta el nivel de ejecución, asume (incorrectamente) que el servicio está siendo utilizado actualmente y, por lo tanto, puede iniciar operaciones incorrectas (iniciar un servicio que fue detenido deliberadamente o detener un servicio que no está ejecutando, etc.). Por lo tanto, Debian introdujo el programa <code
                  class="command">invoke-rc.d</code>: los scripts de mantenimiento deben utilizar este programa para ejecutar scripts de inicialización de servicios que sólo ejecutarán las órdenes necesarias. Sepa que, contrario al uso común, aquí se utiliza el sufijo <code
                  class="filename">.d</code> en el nombre de un programa y no en un directorio.
			</div></div><div
              class="para">
				Finalmente, <code
                class="command">init</code> inicia los programas de control para varias consolas virtuales (<code
                class="command">getty</code>). Muestra un prompt esperando por un nombre de usuario y luego ejecuta <code
                class="command">login <em
                  class="replaceable">usuario</em></code> para iniciar una sesión.
			</div><a
              id="idm140667128601280"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOCABULARIO</em></span> Consola y terminal</strong></p></div></div></div><div
                class="para">
				Los primeros equipos generalmente estaban separados en varias partes muy grandes: el compartimiento de almacenamiento y la unidad de procesamiento central estaban separados de los dispositivos periféricos que los operadores utilizaban para controlarlos. Éstos eran parte de un mobiliario separado: la «consola». Se mantuvo este término pero cambió su significado. Se convirtió, de cierta forma, en sinónimo de «terminal» (un teclado y una pantalla).
			</div><div
                class="para">
				Con el desarrollo de la tecnología, los sistemas operativos han ofrecido varias consolas virtuales que permiten varias sesiones independientes al mismo tiempo, aún si sólo hay un teclado y pantalla. La mayoría de los sistemas GNU/Linux ofrecen seis consolas virtuales (en modo texto) a las que puede acceder presionando las combinaciones de teclas <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> a <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span>.
			</div><div
                class="para">
				Por extensión, los términos «consola» y «terminal» también pueden hacer referencia a emuladores de terminales en una sesión gráfica X11 (como <code
                  class="command">xterm</code>, <code
                  class="command">gnome-terminal</code> o <code
                  class="command">konsole</code>).
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Anterior</strong>8.11. Instalación de un núcleo</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Subir</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Inicio</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Siguiente</strong>9.2. Inicio de sesión remoto</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/unix-services.html">ar-MA</a></li><li><a
              href="../da-DK/unix-services.html">da-DK</a></li><li><a
              href="../de-DE/unix-services.html">de-DE</a></li><li><a
              href="../el-GR/unix-services.html">el-GR</a></li><li><a
              href="../en-US/unix-services.html">en-US</a></li><li><a
              href="../es-ES/unix-services.html">es-ES</a></li><li><a
              href="../fa-IR/unix-services.html">fa-IR</a></li><li><a
              href="../fr-FR/unix-services.html">fr-FR</a></li><li><a
              href="../hr-HR/unix-services.html">hr-HR</a></li><li><a
              href="../id-ID/unix-services.html">id-ID</a></li><li><a
              href="../it-IT/unix-services.html">it-IT</a></li><li><a
              href="../ja-JP/unix-services.html">ja-JP</a></li><li><a
              href="../pl-PL/unix-services.html">pl-PL</a></li><li><a
              href="../pt-BR/unix-services.html">pt-BR</a></li><li><a
              href="../ro-RO/unix-services.html">ro-RO</a></li><li><a
              href="../ru-RU/unix-services.html">ru-RU</a></li><li><a
              href="../tr-TR/unix-services.html">tr-TR</a></li><li><a
              href="../zh-CN/unix-services.html">zh-CN</a></li></ul></div></body></html>
