<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">Capitolo 9. Servizi Unix</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.1" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-it-IT-1.0-1" /><meta
        name="keywords"
        content="Avvio del sistema, Initscripts, SSH, Telnet, Diritti, Permessi, Supervisione, Inetd, Cron, Backup, Hotplug, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Il manuale dell'amministratore Debian" /><link
        rel="up"
        href="index.html"
        title="Il manuale dell'amministratore Debian" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. Installare un kernel" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. Accesso remoto" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/it-IT/unix-services.html" /></head><body
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Indietro</strong></a></li><li
          class="home">Il manuale dell'amministratore Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Avanti</strong></a></li></ul><div
        xml:lang="it-IT"
        class="chapter"
        lang="it-IT"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  id="unix-services"></a>Capitolo 9. Servizi Unix</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. Avvio del sistema</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. The systemd init system</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. The System V init system</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. Accesso remoto</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. Accesso remoto sicuro: SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. Utilizzo di desktop remoti grafici</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. Gestione dei permessi</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. Interfacce di amministrazione</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. Amministrare tramite un'interfaccia Web: <code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. Configurazione dei pacchetti: <code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. <code
                    class="command">syslog</code>, eventi di sistema</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. Principi e meccanismi</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. Il file di configurazione</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. Il super-server <code
                    class="command">inetd</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. Pianificare attività con <code
                    class="command">cron</code> e <code
                    class="command">atd</code></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. Formato del file <code
                        class="filename">crontab</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. Utilizzo del comando <code
                        class="command">at</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. Pianificazione di attività asincrone: <code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. Quote</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. Backup</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#idm140687195312064">9.10.1. Backup con <code
                        class="command">rsync</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#idm140687195273712">9.10.2. ﻿Ripristino di macchine senza backup</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. Collegamento a caldo: <span
                    class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm140687195256576">9.11.1. Premessa</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm140687195247920">9.11.2. Il problema dei nomi</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm140687195234896">9.11.3. Come funziona <span
                        class="emphasis"><em>udev</em></span></a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm140687195184336">9.11.4. Un esempio concreto</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. Gestione dell'energia: Advanced Configuration and Power Interface (ACPI)</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		Questo capitolo comprende una serie di servizi di base che sono comuni a molti sistemi Unix. Tutti gli amministratori dovrebbero conoscerli bene.
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    id="sect.system-boot"></a>9.1. Avvio del sistema</h2></div></div></div><a
            id="idm140687200867968"
            class="indexterm"></a><div
            class="para">
			Quando si avvia il computer, i molti messaggi che scorrono sulla console visualizzano molte inizializzazioni e configurazioni automatiche che vengono eseguite. Può capitare di voler modificare un po' come funziona questa fase, il che significa che è necessario conoscerla bene. Questo è lo scopo di questa sezione.
		</div><div
            class="para">
			First, the BIOS takes control of the computer, detects the disks, loads the <span
              class="emphasis"><em>Master Boot Record</em></span>, and executes the bootloader. The bootloader takes over, finds the kernel on the disk, loads and executes it. The kernel is then initialized, and starts to search for and mount the partition containing the root filesystem, and finally executes the first program — <code
              class="command">init</code>. Frequently, this “root partition” and this <code
              class="command">init</code> are, in fact, located in a virtual filesystem that only exists in RAM (hence its name, “initramfs”, formerly called “initrd” for “initialization RAM disk”). This filesystem is loaded in memory by the bootloader, often from a file on a hard drive or from the network. It contains the bare minimum required by the kernel to load the “true” root filesystem: this may be driver modules for the hard drive, or other devices without which the system cannot boot, or, more frequently, initialization scripts and modules for assembling RAID arrays, opening encrypted partitions, activating LVM volumes, etc. Once the root partition is mounted, the initramfs hands over control to the real init, and the machine goes back to the standard boot process.
		</div><div
            class="figure"><a
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="Boot sequence of a computer running Linux with systemd" /></div></div><p
              class="title"><strong>Figura 9.1. Boot sequence of a computer running Linux with systemd</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.systemd"></a>9.1.1. The systemd init system</h3></div></div></div><div
              class="para">
				The “real init” is currently provided by <span
                class="pkg pkg">systemd</span> and this section documents this init system.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CULTURE</em></span> Before <code
                          class="command">systemd</code></strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> is a relatively recent “init system”, and although it was already available, to a certain extent, in <span
                  class="distribution distribution">Wheezy</span>, it has only become the default in Debian <span
                  class="distribution distribution">Jessie</span>. Previous releases relied, by default, on the “System V init” (in the <span
                  class="pkg pkg">sysv-rc</span> package), a much more traditional system. We describe the SysV init later on.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVA</em></span> Altri sistemi di avvio</strong></p></div></div></div><div
                class="para">
				This book describes the boot system used by default in Debian <span
                  class="distribution distribution">Jessie</span> (as implemented by the <span
                  class="pkg pkg">systemd</span> package), as well as the previous default, <span
                  class="pkg pkg">sysvinit</span>, which is derived and inherited from <span
                  class="emphasis"><em>System_V</em></span> Unix systems; there are others.
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> è un sistema di avvio con un procedimento molto semplice. Mantiene il principio dei runlevel, ma sostituisce le directory e i collegamenti simbolici con un file di configurazione, che indica a <code
                  class="command">init</code> i processi che devono essere avviati e il loro ordine di lancio.
			</div><div
                class="para">
				The <code
                  class="command">upstart</code> system is still not perfectly tested on Debian. It is event based: init scripts are no longer executed in a sequential order but in response to events such as the completion of another script upon which they are dependent. This system, started by Ubuntu, is present in Debian <span
                  class="distribution distribution">Jessie</span>, but is not the default; it comes, in fact, as a replacement for <span
                  class="pkg pkg">sysvinit</span>, and one of the tasks launched by <code
                  class="command">upstart</code> is to launch the scripts written for traditional systems, especially those from the <span
                  class="pkg pkg">sysv-rc</span> package.
			</div><div
                class="para">
				Esistono anche altri sistemi e modalità operative, quali <code
                  class="command">runit</code>, <code
                  class="command">minit</code> o <code
                  class="command">initng</code>, ma sono relativamente specializzati e non largamente diffusi.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CASO SPECIFICO</em></span> Avvio da rete</strong></p></div></div></div><div
                class="para">
				In alcune configurazioni, il BIOS può essere configurato per non eseguire l'MBR, ma per cercare il suo equivalente in rete, rendendo possibile la costruzione di computer senza un disco rigido, o che sono completamente reinstallati ad ogni avvio. Questa opzione non è disponibile su tutto l'hardware e richiede in genere una combinazione appropriata di BIOS e scheda di rete.
			</div><div
                class="para">
				L'avvio da rete può essere utilizzato per lanciare il <code
                  class="command">debian-installer</code> o FAI (vedere la <a
                  class="xref"
                  href="installation.html#sect.installation-methods">Sezione 4.1, «Modalità di installazione»</a> ).
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>FONDAMENTALI</em></span> Il processo, un'istanza di programma</strong></p></div></div></div><a
                id="idm140687200183248"
                class="indexterm"></a><div
                class="para">
				Un processo è la rappresentazione in memoria di un programma in esecuzione. Esso comprende tutte le informazioni necessarie per la corretta esecuzione del software (il codice stesso, ma anche i dati che ha in memoria, l'elenco di file che ha aperto, le connessioni di rete che ha stabilito, ecc.). Un programma unico può essere istanziato in vari processi diversi, non necessariamente in esecuzione con diversi ID utente.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SICUREZZA</em></span> Usare una shell come <code
                          class="command">init</code> per ottenere i privilegi di root</strong></p></div></div></div><div
                class="para">
				By convention, the first process that is booted is the <code
                  class="command">init</code> program (which is a symbolic link to <code
                  class="filename">/lib/systemd/systemd</code> by default). However, it is possible to pass an <code
                  class="literal">init</code> option to the kernel indicating a different program.
			</div><a
                id="idm140687200177712"
                class="indexterm"></a><div
                class="para">
				Chiunque è in grado di accedere al computer può premere il pulsante <span
                  class="keycap"><strong>Reset</strong></span> e quindi riavviare. Poi, al prompt del bootloader, è possibile passare l'opzione <code
                  class="literal">init=/bin/sh</code> per il kernel per ottenere l'accesso come root senza conoscere la password dell'amministratore.
			</div><div
                class="para">
				Per evitare ciò, è possibile proteggere lo stesso bootloader con una password. Si potrebbe anche pensare di proteggere l'accesso al BIOS (un meccanismo di protezione con password è quasi sempre disponibile), senza di ciò un intruso malintenzionato potrebbe ancora avviare la macchina su un supporto rimovibile contenente il proprio sistema Linux, che potrebbe utilizzare per accedere ai dati sull'hard disk del computer.
			</div><div
                class="para">
				Infine, fare attenzione al fatto che la maggior parte dei BIOS dispone di una password generica. Inizialmente destinate alla risoluzione di problemi per coloro che hanno dimenticato la password, queste password sono ora pubbliche e disponibili su Internet (provare a cercare «password generica per BIOS» in un motore di ricerca). Tutte queste protezioni ostacoleranno quindi l'accesso non autorizzato alla macchina senza essere in grado di evitarlo completamente. Non c'è modo affidabile per proteggere un computer se l'utente malintenzionato può accedervi fisicamente; in ogni caso potrebbe smontare gli hard disk per connetterli a un computer sotto il proprio controllo, o addirittura rubare l'intera macchina, o cancellare la memoria del BIOS per ripristinarne la password…
			</div></div><div
              class="para">
				Systemd executes several processes, in charge of setting up the system: keyboard, drivers, filesystems, network, services. It does this while keeping a global view of the system as a whole, and the requirements of the components. Each component is described by a “unit file” (sometimes more); the general syntax is derived from the widely-used “*.ini files“ syntax, with <code
                class="literal"><em
                  class="replaceable">key</em> = <em
                  class="replaceable">value</em></code> pairs grouped between <code
                class="literal">[<em
                  class="replaceable">section</em>]</code> headers. Unit files are stored under <code
                class="filename">/lib/systemd/system/</code> and <code
                class="filename">/etc/systemd/system/</code>; they come in several flavours, but we'll focus on “services” and “targets” here.
			</div><div
              class="para">
				A systemd “service file” describes a process managed by systemd. It contains roughly the same information as old-style init-scripts, but expressed in a declaratory way (and much more concise) way. Systemd handles the bulk of the repetitive tasks (starting and stopping the process, checking its status, logging, dropping privileges, and so on), and the service file only needs to fill in the specifics of the process. For instance, here's the service file for SSH:
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service
</pre><div
              class="para">
				As you can see, there's very little code in there, only declarations. Systemd takes care of displaying progress reports, keeping track of the processes, and even restarting them when needed.
			</div><div
              class="para">
				A systemd “target file” describes a state of the system, where a set of services are known to be operational. It can be thought of as an equivalent of the old-style runlevel. One of the targets is <code
                class="literal">local-fs.target</code>; when it is reached, the rest of the system can assume that all local filesystems are mounted and accessible. Other targets include <code
                class="literal">network-online.target</code> and <code
                class="literal">sound.target</code>. The dependencies of a target can be listed either within the target file (in the <code
                class="literal">Requires=</code> line), or using a symbolic link to a service file in the <code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">targetname</em>.target.wants/</code> directory. For instance, <code
                class="filename">/etc/systemd/system/printer.target.wants/</code> contains a link to <code
                class="filename">/lib/systemd/system/cups.service</code>; systemd will therefore ensure CUPS is running in order to reach <code
                class="literal">printer.target</code>.
			</div><div
              class="para">
				Since unit files are declarative rather than scripts or programs, they cannot be run directly, and they are only interpreted by systemd; several utilities therefore allow the administrator to interact with systemd and control the state of the system and of each component.
			</div><div
              class="para">
				The first such utility is <code
                class="command">systemctl</code>. When run without any arguments, it lists all the unit files known to systemd (except those that have been disabled), as well as their status. <code
                class="command">systemctl status</code> gives a better view of the services, as well as the related processes. If given the name of a service (as in <code
                class="command">systemctl status ntp.service</code>), it returns even more details, as well as the last few log lines related to the service (more on that later).
			</div><div
              class="para">
				Starting a service by hand is a simple matter of running <code
                class="command">systemctl start <em
                  class="replaceable">servicename</em>.service</code>. As one can guess, stopping the service is done with <code
                class="command">systemctl stop <em
                  class="replaceable">servicename</em>.service</code>; other subcommands include <code
                class="command">reload</code> and <code
                class="command">restart</code>.
			</div><div
              class="para">
				To control whether a service is active (i.e. whether it will get started automatically on boot), use <code
                class="command">systemctl enable <em
                  class="replaceable">servicename</em>.service</code> (or <code
                class="command">disable</code>). <code
                class="command">is-enabled</code> allows checking the status of the service.
			</div><div
              class="para">
				An interesting feature of systemd is that it includes a logging component named <code
                class="command">journald</code>. It comes as a complement to more traditional logging systems such as <code
                class="command">syslogd</code>, but it adds interesting features such as a formal link between a service and the messages it generates, and the ability to capture error messages generated by its initialisation sequence. The messages can be displayed later on, with a little help from the <code
                class="command">journalctl</code> command. Without any arguments, it simply spews all log messages that occurred since system boot; it will rarely be used in such a manner. Most of the time, it will be used with a service identifier:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				Another useful command-line flag is <code
                class="command">-f</code>, which instructs <code
                class="command">journalctl</code> to keep displaying new messages as they are emitted (much in the manner of <code
                class="command">tail -f <em
                  class="replaceable">file</em></code>).
			</div><div
              class="para">
				If a service doesn't seem to be working as expected, the first step to debug the problem are to check that the service is actually running with <code
                class="command">systemctl status</code>; if it is not, and the messages given by the first command are not enough to diagnose the problem, check the logs gathered by journald about that service. For instance, assume the SSH server doesn't work:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				After checking the status of the service (failed), we went on to check the logs; they indicate an error in the configuration file. After editing the configuration file and fixing the error, we restart the service, then verify that it is indeed running.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GOING FURTHER</em></span> Other types of unit files</strong></p></div></div></div><div
                class="para">
				We've only described the most basic of systemd's capabilities in this section. It offers many other interesting features; we'll only list a few here:
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						socket activation: a “socket” unit file can be used to describe a network or Unix socket managed by systemd; this means that the socket will be created by systemd, and the actual service may be started on demand when an actual connection attempt comes. This roughly replicates the feature set of <code
                        class="command">inetd</code>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						timers: a “timer” unit file describes events that occur with a fixed frequency; when a service is linked to such a timer, the corresponding task will be executed whenever the timer fires. In a similar fashion, a “time” unit file describes events that occur on specific times. This allows replicating part of the <code
                        class="command">cron</code> features.
					</div></li><li
                    class="listitem"><div
                      class="para">
						network: a “network“ unit file describes a network interface, which allows configuring such interfaces as well as expressing that a service depends on one particular interface being up.
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.sysvinit"></a>9.1.2. The System V init system</h3></div></div></div><div
              class="para">
				The System V init system (which we'll call init for brevity) executes several processes, following instructions from the <code
                class="filename">/etc/inittab</code> file. The first program that is executed (which corresponds to the <span
                class="emphasis"><em>sysinit</em></span> step) is <code
                class="command">/etc/init.d/rcS</code>, a script that executes all of the programs in the <code
                class="filename">/etc/rcS.d/</code> directory. <a
                id="idm140687199359600"
                class="indexterm"></a> <a
                id="idm140687199358800"
                class="indexterm"></a> <a
                id="idm140687199358000"
                class="indexterm"></a> <a
                id="idm140687199357200"
                class="indexterm"></a>
			</div><div
              class="para">
				Tra questi, si trovano successivamente i programmi incaricati di:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						configurare la tastiera della console;
					</div></li><li
                  class="listitem"><div
                    class="para">
						caricare i driver: la maggior parte dei moduli del kernel vengono caricati dal kernel stesso, al rilevamento dell'hardware, altri driver aggiuntivi vengono caricati in seguito automaticamente se i moduli corrispondenti sono elencati nel file <code
                      class="filename">/etc/modules</code>;
					</div></li><li
                  class="listitem"><div
                    class="para">
						verificare l'integrità dei file system;
					</div></li><li
                  class="listitem"><div
                    class="para">
						montare partizioni locali;
					</div></li><li
                  class="listitem"><div
                    class="para">
						configurare la rete;
					</div></li><li
                  class="listitem"><div
                    class="para">
						montare file system di rete (NFS).
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>FONDAMENTALI</em></span> I moduli del kernel e le opzioni</strong></p></div></div></div><a
                id="idm140687199347904"
                class="indexterm"></a><div
                class="para">
				I moduli del kernel hanno anche opzioni che possono essere configurate mettendo alcuni file in <code
                  class="filename">/etc/modprobe.d/</code>. Queste opzioni sono definite con direttive come questa: <code
                  class="literal">options <em
                    class="replaceable">nome-modulo</em> <em
                    class="replaceable">nome-opzione</em>=<em
                    class="replaceable">valore-opzione</em></code>. Diverse opzioni possono essere specificate con un'unica direttiva, se necessario.
			</div><div
                class="para">
				Questi file di configurazione sono destinati a <code
                  class="command">modprobe</code>: il programma che carica un modulo del kernel con le sue dipendenze (i moduli possono infatti chiamare altri moduli). Questo programma è fornito dal pacchetto <span
                  class="pkg pkg">kmod</span>.
			</div><a
                id="idm140687199342016"
                class="indexterm"></a><a
                id="idm140687199340896"
                class="indexterm"></a></div><div
              class="para">
				After this stage, <code
                class="command">init</code> takes over and starts the programs enabled in the default runlevel (which is usually runlevel 2). It executes <code
                class="command">/etc/init.d/rc 2</code>, a script that starts all services which are listed in <code
                class="filename">/etc/rc2.d/</code> and whose names start with the “S” letter. The two-figures number that follows had historically been used to define the order in which services had to be started, but nowadays the default boot system uses <code
                class="command">insserv</code>, which schedules everything automatically based on the scripts' dependencies. Each boot script thus declares the conditions that must be met to start or stop the service (for example, if it must start before or after another service); <code
                class="command">init</code> then launches them in the order that meets these conditions. The static numbering of scripts is therefore no longer taken into consideration (but they must always have a name beginning with “S” followed by two digits and the actual name of the script used for the dependencies). Generally, base services (such as logging with <code
                class="command">rsyslog</code>, or port assignment with <code
                class="command">portmap</code>) are started first, followed by standard services and the graphical interface (<code
                class="command">gdm3</code>).
			</div><div
              class="para">
				Questo sistema di avvio basato su dipendenze consente di automatizzare la rinumerazione, che potrebbe risultare piuttosto noiosa se dovesse essere effettuata manualmente, e limita i rischi di errore umano, poiché la pianificazione viene effettuata secondo i parametri indicati. Un altro vantaggio è che i servizi possono essere avviati in parallelo quando sono indipendenti l'uno dall'altro, e quindi è possibile accelerare il processo di avvio.
			</div><a
              id="idm140687199333360"
              class="indexterm"></a><a
              id="idm140687199332400"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">init</code> distingue tra diversi runlevel, in modo da poter passare da uno all'altro con il comando <code
                class="command">telinit <em
                  class="replaceable">nuovo-livello</em></code>. Immediatamente, <code
                class="command">init</code> esegue ancora una volta <code
                class="command">/etc/init.d/rc</code> con il nuovo runlevel. Questo script quindi avvia i servizi mancanti e ferma quelli che non sono più desiderati. Per fare ciò, fa riferimento al contenuto di <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> (dove <em
                class="replaceable">X</em> rappresenta il nuovo runlevel). Gli script che iniziano con «S» (come in «Start») sono i servizi da avviare, quelli che iniziano con «K» (come in «Kill») sono i servizi che devono essere arrestati. Lo script non avvia alcun servizio che era già attivo nel runlevel precedente.
			</div><div
              class="para">
				By default, System V init in Debian uses four different runlevels:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						Il livello 0 è utilizzato solo temporaneamente, mentre il computer si sta spegnendo. Come tale, esso contiene solo molti script «K».
					</div></li><li
                  class="listitem"><div
                    class="para">
						Il livello 1, noto anche come modalità utente singolo, corrisponde al sistema in modalità degradata; include solo i servizi basilari, ed è destinato ad operazioni di manutenzione in cui le interazioni con gli utenti ordinari non sono desiderate.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Il livello 2 è il livello per il normale funzionamento, che include servizi di rete, un'interfaccia utente grafica, accesso utenti, ecc.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Il livello 6 è simile al livello 0, tranne che è utilizzato durante la fase di arresto che precede un riavvio.
					</div></li></ul></div><div
              class="para">
				Esistono altri livelli, in particolare da 3 a 5. In modo predefinito sono configurati per operare allo stesso modo del livello 2, ma l'amministratore può modificarli (aggiungendo o eliminando script nella corrispondente directory <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code>) per adattarli a particolari esigenze.
			</div><div
              class="figure"><a
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="Boot sequence of a computer running Linux with System V init" /></div></div><p
                class="title"><strong>Figura 9.2. Boot sequence of a computer running Linux with System V init</strong></p></div><a
              id="idm140687199316736"
              class="indexterm"></a><div
              class="para">
				Tutti gli script contenuti nelle varie directory <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> sono solo collegamenti simbolici, creati con l'installazione del pacchetto per il programma <code
                class="command">update-rc.d</code>, che puntano agli script reali che vengono memorizzati in <code
                class="filename">/etc/init.d/</code>. L'amministratore può regolare i servizi disponibili in ogni runlevel attraverso il comando <code
                class="command">update-rc.d</code> con i parametri corretti. La pagina di manuale di <span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(1)</span> descrive la sintassi in dettaglio. Notare che la rimozione di tutti i collegamenti simbolici (con il parametro <code
                class="literal">remove</code>) non è un buon metodo per disabilitare un servizio. Si dovrebbe invece semplicemente configurare quel servizio per non essere lanciato in quel particolare runlevel (pur conservando le chiamate corrispondenti a fermarlo nel caso in cui il servizio viene eseguito nel runlevel precedente). Dal momento che <code
                class="command">update-rc.d</code> ha un'interfaccia un po' complicata, può essere preferibile usare <code
                class="command">rcconf</code> (presente nel pacchetto <span
                class="pkg pkg">rcconf</span>) che fornisce un'interfaccia più intuitiva.
			</div><a
              id="idm140687199309408"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DEBIAN POLICY</em></span> Riavvio dei servizi</strong></p></div></div></div><a
                id="idm140687199307168"
                class="indexterm"></a><a
                id="idm140687199306048"
                class="indexterm"></a><a
                id="idm140687199304608"
                class="indexterm"></a><div
                class="para">
				Gli script dei manutentori dei pacchetti Debian, a volte, riavvieranno alcuni servizi per garantire la loro disponibilità o per tenere conto di alcune opzioni. Il comando che controlla un servizio, <code
                  class="command">/etc/init.d/<em
                    class="replaceable">servizio</em> <em
                    class="replaceable">operazione</em></code>, non tiene in considerazione i runlevel, presume (erroneamente) che il servizio sia attualmente in uso, e può quindi iniziare delle operazioni errate (avviare un servizio che è stato deliberatamente fermato, o interrompere un servizio che è già stato arrestato, ecc.). Debian ha pertanto introdotto il programma <code
                  class="command">invoke-rc.d</code>: questo programma deve essere utilizzato dagli script del manutentore per eseguire gli script di inizializzazione dei servizi ed eseguirà solo i comandi necessari. Si noti che, contrariamente all'uso comune, il suffisso <code
                  class="filename">.d</code> è qui usato nel nome di un programma, e non in una directory.
			</div></div><div
              class="para">
				Infine, <code
                class="command">init</code> avvia i programmi di controllo per le varie console virtuali (<code
                class="command">getty</code>). Visualizza un prompt, in attesa di un nome utente, poi esegue <code
                class="command">login <em
                  class="replaceable">utente</em></code> per iniziare una sessione.
			</div><a
              id="idm140687199297712"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOCABOLARIO</em></span> Console e terminale</strong></p></div></div></div><div
                class="para">
				I primi computer erano generalmente divisi in diversi componenti molto grandi: il contenitore di memorizzazione e l'unità di elaborazione centrale erano separati dai dispositivi periferici utilizzati dagli operatori per controllarli. Questi facevano parte di un mobile separato, la «console». Questo termine è stato mantenuto, ma il suo significato è cambiato. È diventato più o meno sinonimo di «terminale», essendo una tastiera e uno schermo.
			</div><div
                class="para">
				Con lo sviluppo dei computer, i sistemi operativi hanno offerto diverse console virtuali per consentire diverse sessioni indipendenti contemporaneamente, anche se vi è solo una tastiera e uno schermo. La maggior parte dei sistemi GNU/Linux offrono sei console virtuali (in modalità testo), accessibili digitando le combinazioni di tasti da <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> a <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span> .
			</div><div
                class="para">
				Per estensione i termini «console» e «terminale» possono anche riferirsi ad un emulatore di terminale in una sessione grafica X11 (come <code
                  class="command">xterm</code>, <code
                  class="command">gnome-terminal</code> o <code
                  class="command">konsole</code> ).
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Indietro</strong>8.11. Installare un kernel</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Risali</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Partenza</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Avanti</strong>9.2. Accesso remoto</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/unix-services.html">ar-MA</a></li><li><a
              href="../da-DK/unix-services.html">da-DK</a></li><li><a
              href="../de-DE/unix-services.html">de-DE</a></li><li><a
              href="../el-GR/unix-services.html">el-GR</a></li><li><a
              href="../en-US/unix-services.html">en-US</a></li><li><a
              href="../es-ES/unix-services.html">es-ES</a></li><li><a
              href="../fa-IR/unix-services.html">fa-IR</a></li><li><a
              href="../fr-FR/unix-services.html">fr-FR</a></li><li><a
              href="../hr-HR/unix-services.html">hr-HR</a></li><li><a
              href="../id-ID/unix-services.html">id-ID</a></li><li><a
              href="../it-IT/unix-services.html">it-IT</a></li><li><a
              href="../ja-JP/unix-services.html">ja-JP</a></li><li><a
              href="../pl-PL/unix-services.html">pl-PL</a></li><li><a
              href="../pt-BR/unix-services.html">pt-BR</a></li><li><a
              href="../ro-RO/unix-services.html">ro-RO</a></li><li><a
              href="../ru-RU/unix-services.html">ru-RU</a></li><li><a
              href="../tr-TR/unix-services.html">tr-TR</a></li><li><a
              href="../zh-CN/unix-services.html">zh-CN</a></li></ul></div></body></html>
