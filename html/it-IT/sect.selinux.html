<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">14.5. Introduzione a SELinux</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-it-IT-1.0-1" /><meta
        name="keywords"
        content="Firewall, Netfilter, IDS/NIDS" /><link
        rel="home"
        href="index.html"
        title="Il manuale dell'amministratore Debian" /><link
        rel="up"
        href="security.html"
        title="Capitolo 14. Sicurezza" /><link
        rel="prev"
        href="sect.apparmor.html"
        title="14.4. Introduction to AppArmor" /><link
        rel="next"
        href="sect.other-security-considerations.html"
        title="14.6. Altre considerazioni relative alla sicurezza" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/it-IT/sect.selinux.html" /></head><body
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.apparmor.html"><strong>Indietro</strong></a></li><li
          class="home">Il manuale dell'amministratore Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.other-security-considerations.html"><strong>Avanti</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.selinux"></a>14.5. Introduzione a SELinux</h2></div></div></div><a
          id="idm140109899428640"
          class="indexterm"></a><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.selinux-principles"></a>14.5.1. Princìpi</h3></div></div></div><div
            class="para">
				SELinux (<span
              class="emphasis"><em>Security Enhanced Linux</em></span>) è un sistema di <span
              class="emphasis"><em>controllo degli accessi obbligatorio</em></span> costruito sull'interfaccia LSM (<span
              class="emphasis"><em>Linux Security Modules</em></span>) di Linux. In pratica, il kernel interroga SELinux prima di ogni chiamata di sistema per sapere se il processo è autorizzato ad eseguire una data operazione.
			</div><div
            class="para">
				SELinux sfrutta una serie di regole, note comunemente come <span
              class="emphasis"><em>politiche (policy)</em></span>, per autorizzare o vietare operazioni. Queste regole sono difficili da creare. Fortunatamente vengono fornite due politiche standard (<span
              class="emphasis"><em>targeted</em></span> e <span
              class="emphasis"><em>strict</em></span>) per evitare il grosso del lavoro di configurazione.
			</div><div
            class="para">
				Con SELinux, la gestione dei diritti è completamente diversa dai sistemi Unix tradizionali. I diritti di un processo dipendono dal proprio <span
              class="emphasis"><em>contesto di sicurezza</em></span>. Il contesto è definito dall'<span
              class="emphasis"><em>identità</em></span> dell'utente che ha avviato il processo, il <span
              class="emphasis"><em>ruolo</em></span> e il <span
              class="emphasis"><em>dominio</em></span> che l'utente presentava in quel momento. I diritti in realtà dipendono dal dominio, ma le transizioni attraverso i domini sono controllate dai ruoli. Infine, le possibili transizioni tra i ruoli dipendono dall'identità.
			</div><div
            class="figure"><a
              id="idm140109899419712"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/selinux-context.png"
                  alt="Contesti di sicurezza e utenti Unix" /></div></div><p
              class="title"><strong>Figura 14.3. Contesti di sicurezza e utenti Unix</strong></p></div><div
            class="para">
				In pratica, durante l'accesso, all'utente viene assegnato un contesto di sicurezza predefinito (a seconda dei ruoli che è abilitato ad assumere). Questo definisce il dominio corrente, e di conseguenza il dominio che tutti i suoi processi figli acquisiranno. Se si vuole variare il ruolo corrente e il dominio associato, si deve eseguire <code
              class="command">newrole -r <em
                class="replaceable">ruolo_r</em> -t <em
                class="replaceable">dominio_t</em></code> (di solito esiste un solo dominio permesso per un dato ruolo, per cui il parametro <code
              class="literal">-t</code> si può tralasciare). Questo comando permette l'autenticazione su inserimento della propria password. Questa caratteristica impedisce ai programmi di muoversi automaticamente tra i ruoli. Tali cambiamenti possono avvenire solo se esplicitamente ammessi nella politica di SELinux.
			</div><div
            class="para">
				Obviously the rights do not apply to all <span
              class="emphasis"><em>objects</em></span> (files, directories, sockets, devices, etc.). They can vary from object to object. To achieve this, each object is associated to a <span
              class="emphasis"><em>type</em></span> (this is known as labeling). Domains' rights are thus expressed with sets of (dis)allowed operations on those types (and, indirectly, on all objects which are labeled with the given type).
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>EXTRA</em></span> Domini e tipi sono equivalenti</strong></p></div></div></div><div
              class="para">
				Internally, a domain is just a type, but a type that only applies to processes. That's why domains are suffixed with <code
                class="literal">_t</code> just like objects' types.
			</div></div><div
            class="para">
				By default, a program inherits its domain from the user who started it, but the standard SELinux policies expect many important programs to run in dedicated domains. To achieve this, those executables are labeled with a dedicated type (for example <code
              class="command">ssh</code> is labeled with <code
              class="literal">ssh_exec_t</code>, and when the program starts, it automatically switches to the <code
              class="literal">ssh_t</code> domain). This automatic domain transition mechanism makes it possible to grant only the rights required by each program. It is a fundamental principle of SELinux.
			</div><div
            class="figure"><a
              id="idm140109899407184"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/selinux-transitions.png"
                  alt="Transizioni automatiche attraverso domini" /></div></div><p
              class="title"><strong>Figura 14.4. Transizioni automatiche attraverso domini</strong></p></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>IN PRATICA</em></span> Recuperare il contesto di sicurezza</strong></p></div></div></div><a
              id="idm140109899402704"
              class="indexterm"></a><a
              id="idm140109899401744"
              class="indexterm"></a><a
              id="idm140109899400816"
              class="indexterm"></a><div
              class="para">
				Per recuperare il contesto di sicurezza di un dato processo, si usa l'opzione <code
                class="literal">Z</code> di <code
                class="command">ps</code>.
			</div><pre
              class="screen"><code
                class="computeroutput">$ </code><strong
                class="userinput"><code>ps axZ | grep vstfpd</code></strong>
<code
                class="computeroutput">system_u:system_r:ftpd_t:s0   2094 ?    Ss  0:00 /usr/sbin/vsftpd</code></pre><div
              class="para">
				Il primo campo riporta identità, ruolo, dominio e livello MCS, separati da due punti. Il livello MCS (<span
                class="emphasis"><em>Multi-Category Security</em></span>) è un parametro che interviene nella configurazione della politica di protezione della riservatezza, che regola l'accesso ai file basato sulla relativa sensibilità. Questa caratteristica non verrà trattata in questo libro.
			</div><div
              class="para">
				Per recuperare il contesto di sicurezza corrente in un terminale, eseguire <code
                class="command">id -Z</code>.
			</div><pre
              class="screen"><code
                class="computeroutput">$ </code><strong
                class="userinput"><code>id -Z</code></strong>
<code
                class="computeroutput">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</code></pre><div
              class="para">
				Infine, per recuperare il tipo assegnato ad un file, usare <code
                class="command">ls -Z</code>.
			</div><pre
              class="screen"><code
                class="computeroutput">$ </code><strong
                class="userinput"><code>ls -Z test /usr/bin/ssh</code></strong>
<code
                class="computeroutput">unconfined_u:object_r:user_home_t:s0 test
     system_u:object_r:ssh_exec_t:s0 /usr/bin/ssh</code></pre><div
              class="para">
				Vale la pena notare che identità e ruolo assegnati a un file non hanno alcuna particolare importanza (non vengono mai utilizzati), ma per ragioni di uniformità, ad ogni oggetto viene assegnato un contesto di sicurezza completo.
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.selinux-setup"></a>14.5.2. Impostare SELinux</h3></div></div></div><div
            class="para">
				Il supporto di SELinux è incluso nei kernel standard forniti da Debian. Gli strumenti di base in Unix supportano SELinux senza alcuna modifica. Abilitare SELinux quindi è relativamente semplice.
			</div><div
            class="para">
				The <code
              class="command">apt install selinux-basics selinux-policy-default</code> command will automatically install the packages required to configure an SELinux system.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CAUTION</em></span> Reference policy not in jessie</strong></p></div></div></div><div
              class="para">
				Unfortunately the maintainers of the <span
                class="pkg pkg">refpolicy</span> source package did not handle release critical bugs on their package and the package got removed from jessie. This means that the <span
                class="pkg pkg">selinux-policy-*</span> packages are currently not installable in jessie and needs to be fetched from another place. Hopefully they will come back in one of the point releases or in jessie-backports. In the mean time, you can grab them from unstable.
			</div><div
              class="para">
				This sad situation at least proves that SELinux is not very popular in the set of users/developers who are running the development versions of Debian. Thus, if you opt to use SELinux, you should expect the default policy to not work perfectly and you will have to invest quite some time to make it suitable to your specific needs.
			</div></div><div
            class="para">
				The <span
              class="pkg pkg">selinux-policy-default</span> package contains a set of standard rules. By default, this policy only restricts access for a few widely exposed services. The user sessions are not restricted and it is thus unlikely that SELinux would block legitimate user operations. However, this does enhance the security of system services running on the machine. To setup a policy equivalent to the old “strict” rules, you just have to disable the <code
              class="literal">unconfined</code> module (modules management is detailed further in this section).
			</div><div
            class="para">
				Una volta che la politica è stata installata, bisogna etichettare tutti i file presenti (il che significa assegnare loro un tipo). Questa operazione dev'essere intrapresa manualmente con <code
              class="command">fixfiles relabel</code>.
			</div><div
            class="para">
				The SELinux system is now ready. To enable it, you should add the <code
              class="literal">selinux=1 security=selinux</code> parameter to the Linux kernel. The <code
              class="literal">audit=1</code> parameter enables SELinux logging which records all the denied operations. Finally, the <code
              class="literal">enforcing=1</code> parameter brings the rules into application: without it SELinux works in its default <span
              class="emphasis"><em>permissive</em></span> mode where denied actions are logged but still executed. You should thus modify the GRUB bootloader configuration file to append the desired parameters. One easy way to do this is to modify the <code
              class="literal">GRUB_CMDLINE_LINUX</code> variable in <code
              class="filename">/etc/default/grub</code> and to run <code
              class="command">update-grub</code>. SELinux will be active after a reboot.
			</div><div
            class="para">
				Vale la pena notare che lo script <code
              class="command">selinux-activate</code> automatizza queste operazioni e forza l'etichettatura all'avvio successivo (che evita la creazione di nuovi file non etichettati mentre SELinux non è ancora attivo e mentre l'etichettatura è in corso).
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.selinux-management"></a>14.5.3. Gestire un sistema SELinux</h3></div></div></div><a
            id="idm140109899372336"
            class="indexterm"></a><a
            id="idm140109899371216"
            class="indexterm"></a><div
            class="para">
				La politica di SELinux corrisponde ad un insieme modulare di regole, e la loro installazione rileva e abilita i moduli in base ai servizi già presenti. Il sistema è così immediatamente operativo. Comunque, quando un servizio viene installato dopo l'applicazione della politica di SELinux, deve essere possibile abilitare manualmente il modulo corrispondente. Questo è lo scopo del comando <code
              class="command">semodule</code>. Inoltre, dev'essere possibile definire i ruoli che ogni utente può assumere, che può essere fatto con il comando <code
              class="command">semanage</code>.
			</div><div
            class="para">
				Questi due comandi quindi vengono usati per apportare modifiche all'attuale configurazione di SELinux, che è memorizzata in <code
              class="filename">/etc/selinux/default/</code>. Diversamente da altri file di configurazione che si trovano in <code
              class="filename">/etc/</code>, tutti questi file non devono essere modificati manualmente. Si devono utilizzare i programmi dedicati a questo scopo.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>APPROFONDIMENTI</em></span> Documentazione ulteriore</strong></p></div></div></div><div
              class="para">
				Dal momento che NSA non fornisce alcuna documentazione ufficiale, la comunità per compensare ha istituito un wiki. Sono state raccolte un sacco di informazioni, ma bisogna fare attenzione che la maggior parte dei collaboratori sono utenti Fedora (dove SELinux è abilitato in modo predefinito). La documentazione pertanto tende ad essere specifica per questa distribuzione. <div
                class="url">→ <a
                  href="http://www.selinuxproject.org">http://www.selinuxproject.org</a></div>
			</div><div
              class="para">
				Bisogna dare anche uno sguardo alla pagina dedicata del wiki Debian e al blog di Russell Coker, che è uno dei più attivi sviluppatori Debian che si dedica al supporto SELinux. <div
                class="url">→ <a
                  href="http://wiki.debian.org/SELinux">http://wiki.debian.org/SELinux</a></div> <div
                class="url">→ <a
                  href="http://etbe.coker.com.au/tag/selinux/">http://etbe.coker.com.au/tag/selinux/</a></div>
			</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="idm140109899361040"></a>14.5.3.1. Gestione dei moduli SELinux</h4></div></div></div><div
              class="para">
					Available SELinux modules are stored in the <code
                class="filename">/usr/share/selinux/default/</code> directory. To enable one of these modules in the current configuration, you should use <code
                class="command">semodule -i <em
                  class="replaceable">module.pp.bz2</em></code>. The <span
                class="emphasis"><em>pp.bz2</em></span> extension stands for <span
                class="emphasis"><em>policy package</em></span> (compressed with bzip2).
				</div><div
              class="para">
					Removing a module from the current configuration is done with <code
                class="command">semodule -r <em
                  class="replaceable">module</em></code>. Finally, the <code
                class="command">semodule -l</code> command lists the modules which are currently installed. It also outputs their version numbers. Modules can be selectively enabled with <code
                class="command">semodule -e</code> and disabled with <code
                class="command">semodule -d</code>.
				</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -i /usr/share/selinux/default/abrt.pp.bz2</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -l</code></strong>
<code
                class="computeroutput">abrt    1.5.0   Disabled
accountsd       1.1.0   
acct    1.6.0   
[...]</code>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -e abrt</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -d accountsd</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -l</code></strong>
<code
                class="computeroutput">abrt    1.5.0
accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</code>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -r abrt</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -l</code></strong>
<code
                class="computeroutput">accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</code></pre><div
              class="para">
					<code
                class="command">semodule</code> carica immediatamente la nuova configurazione tranne nel caso si usi la sua opzione <code
                class="literal">-n</code>. Vale la pena notare che per impostazione predefinita il programma agisce sulla configurazione corrente (riportata nella variabile <code
                class="literal">SELINUXTYPE</code> in <code
                class="filename">/etc/selinux/config</code>), ma si può anche modificarne un'altra specificandola con l'opzione <code
                class="literal">-s</code>.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="idm140109899344352"></a>14.5.3.2. Gestione delle identità</h4></div></div></div><div
              class="para">
					Ogni volta che un utente effettua l'accesso, assume una determinata identità SELinux. Questa identità definisce i ruoli che egli può assumere. Queste due corrispondenze (utente-identità e identità-ruoli) sono configurabili con il comando <code
                class="command">semanage</code>.
				</div><div
              class="para">
					Bisogna assolutamente leggere la pagina di manuale <span
                class="citerefentry"><span
                  class="refentrytitle">semanage</span>(8)</span>, anche se la sintassi del comando sembra essere simile per tutti i concetti che vengono gestiti. Si troveranno opzioni comuni a tutti i sotto-comandi: <code
                class="literal">-a</code> per aggiungere, <code
                class="literal">-d</code> per eliminare, <code
                class="literal">-m</code> per modificare, <code
                class="literal">-l</code> per elencare, e <code
                class="literal">-t</code> per indicare un tipo (o un dominio).
				</div><div
              class="para">
					<code
                class="command">semanage login -l</code> elenca la corrispondenza in uso degli identificatori degli utenti con le identità SELinux. Gli utenti che non hanno un riferimento esplicito acquisiscono l'identità riportata nella voce <code
                class="literal">__default__</code>. Il comando <code
                class="command">semanage login -a -s user_u <em
                  class="replaceable">utente</em></code> associa l'identità <span
                class="emphasis"><em>user_u</em></span> al dato utente. Infine, <code
                class="command">semanage login -d <em
                  class="replaceable">utente</em></code> rimuove la voce corrispondente assegnata all'utente.
				</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>semanage login -a -s user_u rhertzog</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semanage login -l</code></strong>
<code
                class="computeroutput">
Login Name           SELinux User         MLS/MCS Range        Service

__default__          unconfined_u         SystemLow-SystemHigh *
rhertzog             user_u               SystemLow            *
root                 unconfined_u         SystemLow-SystemHigh *
system_u             system_u             SystemLow-SystemHigh *
# </code><strong
                class="userinput"><code>semanage login -d rhertzog</code></strong></pre><div
              class="para">
					<code
                class="command">semanage user -l</code> elenca la corrispondenza delle identità degli utenti in SELinux con i ruoli assegnati. L'aggiunta di una nuova identità richiede la definizione sia dei ruoli corrispondenti, sia un prefisso di etichetta utilizzato per assegnare un tipo ai file personali (<code
                class="filename">/home/<em
                  class="replaceable">utente</em>/*</code>). Il prefisso «<code
                class="literal">staff</code>» ha come risultato file di tipo «<code
                class="literal">staff_home_dir_t</code>». Per creare una nuova identità per l'utente in SELinux basta lanciare <code
                class="command">semanage user -a -R <em
                  class="replaceable">ruoli</em> -P <em
                  class="replaceable">prefisso</em> <em
                  class="replaceable">identità</em></code>. Infine, con <code
                class="command">semanage user -d <em
                  class="replaceable">identità</em></code> si rimuove una di tali identità.
				</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>semanage user -a -R 'staff_r user_r' -P staff test_u</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semanage user -l</code></strong>
<code
                class="computeroutput">
                Labeling   MLS/       MLS/                          
SELinux User    Prefix     MCS Level  MCS Range             SELinux Roles

root            sysadm     SystemLow  SystemLow-SystemHigh  staff_r sysadm_r system_r
staff_u         staff      SystemLow  SystemLow-SystemHigh  staff_r sysadm_r
sysadm_u        sysadm     SystemLow  SystemLow-SystemHigh  sysadm_r
system_u        user       SystemLow  SystemLow-SystemHigh  system_r
test_u          staff      SystemLow  SystemLow             staff_r user_r
unconfined_u    unconfined SystemLow  SystemLow-SystemHigh  system_r unconfined_r
user_u          user       SystemLow  SystemLow             user_r
# </code><strong
                class="userinput"><code>semanage user -d test_u</code></strong></pre></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="idm140109899322800"></a>14.5.3.3. Gestire i contesti dei file, le porte e i booleani</h4></div></div></div><div
              class="para">
					Ogni modulo SELinux fornisce un insieme di regole per l'etichettatura dei file, ma è anche possibile aggiungerne di personalizzate per far fronte a casi specifici. Per esempio, se si vuole che il server web possa leggere i file dentro la gerarchia <code
                class="filename">/srv/www/</code>, si deve lanciare <code
                class="command">semanage fcontext -a -t httpd_sys_content_t "/srv/www(/.*)?"</code> seguito da <code
                class="command">restorecon -R /srv/www/</code>. Il primo comando registra le nuove regole sull'etichettatura e il secondo reimposta i tipi di file in base alle regole di etichettatura correnti.
				</div><div
              class="para">
					Similarly, TCP/UDP ports are labeled in a way that ensures that only the corresponding daemons can listen to them. For instance, if you want the web server to be able to listen on port 8080, you should run <code
                class="command">semanage port -m -t http_port_t -p tcp 8080</code>.
				</div><div
              class="para">
					Alcuni moduli SELinux esportano opzioni booleane che si possono personalizzare per variare il comportamento delle regole predefinite. L'utilità <code
                class="command">getsebool</code> viene usata per ispezionare tali opzioni (<code
                class="command">getsebool <em
                  class="replaceable">booleano</em></code> mostra un'opzione, e <code
                class="command">getsebool -a</code> le mostra tutte). Il comando <code
                class="command">setsebool <em
                  class="replaceable">booleano</em> <em
                  class="replaceable">valore</em></code> modifica il valore corrente di un'opzione booleana. L'opzione <code
                class="literal">-P</code> rende permanente la modifica, cioè il nuovo valore diventa il predefinito e questo rimarrà tale nei successivi riavvii. L'esempio sotto concede ai web server l'accesso alle directory home (utile quando gli utenti hanno siti web personali in <code
                class="filename">~/public_html/</code>).
				</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>getsebool httpd_enable_homedirs</code></strong>
<code
                class="computeroutput">httpd_enable_homedirs --&gt; off
# </code><strong
                class="userinput"><code>setsebool -P httpd_enable_homedirs on</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>getsebool httpd_enable_homedirs</code></strong> 
<code
                class="computeroutput">httpd_enable_homedirs --&gt; on</code></pre></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.selinux-custom-rules"></a>14.5.4. Adattare le regole</h3></div></div></div><div
            class="para">
				Dato che la politica di SELinux è modulare, potrebbe essere interessante sviluppare nuovi moduli per le applicazioni (eventualmente personalizzate) che ne sono prive. Questi nuovi moduli quindi completerebbero la <span
              class="emphasis"><em>politica di riferimento</em></span>.
			</div><div
            class="para">
				Per creare nuovi moduli, è richiesto il pacchetto <span
              class="pkg pkg">selinux-policy-dev</span> oltre a <span
              class="pkg pkg">selinux-policy-doc</span>. Quest'ultimo contiene la documentazione delle regole standard (<code
              class="filename">/usr/share/doc/selinux-policy-doc/html/</code>) e file di esempio che possono essere usati come modelli per creare nuovi moduli. Installiamo questi file ed esaminiamoli più da vicino:
			</div><pre
            class="screen"><code
              class="computeroutput">$ </code><strong
              class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/Makefile.example Makefile</code></strong>
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/example.fc ./</code></strong>
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/example.if ./</code></strong>
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/example.te ./</code></strong></pre><div
            class="para">
				The <code
              class="filename">.te</code> file is the most important one. It defines the rules. The <code
              class="filename">.fc</code> file defines the “file contexts”, that is the types assigned to files related to this module. The data within the <code
              class="filename">.fc</code> file are used during the file labeling step. Finally, the <code
              class="filename">.if</code> file defines the interface of the module: it is a set of “public functions” that other modules can use to properly interact with the module that you're creating.
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="idm140109877267744"></a>14.5.4.1. Scrivere un file <code
                      class="filename">.fc</code></h4></div></div></div><div
              class="para">
					Analizzare l'esempio sotto dovrebbe essere sufficiente per capire la struttura di un file di questo tipo. Si possono usare espressioni regolari per assegnare lo stesso contesto di sicurezza a file multipli, oppure anche a un intero albero di directory.
				</div><div
              class="example"><a
                id="idm140109877266192"></a><p
                class="title"><strong>Esempio 14.2. File <code
                    class="filename">example.fc</code></strong></p><div
                class="example-contents"><pre
                  class="programlisting scale"># l'eseguibile miaapp avrà:
# label: system_u:object_r:miaapp_exec_t
# sensibilità MLS: s0
# categorie MCS : &lt;nessuna&gt;

/usr/sbin/miaapp         --      gen_context(system_u:object_r:miaapp_exec_t,s0)
</pre></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="idm140109877264192"></a>14.5.4.2. Scrivere un file <code
                      class="filename">.if</code></h4></div></div></div><div
              class="para">
					Nell'esempio sotto, la prima interfaccia («<code
                class="literal">miaapp_domtrans</code>») controlla chi può eseguire l'applicazione. La seconda («<code
                class="literal">miaapp_lettura_log</code>») concede i diritti di lettura sui file di log dell'applicazione.
				</div><div
              class="para">
					Ogni interfaccia deve generare un insieme valido di regole che può essere incluso in un file <code
                class="filename">.te</code>. Si deve perciò dichiarare tutti i tipi che si usano (con la macro <code
                class="literal">gen_require</code>), e usare direttive standard per concedere i diritti. Da notare, comunque, che si possono utilizzare le interfacce fornite dagli altri moduli. Nella prossima sezione si approfondirà maggiormente come esprimere questi diritti.
				</div><div
              class="example"><a
                id="idm140109877260624"></a><p
                class="title"><strong>Esempio 14.3. File <code
                    class="filename">example.if</code></strong></p><div
                class="example-contents"><pre
                  class="programlisting">## &lt;summary&gt;Miaapp policy di esempio&lt;/summary&gt;
## &lt;desc&gt;
##      &lt;p&gt;
##              Testo maggiormente descrittivo su miaapp.  Nel tag &lt;desc&gt;
##              si possono usare anche i tag html &lt;p&gt;, &lt;ul&gt;, e &lt;ol&gt;
##              per la formattazione.
##      &lt;/p&gt;
##      &lt;p&gt;
##              Questa politica fornisce le seguenti caratteristiche di miaapp:
##              &lt;ul&gt;
##              &lt;li&gt;Caratteristica A&lt;/li&gt;
##              &lt;li&gt;Caratteristica B&lt;/li&gt;
##              &lt;li&gt;Caratteristica C&lt;/li&gt;
##              &lt;/ul&gt;
##      &lt;/p&gt;
## &lt;/desc&gt;
#

########################################
## &lt;summary&gt;
##      Esegue una trasizione di dominio per lanciare miaapp.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Dominio con permesso di transizione.
## &lt;/param&gt;
#
interface(`miaapp_domtrans',`
        gen_require(`
                type miaapp_t, miaapp_exec_t;
        ')

        domtrans_pattern($1,miaapp_exec_t,miaapp_t)
')

########################################
## &lt;summary&gt;
##      Legge i file di log di miaapp.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domini con permessi di lettura dei file di log.
## &lt;/param&gt;
#
interface(`miaapp_lettura_log',`
        gen_require(`
                type miaapp_log_t;
        ')

        logging_search_logs($1)
        allow $1 myapp_log_t:file r_file_perms;
')
</pre></div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DOCUMENTAZIONE</em></span> Spiegazioni in merito alla <span
                          class="emphasis"><em>politica di riferimento</em></span></strong></p></div></div></div><div
                class="para">
					The <span
                  class="emphasis"><em>reference policy</em></span> evolves like any free software project: based on volunteer contributions. The project is hosted by Tresys, one of the most active companies in the SELinux field. Their wiki contains explanations on how the rules are structured and how you can create new ones. <div
                  class="url">→ <a
                    href="https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted">https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted</a></div>
				</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="idm140109877254704"></a>14.5.4.3. Scrivere un file <code
                      class="filename">.te</code></h4></div></div></div><div
              class="para">
					Osservare il file <code
                class="filename">example.te</code>:
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>APPROFONDIMENTI</em></span> Il linguaggio macro <code
                          class="command">m4</code></strong></p></div></div></div><div
                class="para">
					Per strutturare in modo appropriato la politica, gli sviluppatori di SELinux utilizzano un processore di comandi macro. Invece di duplicare molte direttive <span
                  class="emphasis"><em>allow</em></span> simili, creano «funzioni macro» per sfruttare una logica a più alto livello, che si traduce anche in una politica maggiormente comprensibile.
				</div><div
                class="para">
					In pratica, per compilare queste regole viene usato <code
                  class="command">m4</code>. Con esso si esegue l'operazione opposta: si espandono tutte le direttive ad alto livello in un enorme database di direttive <span
                  class="emphasis"><em>allow</em></span>.
				</div><div
                class="para">
					Le «interfacce» di SELinux sono semplicemente funzioni macro che vengono sostituite da un insieme di regole al momento della loro compilazione. Allo stesso modo, alcuni diritti sono in realtà gruppi di diritti che vengono sostituiti dai loro valori in fase di compilazione.
				</div></div><pre
              class="programlisting">policy_module(miaapp,1.0.0) <span
                id="example.te.module"><img
                  class="callout"
                  src="Common_Content/images/1.png"
                  alt="1" /></span>

########################################
#
# Dichiarazioni
#

type miaapp_t; <span
                id="example.te.type"><img
                  class="callout"
                  src="Common_Content/images/2.png"
                  alt="2" /></span>
type miaapp_exec_t;
domain_type(miaapp_t)
domain_entry_file(miaapp_t, miaapp_exec_t) <span
                id="example.te.domain"><img
                  class="callout"
                  src="Common_Content/images/3.png"
                  alt="3" /></span>

type miaapp_log_t;
logging_log_file(miaapp_log_t) <span
                id="example.te.interface"><img
                  class="callout"
                  src="Common_Content/images/4.png"
                  alt="4" /></span>

type miaapp_tmp_t;
files_tmp_file(miaapp_tmp_t)

########################################
#
# Policy locale di miaapp
#

allow miaapp_t miaapp_log_t:file { read_file_perms append_file_perms }; <span
                id="example.te.allow"><img
                  class="callout"
                  src="Common_Content/images/5.png"
                  alt="5" /></span>

allow miaapp_t miaapp_tmp_t:file manage_file_perms;
files_tmp_filetrans(miaapp_t,miaapp_tmp_t,file)
</pre><div
              class="calloutlist"><table
                border="0"
                summary="Callout list"><tr><td
                    width="5%"
                    valign="top"
                    align="left"><p><a
                        href="#example.te.module"><img
                          class="callout"
                          src="Common_Content/images/1.png"
                          alt="1" /></a> </p></td><td
                    valign="top"
                    align="left"><div
                      class="para">
							Il modulo dev'essere identificato da nome e numero di versione. Questa direttiva è obbligatoria.
						</div></td></tr><tr><td
                    width="5%"
                    valign="top"
                    align="left"><p><a
                        href="#example.te.type"><img
                          class="callout"
                          src="Common_Content/images/2.png"
                          alt="2" /></a> </p></td><td
                    valign="top"
                    align="left"><div
                      class="para">
							Se il modulo introduce nuovi tipi, deve dichiararli con direttive come questa. Non bisogna esitare a creare tanti tipi quanti necessari piuttosto che concedere troppi inutili diritti.
						</div></td></tr><tr><td
                    width="5%"
                    valign="top"
                    align="left"><p><a
                        href="#example.te.domain"><img
                          class="callout"
                          src="Common_Content/images/3.png"
                          alt="3" /></a> </p></td><td
                    valign="top"
                    align="left"><div
                      class="para">
							Queste interfacce definiscono il tipo <code
                        class="literal">miaapp_t</code> come un dominio di processo che deve essere usato da ogni eseguibile etichettato con <code
                        class="literal">miaapp_exec_t</code>. Implicitamente, ciò aggiunge l'attributo <code
                        class="literal">exec_type</code> a tutti questi soggetti, che a loro volta permettono ad altri moduli di concedere i diritti di esecuzione su questi programmi: per esempio, il modulo <code
                        class="literal">userdomain</code> concede ai processi con dominio <code
                        class="literal">user_t</code>, <code
                        class="literal">staff_t</code> e <code
                        class="literal">sysadm_t</code> di eseguirli. I domini di altre applicazioni circoscritte non avranno i diritti di eseguirli, finché le regole non concedono loro diritti simili (è questo il caso, per esempio, di <code
                        class="command">dpkg</code> con il relativo dominio <code
                        class="literal">dpkg_t</code>).
						</div></td></tr><tr><td
                    width="5%"
                    valign="top"
                    align="left"><p><a
                        href="#example.te.interface"><img
                          class="callout"
                          src="Common_Content/images/4.png"
                          alt="4" /></a> </p></td><td
                    valign="top"
                    align="left"><div
                      class="para">
							<code
                        class="literal">logging_log_file</code> è un'interfaccia fornita dalla politica di riferimento. Essa indica che i file etichettati con quel dato tipo sono file di log che possono beneficiare delle regole associate (per esempio concedendo i diritti a <code
                        class="command">logrotate</code> in modo che possa manipolarli).
						</div></td></tr><tr><td
                    width="5%"
                    valign="top"
                    align="left"><p><a
                        href="#example.te.allow"><img
                          class="callout"
                          src="Common_Content/images/5.png"
                          alt="5" /></a> </p></td><td
                    valign="top"
                    align="left"><div
                      class="para">
							La direttiva <code
                        class="literal">allow</code> è la direttiva base per autorizzare un'operazione. Il primo parametro è il dominio del processo a cui è concessa l'esecuzione dell'operazione. Il secondo definisce l'oggetto che un processo del primo dominio può manipolare. Questo parametro si definisce come «<em
                        class="replaceable">tipo</em>:<em
                        class="replaceable">classe</em>» dove <em
                        class="replaceable">tipo</em> è il proprio tipo SELinux e <em
                        class="replaceable">classe</em> descrive la natura dell'oggetto (file, directory, socket, fifo, ecc.). Infine, l'ultimo parametro descrive i permessi (le operazioni consentite).
						</div><div
                      class="para">
							Permissions are defined as the set of allowed operations and follow this template: <code
                        class="literal">{ <em
                          class="replaceable">operation1</em> <em
                          class="replaceable">operation2</em> }</code>. However, you can also use macros representing the most useful permissions. The <code
                        class="filename">/usr/share/selinux/devel/include/support/obj_perm_sets.spt</code> lists them.
						</div><div
                      class="para">
							La seguente pagina web fornisce una lista relativamente esaustiva delle classi di soggetti, e i permessi che possono essere consentiti. <div
                        class="url">→ <a
                          href="http://www.selinuxproject.org/page/ObjectClassesPerms">http://www.selinuxproject.org/page/ObjectClassesPerms</a></div>
						</div></td></tr></table></div><div
              class="para">
					Ora si deve trovare l'insieme minimo di regole necessarie per assicurare che l'applicazione o il servizio in questione funzioni correttamente. Per ottenere ciò, bisogna avere una buona conoscenza di come funziona l'applicazione e di che genere di dati vengono gestiti e/o prodotti.
				</div><div
              class="para">
					È comunque possibile un approccio empirico. Una volta che i soggetti rilevanti sono stati correttamente etichettati, si può usare l'applicazione in modalità permissiva: che verrebbero bloccate vengono registrate ma vengono comunque eseguite. Analizzando i log, si possono identificare le operazioni da consentire. Questo è un esempio di una di queste voci di log:
				</div><pre
              class="programlisting">avc:  denied  { read write } for  pid=1876 comm="syslogd" name="xconsole" dev=tmpfs ino=5510 scontext=system_u:system_r:syslogd_t:s0 tcontext=system_u:object_r:device_t:s0 tclass=fifo_file permissive=1
</pre><div
              class="para">
					Per comprendere meglio questo messaggio, studiamolo pezzo per pezzo.
				</div><div
              class="table"><a
                id="idm140109877226768"></a><p
                class="title"><strong>Tabella 14.1. Analisi di un tracciamento di SELinux</strong></p><div
                class="table-contents"><table
                  xmlns:d="http://docbook.org/ns/docbook"
                  class="lt-4-cols gt-7-rows"
                  summary="Analisi di un tracciamento di SELinux"><colgroup><col /><col /></colgroup><thead><tr><th>Messaggio</th><th>Descrizione</th></tr></thead><tbody><tr><td><code
                          class="computeroutput">avc: denied</code></td><td>Un'operazione è stata negata.</td></tr><tr><td><code
                          class="computeroutput">{ read write }</code></td><td>Questa operazione ha richiesto i permessi di <code
                          class="literal">lettura</code> e <code
                          class="literal">scrittura</code>.</td></tr><tr><td><code
                          class="computeroutput">pid=1876</code></td><td>Il processo con PID 1876 ha eseguito l'operazione (o ha tentato di eseguirla).</td></tr><tr><td><code
                          class="computeroutput">comm="syslogd"</code></td><td>Il processo era un'istanza del programma <code
                          class="literal">syslogd</code>.</td></tr><tr><td><code
                          class="computeroutput">name="xconsole"</code></td><td>The target object was named <code
                          class="literal">xconsole</code>. Sometimes you can also have a “path” variable — with the full path — instead.</td></tr><tr><td><code
                          class="computeroutput">dev=tmpfs</code></td><td>The device hosting the target object is a <code
                          class="literal">tmpfs</code> (an in-memory filesystem). For a real disk, you could see the partition hosting the object (for example: “sda3”).</td></tr><tr><td><code
                          class="computeroutput">ino=5510</code></td><td>L'oggetto è identificato dall'inode numero 5510.</td></tr><tr><td><code
                          class="computeroutput">scontext=system_u:system_r:syslogd_t:s0</code></td><td>Questo è il contesto di sicurezza del processo che ha eseguito l'operazione.</td></tr><tr><td><code
                          class="computeroutput">tcontext=system_u:object_r:device_t:s0</code></td><td>Questo è il contesto di sicurezza dell'oggetto di destinazione.</td></tr><tr><td><code
                          class="computeroutput">tclass=fifo_file</code></td><td>L'oggetto di destinazione è un file FIFO.</td></tr></tbody></table></div></div><div
              class="para">
					Dall'osservazione di questa voce di log, è possibilie costruire una regola che può permettere questa operazione. Per esempio: <code
                class="literal">allow syslogd_t device_t:fifo_file { read write }</code>. Questo processo può essere automatizzato, ed è esattamente ciò che offre il comando <code
                class="command">audit2allow</code> (del pacchetto <span
                class="pkg pkg">policycoreutils</span>). Questo approccio è utile solo se i vari soggetti sono già etichettati correttamente secondo ciò che dev'essere ristretto. In ogni caso, bisognerà rivedere attentamente le regole generate e validarle a seconda della propria conoscenza dell'applicazione. In effetti, questo approccio tende a concedere più diritti di quelli realmente necessari. La soluzione corretta è spesso quella di creare nuovi tipi e di concedere i diritti solo a quei tipi. Può anche accadere che negare un'operazione non sia fatale per l'applicazione, nel qual caso sarebbe meglio aggiungere una regola «<code
                class="literal">dontaudit</code>» per evitare la voce di log nonostante l'effettivo diniego.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>COMPLEMENTI</em></span> Nessun ruolo nelle regole della politica</strong></p></div></div></div><a
                id="idm140109877204192"
                class="indexterm"></a><a
                id="idm140109877203424"
                class="indexterm"></a><div
                class="para">
					It might seem weird that roles do not appear at all when creating new rules. SELinux uses only the domains to find out which operations are allowed. The role intervenes only indirectly by allowing the user to switch to another domain. SELinux is based on a theory known as <span
                  class="emphasis"><em>Type Enforcement</em></span> and the type is the only element that matters when granting rights.
				</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="idm140109877201248"></a>14.5.4.4. Compilare i file</h4></div></div></div><div
              class="para">
					Once the 3 files (<code
                class="filename">example.if</code>, <code
                class="filename">example.fc</code>, and <code
                class="filename">example.te</code>) match your expectations for the new rules, just run <code
                class="command">make NAME=devel</code> to generate a module in the <code
                class="filename">example.pp</code> file (you can immediately load it with <code
                class="command">semodule -i example.pp</code>). If several modules are defined, <code
                class="command">make</code> will create all the corresponding <code
                class="filename">.pp</code> files.
				</div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.apparmor.html"><strong>Indietro</strong>14.4. Introduction to AppArmor</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Risali</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Partenza</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.other-security-considerations.html"><strong>Avanti</strong>14.6. Altre considerazioni relative alla sicurezza</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.selinux.html">ar-MA</a></li><li><a
              href="../da-DK/sect.selinux.html">da-DK</a></li><li><a
              href="../de-DE/sect.selinux.html">de-DE</a></li><li><a
              href="../el-GR/sect.selinux.html">el-GR</a></li><li><a
              href="../en-US/sect.selinux.html">en-US</a></li><li><a
              href="../es-ES/sect.selinux.html">es-ES</a></li><li><a
              href="../fa-IR/sect.selinux.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.selinux.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.selinux.html">hr-HR</a></li><li><a
              href="../id-ID/sect.selinux.html">id-ID</a></li><li><a
              href="../it-IT/sect.selinux.html">it-IT</a></li><li><a
              href="../ja-JP/sect.selinux.html">ja-JP</a></li><li><a
              href="../pl-PL/sect.selinux.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.selinux.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.selinux.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.selinux.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.selinux.html">tr-TR</a></li><li><a
              href="../zh-CN/sect.selinux.html">zh-CN</a></li></ul></div></body></html>
