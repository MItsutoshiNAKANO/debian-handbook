<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">14.3. Supervisione: prevenire, rilevare, dissuadere</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-it-IT-1.0-1" /><meta
        name="keywords"
        content="Firewall, Netfilter, IDS/NIDS" /><link
        rel="home"
        href="index.html"
        title="Il manuale dell'amministratore Debian" /><link
        rel="up"
        href="security.html"
        title="Capitolo 14. Sicurezza" /><link
        rel="prev"
        href="sect.firewall-packet-filtering.html"
        title="14.2. Firewall o filtraggio dei pacchetti" /><link
        rel="next"
        href="sect.apparmor.html"
        title="14.4. Introduction to AppArmor" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/it-IT/sect.supervision.html" /></head><body
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>Indietro</strong></a></li><li
          class="home">Il manuale dell'amministratore Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>Avanti</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.supervision"></a>14.3. Supervisione: prevenire, rilevare, dissuadere</h2></div></div></div><a
          id="idm140253684804224"
          class="indexterm"></a><div
          class="para">
			Monitoring is an integral part of any security policy for several reasons. Among them, that the goal of security is usually not restricted to guaranteeing data confidentiality, but it also includes ensuring availability of the services. It is therefore imperative to check that everything works as expected, and to detect in a timely manner any deviant behavior or change in quality of the service(s) rendered. Monitoring activity can help detecting intrusion attempts and enable a swift reaction before they cause grave consequences. This section reviews some tools that can be used to monitor several aspects of a Debian system. As such, it completes the section dedicated to generic system monitoring in <a
            class="xref"
            href="advanced-administration.html">Capitolo 12, <em>Amministrazione avanzata</em></a>.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.logcheck"></a>14.3.1. Monitorare i log con <code
                    class="command">logcheck</code></h3></div></div></div><a
            id="idm140253684800208"
            class="indexterm"></a><a
            id="idm140253684799088"
            class="indexterm"></a><a
            id="idm140253684797648"
            class="indexterm"></a><div
            class="para">
				Il comando <code
              class="command">logcheck</code> monitora i file di log ogni ora per impostazione predefinita. Invia messaggi di log inconsueti via email all'amministratore per analisi più approfondite.
			</div><div
            class="para">
				The list of monitored files is stored in <code
              class="filename">/etc/logcheck/logcheck.logfiles</code>; the default values work fine if the <code
              class="filename">/etc/rsyslog.conf</code> file has not been completely overhauled.
			</div><div
            class="para">
				<code
              class="command">logcheck</code> lavora in uno di tre modi più o meno dettagliati: <span
              class="emphasis"><em>paranoid</em></span>, <span
              class="emphasis"><em>server</em></span> e <span
              class="emphasis"><em>workstation</em></span>. Il primo è <span
              class="emphasis"><em>molto</em></span> prolisso, e dovrebbe essere usato solo per server specifici come i firewall. Il secondo modo (predefinito) è consigliato per la maggior parte dei server. L'ultimo è progettato per le workstation, ed è ancora più conciso (filtra maggiormente i messaggi).
			</div><div
            class="para">
				In tutti e tre i casi, <code
              class="command">logcheck</code> probabilmente dovrà essere personalizzato escludendo alcuni messaggi extra (a seconda dei servizi installati), a meno che l'amministratore non voglia veramente ricevere ammassi orari di lunghe e noiose email. Poiché il meccanismo di selezione dei messaggi è piuttosto complesso, il file <code
              class="filename">/usr/share/doc/logcheck-database/README.logcheck-database.gz</code> è una lettura consigliata, anche se impegnativa.
			</div><div
            class="para">
				Le regole applicate possono essere suddivise in varie tipologie:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						quelle che qualificano il messaggio come un tentativo di intrusione (memorizzato in un file nella directory <code
                    class="filename">/etc/logcheck/cracking.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						quelle che cancellano tale qualifica (<code
                    class="filename">/etc/logcheck/cracking.ignore.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						quelle che classificano il messaggio come un allarme di sicurezza (<code
                    class="filename">/etc/logcheck/violations.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						quelle che cancellano questa classificazione (<code
                    class="filename">/etc/logcheck/violations.ignore.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						infine, quelle che si applicano ai rimanenti messaggi (considerati come <span
                    class="emphasis"><em>eventi di sistema</em></span>).
					</div></li></ul></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>ATTENZIONE</em></span> Ignorare un messaggio</strong></p></div></div></div><div
              class="para">
				Tutti i messaggi etichettati come tentativo di intrusione oppure come allarme di sicurezza (seguendo una regola memorizzata in un file <code
                class="filename">/etc/logcheck/violations.d/miofile</code>) possono essere ignorati solamente tramite una regola nei file <code
                class="filename">/etc/logcheck/violations.ignore.d/miofile</code> oppure <code
                class="filename">/etc/logcheck/violations.ignore.d/miofile-<em
                  class="replaceable">estensione</em></code>.
			</div></div><div
            class="para">
				Un evento di sistema è sempre segnalato a meno che una regola in una directory <code
              class="filename">/etc/logcheck/ignore.d.{paranoid,server,workstation}/</code> stabilisca che l'evento debba essere ignorato. Le sole directory prese in considerazione sono esclusivamente quelle corrispondenti ad un livello di prolissità maggiore o uguale alla modalità di funzionamento selezionata.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.monitoring-activity"></a>14.3.2. Attività di monitoraggio</h3></div></div></div><a
            id="idm140253684775248"
            class="indexterm"></a><a
            id="idm140253684773808"
            class="indexterm"></a><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.real-time-monitoring"></a>14.3.2.1. In tempo reale</h4></div></div></div><div
              class="para">
					<code
                class="command">top</code> è uno strumento interattivo che mostra l'elenco dei processi attualmente in esecuzione. L'ordinamento predefinito è basato sull'utilizzo corrente del processore e può essere ottenuto con il tasto <span
                class="keycap"><strong>P</strong></span>. Altri tipi di ordinamento sono per occupazione di memoria (tasto <span
                class="keycap"><strong>M</strong></span>), per tempo totale di processore (tasto <span
                class="keycap"><strong>T</strong></span>) e per identificatore di processo (tasto <span
                class="keycap"><strong>N</strong></span>). Il tasto <span
                class="keycap"><strong>r</strong></span> permette il <span
                class="emphasis"><em>renice</em></span> di un processo, cioè la variazione della sua priorità.
				</div><a
              id="idm140253684767824"
              class="indexterm"></a><div
              class="para">
					Quando il sistema sembra essere sovraccarico, <code
                class="command">top</code> è uno strumento fondamentale per capire quali processi competono per il tempo di processore o consumano troppa memoria. In particolare, spesso è interessante controllare se il processo che utilizza le risorse corrisponde realmente ad un servizio che la macchina mette a disposizione. Un processo sconosciuto in esecuzione con utente www-data dovrebbe subito saltare all'occhio ed essere controllato, dato che potenzialmente potrebbe essere l'istanza di un programma installato ed eseguito nel sistema attraverso la vulnerabilità di un'applicazione web.
				</div><div
              class="para">
					<code
                class="command">top</code> è uno strumento molto flessibile e le pagine del manuale riportano i dettagli di come modificarne la visualizzazione e adattarla alle abitudini e bisogni personali.
				</div><div
              class="para">
					The <code
                class="command">gnome-system-monitor</code> graphical tool is similar to <code
                class="command">top</code> and it provides roughly the same features.
				</div><a
              id="idm140253684762736"
              class="indexterm"></a></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.monitoring-history"></a>14.3.2.2. Storico</h4></div></div></div><a
              id="idm140253684760400"
              class="indexterm"></a><div
              class="para">
					Il carico del processore, il traffico di rete e lo spazio libero su disco sono informazioni che variano costantemente. Mantenere uno storico della loro evoluzione spesso è utile nel determinare esattamente come viene utilizzato un computer.
				</div><a
              id="idm140253684758720"
              class="indexterm"></a><a
              id="idm140253684757760"
              class="indexterm"></a><div
              class="para">
					Esistono molti strumenti dedicati a questo compito. La maggior parte può recuperare dati via SNMP (<span
                class="emphasis"><em>Simple Network Management Protocol</em></span>) al fine di centralizzare l'informazione. Un ulteriore beneficio è che si possono recuperare dati da elementi di rete che non necessariamente sono computer generici, come ad esempio switch di rete o router dedicati.
				</div><div
              class="para">
					This book deals with Munin in some detail (see <a
                class="xref"
                href="sect.monitoring.html#sect.munin">Sezione 12.4.1, «Impostazione di Munin»</a>) as part of <a
                class="xref"
                href="advanced-administration.html">Capitolo 12: «<em>Amministrazione avanzata</em>»</a>. Debian also provides a similar tool, <span
                class="pkg pkg">cacti</span>. Its deployment is slightly more complex, since it is based solely on SNMP. Despite having a web interface, grasping the concepts involved in configuration still requires some effort. Reading the HTML documentation (<code
                class="filename">/usr/share/doc/cacti/html/index.html</code>) should be considered a prerequisite.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVA</em></span> <code
                          class="command">mrtg</code></strong></p></div></div></div><a
                id="idm140253684751264"
                class="indexterm"></a><div
                class="para">
					<code
                  class="command">mrtg</code> (nel pacchetto che ha lo stesso nome) è un vecchio strumento. Nonostante sia un po' grezzo, può aggregare dati storici e visualizzarli sotto forma di grafici. Il pacchetto comprende una serie di script dedicati alla raccolta dei dati monitorati più diffusi come il carico del processore, il traffico di rete, le visite alle pagine web e così via.
				</div><div
                class="para">
					I pacchetti <span
                  class="pkg pkg">mrtg-contrib</span> e <span
                  class="pkg pkg">mrtgutils</span> contengono script di esempio che possono essere utilizzati direttamente.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="idm140253684746576"></a>14.3.3. Rilevare le modifiche</h3></div></div></div><div
            class="para">
				Una volta che il sistema è installato e configurato, a meno di aggiornamenti di sicurezza, la maggior parte dei file e directory rimangono statici, dati a parte. È allora interessante fare in modo che i file realmente non possano cambiare: ogni variazione inattesa dovrebbe perciò catturare la nostra attenzione. Questa sezione presenta alcuni strumenti che permettono di monitorare i file e di avvisare l'amministratore quando si verificano cambiamenti non previsti (o semplicemente di elencarli).
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.dpkg-verify"></a>14.3.3.1. Auditing Packages with <code
                      class="command">dpkg --verify</code></h4></div></div></div><a
              id="idm140253684743424"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>APPROFONDIMENTI</em></span> Proteggere contro le modifiche degli autori originali</strong></p></div></div></div><div
                class="para">
					<code
                  class="command">dpkg --verify</code> is useful in detecting changes to files coming from a Debian package, but it will be useless if the package itself is compromised, for instance if the Debian mirror is compromised. Protecting against this class of attacks involves using APT's digital signature verification system (see <a
                  class="xref"
                  href="sect.package-authentication.html">Sezione 6.5, «Controllare l'autenticità dei pacchetti»</a>), and taking care to only install packages from a certified origin.
				</div></div><div
              class="para">
					<code
                class="command">dpkg --verify</code> (or <code
                class="command">dpkg -V</code>) is an interesting tool since it allows finding what installed files have been modified (potentially by an attacker), but this should be taken with a grain of salt. To do its job it relies on checksums stored in dpkg's own database which is stored on the hard disk (they can be found in <code
                class="filename">/var/lib/dpkg/info/<em
                  class="replaceable">package</em>.md5sums</code>); a thorough attacker will therefore update these files so they contain the new checksums for the subverted files.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>BACK TO BASICS</em></span> File fingerprint</strong></p></div></div></div><a
                id="idm140253684734832"
                class="indexterm"></a><a
                id="idm140253684733872"
                class="indexterm"></a><a
                id="idm140253684732912"
                class="indexterm"></a><a
                id="idm140253684731952"
                class="indexterm"></a><div
                class="para">
					As a reminder: a fingerprint is a value, often a number (even though in hexadecimal notation), that contains a kind of signature for the contents of a file. This signature is calculated with an algorithm (MD5 or SHA1 being well-known examples) that more or less guarantee that even the tiniest change in the file contents implies a change in the fingerprint; this is known as the “avalanche effect”. This allows a simple numerical fingerprint to serve as a litmus test to check whether the contents of a file have been altered. These algorithms are not reversible; in other words, for most of them, knowing a fingerprint doesn't allow finding the corresponding contents. Recent mathematical advances seem to weaken the absoluteness of these principles, but their use is not called into question so far, since creating different contents yielding the same fingerprint still seems to be quite a difficult task.
				</div></div><div
              class="para">
					Running <code
                class="command">dpkg -V</code> will verify all installed packages and will print out a line for each file with a failing test. The output format is the same as the one of <code
                class="command">rpm -V</code> where each character denotes a test on some specific meta-data. Unfortunately <code
                class="command">dpkg</code> does not store the meta-data needed for most tests and will thus output question marks for them. Currently only the checksum test can yield a "5" on the third character (when it fails).
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>dpkg -V</code></strong>
<code
                class="computeroutput">??5??????   /lib/systemd/system/ssh.service
??5?????? c /etc/libvirt/qemu/networks/default.xml
??5?????? c /etc/lvm/lvm.conf
??5?????? c /etc/salt/roster</code></pre><div
              class="para">
					In the sample above, dpkg reports a change to SSH's service file that the administrator made to the packaged file instead of using an appropriate <code
                class="filename">/etc/systemd/system/ssh.service</code> override (which would be stored below <code
                class="filename">/etc</code> like any configuration change should be). It also lists multiple configuration files (identified by the "c" letter on the second field) that had been legitimately modified.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.debsums"></a>14.3.3.2. Controllo dei pacchetti: <code
                      class="command">debsums</code> e i suoi limiti</h4></div></div></div><a
              id="idm140253684722160"
              class="indexterm"></a><div
              class="para">
					<code
                class="command">debsums</code> is the ancestor of <code
                class="command">dpkg -V</code> and is thus mostly obsolete. It suffers from the same limitations than dpkg. Fortunately, some of the limitations can be worked-around (whereas dpkg does not offer similar work-arounds).
				</div><div
              class="para">
					Since the data on the disk cannot be trusted, <code
                class="command">debsums</code> offers to do its checks based on <code
                class="filename">.deb</code> files instead of relying on dpkg's database. To download trusted <code
                class="filename">.deb</code> files of all the packages installed, we can rely on APT's authenticated downloads. This operation can be slow and tedious, and should therefore not be considered a proactive technique to be used on a regular basis.
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</code></strong>
<code
                class="computeroutput">[ ... ]
# </code><strong
                class="userinput"><code>debsums -p /var/cache/apt/archives --generate=all</code></strong></pre><div
              class="para">
					Da notare che questo esempio utilizza il comando <code
                class="command">grep-status</code> del pacchetto <span
                class="pkg pkg">dctrl-tools</span>, che non è installato in modo predefinito.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="idm140253684713728"></a>14.3.3.3. Monitorare i file: AIDE</h4></div></div></div><a
              id="idm140253684712928"
              class="indexterm"></a><div
              class="para">
					Lo strumento AIDE (<span
                class="emphasis"><em>Advanced Intrusion Detection Environment</em></span>) permette di verificare l'integrità dei file e rileva tutti i cambiamenti rispetto ad una immagine valida archiviata del sistema. Questa immagine viene memorizzata in un database (<code
                class="filename">/var/lib/aide/aide.db</code>) contenente le informazioni significative di tutti i file del sistema (impronte digitali, permessi, data e ora e così via). Questo database viene generato inizialmente con <code
                class="command">aideinit</code>; esso viene poi utilizzato su base giornaliera (dallo script <code
                class="filename">/etc/cron.daily/aide</code>) per verificare che non sia cambiato nulla di significativo. Quando viene rilevata una modifica, AIDE la elenca nei file di log (<code
                class="filename">/var/log/aide/*.log</code>) e invia i risultati via email all'amministratore.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>IN PRATICA</em></span> Proteggere il database</strong></p></div></div></div><div
                class="para">
					Dal momento che AIDE usa un database locale per confrontare lo stato dei file, l'affidabilità dei suoi risultati è direttamente legata alla validità del suo database. Se un autore di un attacco acquisisce i permessi di root su un sistema compromesso, sarà in grado di sostituire il database per nascondere le sue tracce. Una possibile soluzione è quella di salvare i relativi dati su un supporto a sola lettura.
				</div></div><div
              class="para">
					Sono presenti molte opzioni in <code
                class="filename">/etc/default/aide</code> per modificare il comportamento del pacchetto <span
                class="pkg pkg">aide</span>. La configurazione vera e propria di AIDE viene memorizzata in <code
                class="filename">/etc/aide/aide.conf</code> e <code
                class="filename">/etc/aide/aide.conf.d/</code> (in realtà, questi file vengono utilizzati da <code
                class="command">update-aide.conf</code> per generare <code
                class="filename">/var/lib/aide/aide.conf.autogenerated</code>). La configurazione indica quali proprietà di quali file devono essere controllate. Per esempio, il contenuto dei file di log cambia regolarmente, e tali cambiamenti possono essere ignorati fino a quando i permessi di questi file rimangono invariati, ma sia il contenuto che i permessi dei programmi eseguibili devono rimanere costanti. Anche se non molto complessa, la sintassi della configurazione non è del tutto intuitiva, ed è quindi consigliato leggere la pagina di manuale <span
                class="citerefentry"><span
                  class="refentrytitle">aide.conf</span>(5)</span>.
				</div><div
              class="para">
					Una nuova versione del database è generata giornalmente in <code
                class="filename">/var/lib/aide/aide.db.new</code>; se tutte le variazioni raccolte sono legittime, viene usato per sostituire il database di riferimento.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVE</em></span> Tripwire e Samhain</strong></p></div></div></div><div
                class="para">
					Tripwire è molto simile ad AIDE; anche la sintassi del file di configurazione è bene o male la stessa. La principale novità fornita da <span
                  class="pkg pkg">tripwire</span> è il meccanismo di firma del file di configurazione, affinché un autore di un attacco non possa associarlo a una diversa versione del database di riferimento.
				</div><div
                class="para">
					Anche Samhain offre caratteristiche simili, oltre ad alcune funzioni per permettere la rilevazione dei rootkit (vedere il riquadro APPROFODNIMENTI). Può anche essere distribuito globalmente in rete, memorizzando i suoi risultati in un server centrale (con firma).
				</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>APPROFONDIMENTI</em></span> I pacchetti <span
                          class="pkg pkg">checksecurity</span> e <span
                          class="pkg pkg">chkrootkit</span>/<span
                          class="pkg pkg">rkhunter</span> </strong></p></div></div></div><a
                id="idm140253684693232"
                class="indexterm"></a><div
                class="para">
					Il primo di questi pacchetti contiene numerosi script brevi che eseguono controlli di base sul sistema (password vuote, nuovi file con setuid e così via) e avvertono l'amministratore se necessario. Nonostante il suo nome esplicito, un amministratore non dovrebbe affidarsi solamente ad esso per garantire la sicurezza di un sistema Linux.
				</div><div
                class="para">
					I pacchetti <span
                  class="pkg pkg">chkrootkit</span> e <span
                  class="pkg pkg">rkhunter</span> permettono di cercare <span
                  class="emphasis"><em>rootkit</em></span> potenzialmente installati nel sistema. Come promemoria, un rootkit è una parte di software progettata per nascondere il fatto che il sistema è compromesso mentre mantiene in modo discreto il controllo sulla macchina. I test non sono affidabili al 100%, ma solitamente riescono ad attirare l'attenzione dell'amministratore su potenziali problemi.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.intrusion-detection"></a>14.3.4. Rilevare intrusioni (IDS/NIDS)</h3></div></div></div><a
            id="idm140253684687056"
            class="indexterm"></a><a
            id="idm140253684686096"
            class="indexterm"></a><a
            id="idm140253684685168"
            class="indexterm"></a><a
            id="idm140253684684208"
            class="indexterm"></a><a
            id="idm140253686195696"
            class="indexterm"></a><a
            id="idm140253686194736"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>FONDAMENTALI</em></span> «Denial of service»</strong></p></div></div></div><a
              id="idm140253686192176"
              class="indexterm"></a><div
              class="para">
				Un attacco «denial of service» ha un solo scopo: bloccare la disponibilità di un servizio. Che un attacco di questo tipo implichi il sovraccarico del server tramite interrogazioni o lo sfruttamento di un bug, il risultato finale è il medesimo: il servizio non è più fruibile. Gli utenti ordinari sono scontenti, e il soggetto che ospita il servizio di rete preso di mira subisce una perdita di reputazione (e probabilmente di ricavi, per esempio se il servizio è un sito di e-commerce).
			</div><div
              class="para">
				Such an attack is sometimes “distributed”; this usually involves overloading the server with large numbers of queries coming from many different sources so that the server becomes unable to answer the legitimate queries. These types of attacks have gained well-known acronyms: <acronym
                class="acronym">DDoS</acronym> and <acronym
                class="acronym">DoS</acronym> (depending on whether the denial of service attack is distributed or not).
			</div></div><div
            class="para">
				<code
              class="command">suricata</code> (in the Debian package of the same name) is a NIDS — a <span
              class="emphasis"><em>Network Intrusion Detection System</em></span>. Its function is to listen to the network and try to detect infiltration attempts and/or hostile acts (including denial of service attacks). All these events are logged in multiple files in <code
              class="filename">/var/log/suricata</code>. There are third party tools (Kibana/logstash) to better browse all the data collected. <div
              class="url">→ <a
                href="http://suricata-ids.org">http://suricata-ids.org</a></div> <div
              class="url">→ <a
                href="https://www.elastic.co/products/kibana">https://www.elastic.co/products/kibana</a></div>
			</div><a
            id="idm140253686184400"
            class="indexterm"></a><a
            id="idm140253686183280"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>ATTENZIONE</em></span> Raggio d'azione</strong></p></div></div></div><div
              class="para">
				The effectiveness of <code
                class="command">suricata</code> is limited by the traffic seen on the monitored network interface. It will obviously not be able to detect anything if it cannot observe the real traffic. When plugged into a network switch, it will therefore only monitor attacks targeting the machine it runs on, which is probably not the intention. The machine hosting <code
                class="command">suricata</code> should therefore be plugged into the “mirror” port of the switch, which is usually dedicated to chaining switches and therefore gets all the traffic.
			</div></div><div
            class="para">
				Configuring suricata involves reviewing and editing <code
              class="filename">/etc/suricata/suricata-debian.yaml</code>, which is very long because each parameter is abundantly commented. A minimal configuration requires describing the range of addresses that the local network covers (<code
              class="literal">HOME_NET</code> parameter). In practice, this means the set of all potential attack targets. But getting the most of it requires reading it in full and adapting it to the local situation.
			</div><div
            class="para">
				On top of this, you should also edit <code
              class="filename">/etc/default/suricata</code> to define the network interface to monitor and to enable the init script (by setting <code
              class="literal">RUN=yes</code>). You might also want to set <code
              class="literal">LISTENMODE=pcap</code> because the default <code
              class="literal">LISTENMODE=nfqueue</code> requires further configuration to work properly (the netfilter firewall must be configured to pass packets to some user-space queue handled by suricata via the <code
              class="literal">NFQUEUE</code> target).
			</div><div
            class="para">
				To detect bad behaviour, <code
              class="command">suricata</code> needs a set of monitoring rules: you can find such rules in the <span
              class="pkg pkg">snort-rules-default</span> package. <code
              class="command">snort</code> is the historical reference in the IDS ecosystem and <code
              class="command">suricata</code> is able to reuse rules written for it. Unfortunately that package is missing from <span
              class="distribution distribution">Debian Jessie</span> and should be retrieved from another Debian release like <span
              class="distribution distribution">Testing</span> or <span
              class="distribution distribution">Unstable</span>.
			</div><div
            class="para">
				Alternatively, <code
              class="command">oinkmaster</code> (in the package of the same name) can be used to download Snort rulesets from external sources.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>APPROFONDIMENTI</em></span> Integrazione con <code
                        class="command">prelude</code></strong></p></div></div></div><div
              class="para">
				Prelude permette il monitoraggio centralizzato delle informazioni di sicurezza. La sua architetture modulare fornisce un server (il <span
                class="emphasis"><em>manager</em></span> in <span
                class="pkg pkg">prelude-manager</span>) che raccoglie gli allarmi generati da <span
                class="emphasis"><em>sensori</em></span> di varie tipologie.
			</div><div
              class="para">
				Suricata can be configured as such a sensor. Other possibilities include <span
                class="emphasis"><em>prelude-lml</em></span> (<span
                class="emphasis"><em>Log Monitor Lackey</em></span>) which monitors log files (in a manner similar to <code
                class="command">logcheck</code>, described in <a
                class="xref"
                href="sect.supervision.html#sect.logcheck">Sezione 14.3.1, «Monitorare i log con <code
                  class="command">logcheck</code>»</a>).
			</div><a
              id="idm140253686162032"
              class="indexterm"></a></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>Indietro</strong>14.2. Firewall o filtraggio dei pacchetti</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Risali</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Partenza</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>Avanti</strong>14.4. Introduction to AppArmor</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.supervision.html">ar-MA</a></li><li><a
              href="../da-DK/sect.supervision.html">da-DK</a></li><li><a
              href="../de-DE/sect.supervision.html">de-DE</a></li><li><a
              href="../el-GR/sect.supervision.html">el-GR</a></li><li><a
              href="../en-US/sect.supervision.html">en-US</a></li><li><a
              href="../es-ES/sect.supervision.html">es-ES</a></li><li><a
              href="../fa-IR/sect.supervision.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.supervision.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.supervision.html">hr-HR</a></li><li><a
              href="../id-ID/sect.supervision.html">id-ID</a></li><li><a
              href="../it-IT/sect.supervision.html">it-IT</a></li><li><a
              href="../ja-JP/sect.supervision.html">ja-JP</a></li><li><a
              href="../pl-PL/sect.supervision.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.supervision.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.supervision.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.supervision.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.supervision.html">tr-TR</a></li><li><a
              href="../zh-CN/sect.supervision.html">zh-CN</a></li></ul></div></body></html>
